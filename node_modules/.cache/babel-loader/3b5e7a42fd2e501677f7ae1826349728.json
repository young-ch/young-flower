{"remainingRequest":"/Users/youngchelchoi/Desktop/workspace/flower/flower-backoffice/node_modules/babel-loader/lib/index.js!/Users/youngchelchoi/Desktop/workspace/flower/flower-backoffice/node_modules/vuetify/lib/util/mergeData.js","dependencies":[{"path":"/Users/youngchelchoi/Desktop/workspace/flower/flower-backoffice/node_modules/vuetify/lib/util/mergeData.js","mtime":1665531753789},{"path":"/Users/youngchelchoi/Desktop/workspace/flower/flower-backoffice/babel.config.js","mtime":1665531625438},{"path":"/Users/youngchelchoi/Desktop/workspace/flower/flower-backoffice/node_modules/cache-loader/dist/cjs.js","mtime":1665531750829},{"path":"/Users/youngchelchoi/Desktop/workspace/flower/flower-backoffice/node_modules/babel-loader/lib/index.js","mtime":1665531751248}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IHsgY2FtZWxpemUsIHdyYXBJbkFycmF5IH0gZnJvbSAnLi9oZWxwZXJzJzsKY29uc3QgcGF0dGVybiA9IHsKICBzdHlsZUxpc3Q6IC87KD8hW14oXSpcKSkvZywKICBzdHlsZVByb3A6IC86KC4qKS8KfTsKZnVuY3Rpb24gcGFyc2VTdHlsZShzdHlsZSkgewogIGNvbnN0IHN0eWxlTWFwID0ge307CiAgZm9yIChjb25zdCBzIG9mIHN0eWxlLnNwbGl0KHBhdHRlcm4uc3R5bGVMaXN0KSkgewogICAgbGV0IFtrZXksIHZhbF0gPSBzLnNwbGl0KHBhdHRlcm4uc3R5bGVQcm9wKTsKICAgIGtleSA9IGtleS50cmltKCk7CiAgICBpZiAoIWtleSkgewogICAgICBjb250aW51ZTsKICAgIH0gLy8gTWF5IGJlIHVuZGVmaW5lZCBpZiB0aGUgYGtleTogdmFsdWVgIHBhaXIgaXMgaW5jb21wbGV0ZS4KCiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHsKICAgICAgdmFsID0gdmFsLnRyaW0oKTsKICAgIH0KICAgIHN0eWxlTWFwW2NhbWVsaXplKGtleSldID0gdmFsOwogIH0KICByZXR1cm4gc3R5bGVNYXA7Cn0KZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VEYXRhKCkgewogIGNvbnN0IG1lcmdlVGFyZ2V0ID0ge307CiAgbGV0IGkgPSBhcmd1bWVudHMubGVuZ3RoOwogIGxldCBwcm9wOyAvLyBBbGxvdyBmb3IgdmFyaWFkaWMgYXJndW1lbnQgbGVuZ3RoLgoKICB3aGlsZSAoaS0tKSB7CiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGRhdGEgcHJvcGVydGllcyBhbmQgZXhlY3V0ZSBtZXJnZSBzdHJhdGVnaWVzCiAgICAvLyBPYmplY3Qua2V5cyBlbGltaW5hdGVzIG5lZWQgZm9yIGhhc093blByb3BlcnR5IGNhbGwKICAgIGZvciAocHJvcCBvZiBPYmplY3Qua2V5cyhhcmd1bWVudHNbaV0pKSB7CiAgICAgIHN3aXRjaCAocHJvcCkgewogICAgICAgIC8vIEFycmF5IG1lcmdlIHN0cmF0ZWd5IChhcnJheSBjb25jYXRlbmF0aW9uKQogICAgICAgIGNhc2UgJ2NsYXNzJzoKICAgICAgICBjYXNlICdkaXJlY3RpdmVzJzoKICAgICAgICAgIGlmIChhcmd1bWVudHNbaV1bcHJvcF0pIHsKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSBtZXJnZUNsYXNzZXMobWVyZ2VUYXJnZXRbcHJvcF0sIGFyZ3VtZW50c1tpXVtwcm9wXSk7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICdzdHlsZSc6CiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gbWVyZ2VTdHlsZXMobWVyZ2VUYXJnZXRbcHJvcF0sIGFyZ3VtZW50c1tpXVtwcm9wXSk7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBTcGFjZSBkZWxpbWl0ZWQgc3RyaW5nIGNvbmNhdGVuYXRpb24gc3RyYXRlZ3kKCiAgICAgICAgY2FzZSAnc3RhdGljQ2xhc3MnOgogICAgICAgICAgaWYgKCFhcmd1bWVudHNbaV1bcHJvcF0pIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAobWVyZ2VUYXJnZXRbcHJvcF0gPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9ICcnOwogICAgICAgICAgfQogICAgICAgICAgaWYgKG1lcmdlVGFyZ2V0W3Byb3BdKSB7CiAgICAgICAgICAgIC8vIE5vdCBhbiBlbXB0eSBzdHJpbmcsIHNvIGNvbmNhdGVuYXRlCiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdICs9ICcgJzsKICAgICAgICAgIH0KICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdICs9IGFyZ3VtZW50c1tpXVtwcm9wXS50cmltKCk7CiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBPYmplY3QsIHRoZSBwcm9wZXJ0aWVzIG9mIHdoaWNoIHRvIG1lcmdlIHZpYSBhcnJheSBtZXJnZSBzdHJhdGVneSAoYXJyYXkgY29uY2F0ZW5hdGlvbikuCiAgICAgICAgLy8gQ2FsbGJhY2sgbWVyZ2Ugc3RyYXRlZ3kgbWVyZ2VzIGNhbGxiYWNrcyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSwKICAgICAgICAvLyBzbyB0aGF0IHRoZSBsYXN0IGRlZmluZWQgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIGZpcnN0LgogICAgICAgIC8vIFRoaXMgaXMgZG9uZSBzaW5jZSB0byBtaW1pYyBob3cgT2JqZWN0LmFzc2lnbiBtZXJnaW5nCiAgICAgICAgLy8gdXNlcyB0aGUgbGFzdCBnaXZlbiB2YWx1ZSB0byBhc3NpZ24uCgogICAgICAgIGNhc2UgJ29uJzoKICAgICAgICBjYXNlICduYXRpdmVPbic6CiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gbWVyZ2VMaXN0ZW5lcnMobWVyZ2VUYXJnZXRbcHJvcF0sIGFyZ3VtZW50c1tpXVtwcm9wXSk7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBPYmplY3QgbWVyZ2Ugc3RyYXRlZ3kKCiAgICAgICAgY2FzZSAnYXR0cnMnOgogICAgICAgIGNhc2UgJ3Byb3BzJzoKICAgICAgICBjYXNlICdkb21Qcm9wcyc6CiAgICAgICAgY2FzZSAnc2NvcGVkU2xvdHMnOgogICAgICAgIGNhc2UgJ3N0YXRpY1N0eWxlJzoKICAgICAgICBjYXNlICdob29rJzoKICAgICAgICBjYXNlICd0cmFuc2l0aW9uJzoKICAgICAgICAgIGlmICghYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKCFtZXJnZVRhcmdldFtwcm9wXSkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9IHt9OwogICAgICAgICAgfQogICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSB7CiAgICAgICAgICAgIC4uLmFyZ3VtZW50c1tpXVtwcm9wXSwKICAgICAgICAgICAgLi4ubWVyZ2VUYXJnZXRbcHJvcF0KICAgICAgICAgIH07CiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBSZWFzc2lnbm1lbnQgc3RyYXRlZ3kgKG5vIG1lcmdlKQoKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgLy8gc2xvdCwga2V5LCByZWYsIHRhZywgc2hvdywga2VlcEFsaXZlCiAgICAgICAgICBpZiAoIW1lcmdlVGFyZ2V0W3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gYXJndW1lbnRzW2ldW3Byb3BdOwogICAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQogIHJldHVybiBtZXJnZVRhcmdldDsKfQpleHBvcnQgZnVuY3Rpb24gbWVyZ2VTdHlsZXModGFyZ2V0LCBzb3VyY2UpIHsKICBpZiAoIXRhcmdldCkgcmV0dXJuIHNvdXJjZTsKICBpZiAoIXNvdXJjZSkgcmV0dXJuIHRhcmdldDsKICB0YXJnZXQgPSB3cmFwSW5BcnJheSh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHBhcnNlU3R5bGUodGFyZ2V0KSA6IHRhcmdldCk7CiAgcmV0dXJuIHRhcmdldC5jb25jYXQodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBwYXJzZVN0eWxlKHNvdXJjZSkgOiBzb3VyY2UpOwp9CmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNsYXNzZXModGFyZ2V0LCBzb3VyY2UpIHsKICBpZiAoIXNvdXJjZSkgcmV0dXJuIHRhcmdldDsKICBpZiAoIXRhcmdldCkgcmV0dXJuIHNvdXJjZTsKICByZXR1cm4gdGFyZ2V0ID8gd3JhcEluQXJyYXkodGFyZ2V0KS5jb25jYXQoc291cmNlKSA6IHNvdXJjZTsKfQpleHBvcnQgZnVuY3Rpb24gbWVyZ2VMaXN0ZW5lcnMoLi4uYXJncykgewogIGlmICghYXJnc1swXSkgcmV0dXJuIGFyZ3NbMV07CiAgaWYgKCFhcmdzWzFdKSByZXR1cm4gYXJnc1swXTsKICBjb25zdCBkZXN0ID0ge307CiAgZm9yIChsZXQgaSA9IDI7IGktLTspIHsKICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07CiAgICBmb3IgKGNvbnN0IGV2ZW50IGluIGFyZykgewogICAgICBpZiAoIWFyZ1tldmVudF0pIGNvbnRpbnVlOwogICAgICBpZiAoZGVzdFtldmVudF0pIHsKICAgICAgICAvLyBNZXJnZSBjdXJyZW50IGxpc3RlbmVycyBiZWZvcmUgKGJlY2F1c2Ugd2UgYXJlIGl0ZXJhdGluZyBiYWNrd2FyZHMpLgogICAgICAgIC8vIE5vdGUgdGhhdCBuZWl0aGVyICJ0YXJnZXQiIG9yICJzb3VyY2UiIG11c3QgYmUgYWx0ZXJlZC4KICAgICAgICBkZXN0W2V2ZW50XSA9IFtdLmNvbmNhdChhcmdbZXZlbnRdLCBkZXN0W2V2ZW50XSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gU3RyYWlnaHQgYXNzaWduLgogICAgICAgIGRlc3RbZXZlbnRdID0gYXJnW2V2ZW50XTsKICAgICAgfQogICAgfQogIH0KICByZXR1cm4gZGVzdDsKfQ=="},{"version":3,"mappings":"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","names":["camelize","wrapInArray","pattern","styleList","styleProp","parseStyle","style","styleMap","s","split","key","val","trim","mergeData","mergeTarget","i","arguments","length","prop","Object","keys","mergeClasses","mergeStyles","undefined","mergeListeners","target","source","concat","args","dest","arg","event"],"sourceRoot":"","sources":["../../src/util/mergeData.ts"],"sourcesContent":["/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\n/* eslint-disable max-statements */\nimport { VNodeData } from 'vue'\nimport { camelize, wrapInArray } from './helpers'\n\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/,\n} as const\n\nfunction parseStyle (style: string) {\n  const styleMap: Dictionary<any> = {}\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp)\n    key = key.trim()\n    if (!key) {\n      continue\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === 'string') {\n      val = val.trim()\n    }\n    styleMap[camelize(key)] = val\n  }\n\n  return styleMap\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nexport default function mergeData (...vNodeData: VNodeData[]): VNodeData\nexport default function mergeData (): VNodeData {\n  const mergeTarget: VNodeData & Dictionary<any> = {}\n  let i: number = arguments.length\n  let prop: string\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Space delimited string concatenation strategy\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = ''\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' '\n          }\n          mergeTarget[prop] += arguments[i][prop].trim()\n          break\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Object merge strategy\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] }\n          break\n        // Reassignment strategy (no merge)\n        default: // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop]\n          }\n      }\n    }\n  }\n\n  return mergeTarget\n}\n\nexport function mergeStyles (\n  target: undefined | string | object[] | object,\n  source: undefined | string | object[] | object\n) {\n  if (!target) return source\n  if (!source) return target\n\n  target = wrapInArray(typeof target === 'string' ? parseStyle(target) : target)\n\n  return (target as object[]).concat(typeof source === 'string' ? parseStyle(source) : source)\n}\n\nexport function mergeClasses (target: any, source: any) {\n  if (!source) return target\n  if (!target) return source\n\n  return target ? wrapInArray(target).concat(source) : source\n}\n\nexport function mergeListeners (...args: [\n  { [key: string]: Function | Function[] } | undefined,\n  { [key: string]: Function | Function[] } | undefined\n]) {\n  if (!args[0]) return args[1]\n  if (!args[1]) return args[0]\n\n  const dest: { [key: string]: Function | Function[] } = {}\n\n  for (let i = 2; i--;) {\n    const arg = args[i]\n    for (const event in arg) {\n      if (!arg[event]) continue\n\n      if (dest[event]) {\n        // Merge current listeners before (because we are iterating backwards).\n        // Note that neither \"target\" or \"source\" must be altered.\n        dest[event] = ([] as Function[]).concat(arg[event], dest[event])\n      } else {\n        // Straight assign.\n        dest[event] = arg[event]\n      }\n    }\n  }\n\n  return dest\n}\n"]}]}