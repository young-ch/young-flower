{"version":3,"file":"extension.cjs.js","sources":["../node_modules/@emmetio/scanner/scanner.es.js","../node_modules/@emmetio/abbreviation/dist/abbreviation.es.js","../node_modules/@emmetio/css-abbreviation/dist/css-abbreviation.es.js","../src/lib/config.ts","../../action-utils/node_modules/@emmetio/scanner/scanner.es.js","../../action-utils/node_modules/@emmetio/html-matcher/dist/html-matcher.es.js","../../action-utils/node_modules/@emmetio/css-matcher/dist/css-matcher.es.js","../../action-utils/node_modules/@emmetio/abbreviation/dist/abbreviation.es.js","../../action-utils/node_modules/@emmetio/css-abbreviation/dist/css-abbreviation.es.js","../../action-utils/node_modules/emmet/dist/emmet.es.js","../../action-utils/dist/action-utils.es.js","../src/lib/utils.ts","../node_modules/@emmetio/html-matcher/dist/html-matcher.es.js","../src/lib/syntax.ts","../node_modules/emmet/dist/emmet.es.js","../node_modules/@emmetio/css-matcher/dist/css-matcher.es.js","../node_modules/@emmetio/math-expression/dist/math.es.js","../src/lib/output.ts","../src/lib/emmet.ts","../src/abbreviation.ts","../src/lib/match-tags.ts","../src/mode/utils.ts","../src/mode/markup.ts","../src/mode/stylesheet.ts","../src/mode/snippet.ts","../src/commands/expand-abbreviation.ts","../src/commands/reset-abbreviation.ts","../src/commands/capture-abbreviation.ts","../src/commands/enter-abbreviation.ts","../src/commands/insert-line-break.ts","../src/commands/wrap-with-abbreviation.ts","../src/commands/balance.ts","../src/commands/comment.ts","../src/commands/evaluate-math.ts","../src/commands/go-to-edit-point.ts","../src/commands/go-to-tag-pair.ts","../src/commands/inc-dec-number.ts","../src/commands/remove-tag.ts","../src/commands/select-item.ts","../src/commands/split-join-tag.ts","../src/extension.ts"],"sourcesContent":["const defaultQuotedOptions = {\n    escape: 92,\n    throws: false\n};\n/**\n * Check if given code is a number\n */\nfunction isNumber(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n */\nfunction isAlphaNumeric(code) {\n    return isNumber(code) || isAlpha(code);\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha(code);\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @return `true` if quoted string was consumed. The contents of quoted string\n * will be available as `stream.current()`\n */\nfunction eatQuoted(stream, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    const quote = stream.peek();\n    if (stream.eat(isQuote)) {\n        while (!stream.eof()) {\n            switch (stream.next()) {\n                case quote:\n                    stream.start = start;\n                    return true;\n                case options.escape:\n                    stream.next();\n                    break;\n            }\n        }\n        // If we’re here then stream wasn’t properly consumed.\n        // Revert stream and decide what to do\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error('Unable to consume quoted string');\n        }\n    }\n    return false;\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param open Character code of pair opening\n * @param close Character code of pair closing\n * @return Returns `true` if character pair was successfully consumed, it’s\n * content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    if (stream.eat(open)) {\n        let stack = 1;\n        let ch;\n        while (!stream.eof()) {\n            if (eatQuoted(stream, options)) {\n                continue;\n            }\n            ch = stream.next();\n            if (ch === open) {\n                stack++;\n            }\n            else if (ch === close) {\n                stack--;\n                if (!stack) {\n                    stream.start = start;\n                    return true;\n                }\n            }\n            else if (ch === options.escape) {\n                stream.next();\n            }\n        }\n        // If we’re here then paired character can’t be consumed\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n        }\n    }\n    return false;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nexport default Scanner;\nexport { ScannerError, eatPair, eatQuoted, isAlpha, isAlphaNumeric, isAlphaNumericWord, isAlphaWord, isNumber, isQuote, isSpace, isWhiteSpace };\n//# sourceMappingURL=scanner.es.js.map\n","import Scanner, { isAlphaNumericWord, isSpace, isQuote as isQuote$1, isNumber, isAlpha, ScannerError } from '@emmetio/scanner';\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    const token = peek(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner(abbr);\n    const result = statements(scanner, options);\n    if (readable(scanner)) {\n        throw error(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable(scanner)) {\n        if (node = element(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume(scanner, isSiblingOperator)) {\n                continue;\n            }\n            else if (consume(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket(token, 'group', false)) {\n            result.repeat = repeater(scanner);\n        }\n        return result;\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume(scanner, isWhiteSpace)) {\n                throw error(scanner, `Unexpected \"${peek(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator(peek(scanner), type)) {\n        scanner.pos++;\n        const attr = {\n            name: [createLiteral(type)]\n        };\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: it’s a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal(scanner, true)) {\n        return {\n            name: slice(scanner),\n            value: consume(scanner, isEquals) && (quoted(scanner) || literal(scanner, true))\n                ? slice(scanner)\n                : void 0\n        };\n    }\n}\nfunction repeater(scanner) {\n    return isRepeater(peek(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek(scanner);\n    if (isQuote(quote)) {\n        scanner.pos++;\n        while (readable(scanner)) {\n            if (isQuote(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable(scanner)) {\n        const token = peek(scanner);\n        if (brackets.expression) {\n            // If we’re inside expression, we should consume all content in it\n            if (isBracket(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote(token) || isOperator(token) || isWhiteSpace(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable(scanner)) {\n            const { pos } = scanner;\n            if (!consume(scanner, isClassNameOperator) || !consume(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable(scanner) && consume(scanner, isElementName)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable(scanner)) {\n            const token = next(scanner);\n            if (isBracket(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket(token, 'group', true);\n}\nfunction createLiteral(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator(token, 'child');\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator(token, 'close');\n}\n\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(92 /* Escape */)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken(scanner, ctx);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, ctx) {\n    return field(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater$1(scanner)\n        || whiteSpace(scanner)\n        || literal$1(scanner, ctx)\n        || operator(scanner)\n        || quote(scanner)\n        || bracket(scanner);\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal$1(scanner, ctx) {\n    const start = scanner.pos;\n    let value = '';\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n        const ch = scanner.peek();\n        if (ch === ctx.quote || ch === 36 /* Dollar */ || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (ctx.expression && ch === 125 /* CurlyBracketClose */) {\n            break;\n        }\n        if (!ctx.quote && !ctx.expression) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName$1(ch)) {\n                break;\n            }\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$1(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n        value += scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos,\n            value: scanner.substring(start, scanner.pos)\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote$1(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === 39 /* SingleQuote */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(35 /* Hash */)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(36 /* Dollar */)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(64 /* At */)) {\n            // Consume numbering modifiers\n            while (scanner.eat(94 /* Climb */)) {\n                parent++;\n            }\n            reverse = scanner.eat(45 /* Dash */);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and it’s allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === 42 /* Asterisk */ && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns it’s type\n */\nfunction bracketType(ch) {\n    if (ch === 40 /* RoundBracketOpen */ || ch === 41 /* RoundBracketClose */) {\n        return 'group';\n    }\n    if (ch === 91 /* SquareBracketOpen */ || ch === 93 /* SquareBracketClose */) {\n        return 'attribute';\n    }\n    if (ch === 123 /* CurlyBracketOpen */ || ch === 125 /* CurlyBracketClose */) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 62 /* Child */ && 'child')\n        || (ch === 43 /* Sibling */ && 'sibling')\n        || (ch === 94 /* Climb */ && 'climb')\n        || (ch === 46 /* Dot */ && 'class')\n        || (ch === 35 /* Hash */ && 'id')\n        || (ch === 47 /* Slash */ && 'close')\n        || (ch === 61 /* Equals */ && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyBracketOpen */\n        || ch === 91 /* SquareBracketOpen */\n        || ch === 40 /* RoundBracketOpen */;\n}\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName$1(ch) {\n    return isAlphaNumericWord(ch)\n        || ch === 45 /* Dash */\n        || ch === 58 /* Colon */\n        || ch === 33 /* Excl */;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // It’s a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // It’s a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value - 1\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace(token) {\n        return token.value;\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\nconst urlRegex = /^((https?:|ftp:|file:)?\\/\\/|(www|ftp)\\.)[^ ]*$/;\nconst emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,5}$/;\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    let cleanText;\n    if (options.text) {\n        if (Array.isArray(options.text)) {\n            cleanText = options.text.filter(s => s.trim());\n        }\n        else {\n            cleanText = options.text;\n        }\n    }\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            cleanText,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                var _a;\n                textInserted = true;\n                let value;\n                if (Array.isArray(options.text)) {\n                    if (pos !== undefined && pos >= 0 && pos < cleanText.length) {\n                        return cleanText[pos];\n                    }\n                    value = pos !== undefined ? options.text[pos] : options.text.join('\\n');\n                }\n                else {\n                    value = (_a = options.text) !== null && _a !== void 0 ? _a : '';\n                }\n                return value;\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n            if (deepest.name === 'a' && options.href) {\n                // Automatically update value of `<a>` element if inserting URL or email\n                insertHref(deepest, text);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.cleanText.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // It’s an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if it’s reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField)) {\n        // XXX it’s unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote(tokens[0])) {\n            // It’s a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket(last(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesn’t support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction insertHref(node, text) {\n    var _a;\n    let href = '';\n    if (urlRegex.test(text)) {\n        href = text;\n        if (!/\\w+:/.test(href) && !href.startsWith('//')) {\n            href = `http://${href}`;\n        }\n    }\n    else if (emailRegex.test(text)) {\n        href = `mailto:${text}`;\n    }\n    const hrefAttribute = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find(attr => attr.name === 'href');\n    if (!hrefAttribute) {\n        node.attributes = [{ name: 'href', value: [href], valueType: 'doubleQuote' }];\n    }\n    else if (!hrefAttribute.value) {\n        hrefAttribute.value = [href];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parseAbbreviation;\nexport { convert, getToken, abbreviation as parse, tokenize };\n//# sourceMappingURL=abbreviation.es.js.map\n","import Scanner, { isNumber, isAlpha, isAlphaWord, isQuote, isSpace, isAlphaNumericWord, ScannerError } from '@emmetio/scanner';\n\nfunction tokenize(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = getToken(scanner, brackets === 0 && !isValue);\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, short) {\n    return field(scanner)\n        || numberValue(scanner)\n        || colorValue(scanner)\n        || stringValue(scanner)\n        || bracket(scanner)\n        || operator(scanner)\n        || whiteSpace(scanner)\n        || literal(scanner, short);\n}\nfunction field(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n */\nfunction literal(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral : isKeyword);\n    }\n    else {\n        // Allow dots only at the beginning of literal\n        scanner.eat(46 /* Dot */);\n        scanner.eatWhile(isLiteral);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(37 /* Percent */) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === 39 /* SingleQuote */ ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc   → #aabbccc\n    // #0     → #000000\n    // #fff.5 → rgba(255, 255, 255, 0.5)\n    // #t     → transparent\n    const start = scanner.pos;\n    if (scanner.eat(35 /* Hash */)) {\n        const valueStart = scanner.pos;\n        let color = '';\n        let alpha = '';\n        if (scanner.eatWhile(isHex)) {\n            color = scanner.substring(valueStart, scanner.pos);\n            alpha = colorAlpha(scanner);\n        }\n        else if (scanner.eat(116 /* Transparent */)) {\n            color = '0';\n            alpha = colorAlpha(scanner) || '0';\n        }\n        else {\n            alpha = colorAlpha(scanner);\n        }\n        if (color || alpha || scanner.eof()) {\n            const { r, g, b, a } = parseColor(color, alpha);\n            return {\n                type: 'ColorValue',\n                r, g, b, a,\n                raw: scanner.substring(start + 1, scanner.pos),\n                start,\n                end: scanner.pos\n            };\n        }\n        else {\n            // Consumed # but no actual value: invalid color value, treat it as literal\n            return createLiteral(scanner, start);\n        }\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes alpha value of color: `.1`\n */\nfunction colorAlpha(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */)) {\n        scanner.start = start;\n        if (scanner.eatWhile(isNumber)) {\n            return scanner.current();\n        }\n        return '1';\n    }\n    return '';\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    if (isBracket(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === 40 /* RoundBracketOpen */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(45 /* Dash */);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber);\n    const prevPos = stream.pos;\n    if (stream.eat(46 /* Dot */)) {\n        // It’s perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === 64 /* At */ || code === 36 /* Dollar */;\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 43 /* Sibling */ && \"+\" /* Sibling */)\n        || (ch === 33 /* Excl */ && \"!\" /* Important */)\n        || (ch === 44 /* Comma */ && \",\" /* ArgumentDelimiter */)\n        || (ch === 58 /* Colon */ && \":\" /* PropertyDelimiter */)\n        || (ch === 45 /* Dash */ && \"-\" /* ValueDelimiter */)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber(code) || isAlpha(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === 45 /* Dash */;\n}\nfunction isBracket(code) {\n    return code === 40 /* RoundBracketOpen */ || code === 41 /* RoundBracketClose */;\n}\nfunction isLiteral(code) {\n    return isAlphaWord(code) || code === 37 /* Percent */ || code === 47 /* Slash */;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral(scanner, start, end));\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    if (test(peek(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner(tokens);\n    const result = [];\n    let property;\n    while (readable(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume(scanner, isSiblingOperator)) {\n            throw error(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek(scanner);\n    const valueMode = !!options.value;\n    if (!valueMode && isLiteral$1(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    if (valueMode) {\n        consume(scanner, isWhiteSpace);\n    }\n    while (readable(scanner)) {\n        if (consume(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner, valueMode)) {\n            value.push(valueFragment);\n        }\n        else if (!consume(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner, inArgument) {\n    const result = [];\n    let token;\n    let args;\n    while (readable(scanner)) {\n        token = peek(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral$1(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token) || (inArgument && isWhiteSpace(token))) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isOpenBracket)) {\n        const args = [];\n        let value;\n        while (readable(scanner) && !consume(scanner, isCloseBracket)) {\n            if (value = consumeValue(scanner, true)) {\n                args.push(value);\n            }\n            else if (!consume(scanner, isWhiteSpace) && !consume(scanner, isArgumentDelimiter)) {\n                throw error(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral$1(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket$1(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket(token) {\n    return isBracket$1(token, true);\n}\nfunction isCloseBracket(token) {\n    return isBracket$1(token, false);\n}\nfunction isWhiteSpace(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, \"+\" /* Sibling */);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator(token, \",\" /* ArgumentDelimiter */);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token);\n}\nfunction isImportant(token) {\n    return isOperator(token, \"!\" /* Important */);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field';\n}\nfunction isValueDelimiter(token) {\n    return isOperator(token, \":\" /* PropertyDelimiter */)\n        || isOperator(token, \"-\" /* ValueDelimiter */);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral$1(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parse;\nexport { getToken, parser, tokenize };\n","import { GlobalConfig } from 'emmet';\n\nexport interface EmmetEditorOptions extends CodeMirror.EditorConfiguration {\n    emmet: EmmetConfig;\n}\n\nexport type EnableForSyntax = boolean | string[];\n\nexport interface EmmetConfig {\n    /** Enables abbreviation marking in editor. Works in known syntaxes only */\n    mark: EnableForSyntax;\n\n    /**\n     * Enables preview of marked abbreviation. Pass `true` to enable preview for\n     * all syntaxes or array of modes or Emmet syntax types (`markup` or `stylesheet`)\n     * where preview should be displayed\n     */\n    preview: EnableForSyntax;\n\n    /** Mark HTML tag pairs in editor */\n    markTagPairs: boolean;\n\n    /**\n     * Displays open tag preview when caret is inside its matching closing tag.\n     * Preview is displayed only if open tag has attributes.\n     * Works only if `markTagPairs` is enabled\n     */\n    previewOpenTag: boolean;\n\n    /** Allow automatic tag pair rename, works only if `markTagPairs` is enabled */\n    autoRenameTags: boolean;\n\n    /** Quotes to use in generated HTML attribute values */\n    attributeQuotes: 'single' | 'double';\n\n    /** Style for self-closing elements (like `<br>`) and boolean attributes */\n    markupStyle: 'html' | 'xhtml' | 'xml',\n\n    /**\n     * Enable automatic tag commenting. When enabled, elements generated from Emmet\n     * abbreviation with `id` and/or `class` attributes will receive a comment\n     * with these attribute values\n     */\n    comments: boolean;\n\n    /**\n     * Commenting template. Default value is `\\n<!-- /[#ID][.CLASS] -->`\n     * Outputs everything between `[` and `]` only if specified attribute name\n     * (written in UPPERCASE) exists in element. Attribute name is replaced with\n     * actual value. Use `\\n` to add a newline.\n     */\n    commentsTemplate?: string;\n\n    /**\n     * Enable BEM support. When enabled, Emmet will treat class names starting\n     * with `-` as _element_ and with `_` as _modifier_ in BEM notation.\n     * These class names will inherit `block` name from current or ancestor element.\n     * For example, the abbreviation `ul.nav.nav_secondary>li.nav__item` can be\n     * shortened to `ul.nav._secondary>li.-item` with this option enabled.\n     */\n    bem: boolean;\n\n    /**\n     * For stylesheet abbreviations, generate short HEX color values, if possible.\n     * For example, `c#0` will be expanded to `color: #000;` instead of `color: #000000`.\n     */\n    shortHex?: boolean;\n\n    /** Advanced Emmet config */\n    config?: GlobalConfig;\n\n    /**\n     * Function for attaching abbreviation preview\n     */\n    attachPreview?: (editor: CodeMirror.Editor, preview: HTMLElement, pos: CodeMirror.Position) => void;\n}\n\nexport const defaultConfig: EmmetConfig = {\n    mark: true,\n    preview: true,\n    autoRenameTags: true,\n    markTagPairs: true,\n    previewOpenTag: false,\n    attributeQuotes: 'double',\n    markupStyle: 'html',\n    comments: false,\n    commentsTemplate: '<!-- /[#ID][.CLASS] -->',\n    bem: false\n};\n\nexport default function getEmmetConfig(editor: CodeMirror.Editor, opt?: Partial<EmmetConfig>): EmmetConfig {\n    if (!opt) {\n        // @ts-ignore Bypass limited options, defined in typings\n        opt = editor.getOption('emmet');\n    }\n    return { ...defaultConfig, ...opt };\n}\n","const defaultQuotedOptions = {\n    escape: 92,\n    throws: false\n};\n/**\n * Check if given code is a number\n */\nfunction isNumber(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n */\nfunction isAlphaNumeric(code) {\n    return isNumber(code) || isAlpha(code);\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha(code);\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @return `true` if quoted string was consumed. The contents of quoted string\n * will be available as `stream.current()`\n */\nfunction eatQuoted(stream, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    const quote = stream.peek();\n    if (stream.eat(isQuote)) {\n        while (!stream.eof()) {\n            switch (stream.next()) {\n                case quote:\n                    stream.start = start;\n                    return true;\n                case options.escape:\n                    stream.next();\n                    break;\n            }\n        }\n        // If we’re here then stream wasn’t properly consumed.\n        // Revert stream and decide what to do\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error('Unable to consume quoted string');\n        }\n    }\n    return false;\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param open Character code of pair opening\n * @param close Character code of pair closing\n * @return Returns `true` if character pair was successfully consumed, it’s\n * content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    if (stream.eat(open)) {\n        let stack = 1;\n        let ch;\n        while (!stream.eof()) {\n            if (eatQuoted(stream, options)) {\n                continue;\n            }\n            ch = stream.next();\n            if (ch === open) {\n                stack++;\n            }\n            else if (ch === close) {\n                stack--;\n                if (!stack) {\n                    stream.start = start;\n                    return true;\n                }\n            }\n            else if (ch === options.escape) {\n                stream.next();\n            }\n        }\n        // If we’re here then paired character can’t be consumed\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n        }\n    }\n    return false;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nexport default Scanner;\nexport { ScannerError, eatPair, eatQuoted, isAlpha, isAlphaNumeric, isAlphaNumericWord, isAlphaWord, isNumber, isQuote, isSpace, isWhiteSpace };\n//# sourceMappingURL=scanner.es.js.map\n","import Scanner, { eatPair, isAlpha, isNumber, isQuote, isSpace, eatQuoted } from '@emmetio/scanner';\n\nconst defaultOptions = {\n    xml: false,\n    allTokens: false,\n    special: {\n        style: null,\n        script: ['', 'text/javascript', 'application/x-javascript', 'javascript', 'typescript', 'ts', 'coffee', 'coffeescript']\n    },\n    empty: ['img', 'meta', 'link', 'br', 'base', 'hr', 'area', 'wbr', 'col', 'embed', 'input', 'param', 'source', 'track']\n};\n/** Options for `Scanner` utils */\nconst opt = { throws: false };\nfunction createOptions(options = {}) {\n    return Object.assign(Object.assign({}, defaultOptions), options);\n}\n/**\n * Converts given string into array of character codes\n */\nfunction toCharCodes(str) {\n    return str.split('').map(ch => ch.charCodeAt(0));\n}\n/**\n * Consumes array of character codes from given scanner\n */\nfunction consumeArray(scanner, codes) {\n    const start = scanner.pos;\n    for (let i = 0; i < codes.length; i++) {\n        if (!scanner.eat(codes[i])) {\n            scanner.pos = start;\n            return false;\n        }\n    }\n    scanner.start = start;\n    return true;\n}\n/**\n * Consumes section from given string which starts with `open` character codes\n * and ends with `close` character codes\n * @return Returns `true` if section was consumed\n */\nfunction consumeSection(scanner, open, close, allowUnclosed) {\n    const start = scanner.pos;\n    if (consumeArray(scanner, open)) {\n        // consumed `<!--`, read next until we find ending part or reach the end of input\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, close)) {\n                scanner.start = start;\n                return true;\n            }\n            scanner.pos++;\n        }\n        // unclosed section is allowed\n        if (allowUnclosed) {\n            scanner.start = start;\n            return true;\n        }\n        scanner.pos = start;\n        return false;\n    }\n    // unable to find section, revert to initial position\n    scanner.pos = start;\n    return false;\n}\n/**\n * Check if given character can be used as a start of tag name or attribute\n */\nfunction nameStartChar(ch) {\n    // Limited XML spec: https://www.w3.org/TR/xml/#NT-NameStartChar\n    return isAlpha(ch) || ch === 58 /* Colon */ || ch === 95 /* Underscore */\n        || (ch >= 0xC0 && ch <= 0xD6)\n        || (ch >= 0xD8 && ch <= 0xF6)\n        || (ch >= 0xF8 && ch <= 0x2FF)\n        || (ch >= 0x370 && ch <= 0x37D)\n        || (ch >= 0x37F && ch <= 0x1FFF);\n}\n/**\n * Check if given character can be used in a tag or attribute name\n */\nfunction nameChar(ch) {\n    // Limited XML spec: https://www.w3.org/TR/xml/#NT-NameChar\n    return nameStartChar(ch) || ch === 45 /* Dash */ || ch === 46 /* Dot */ || isNumber(ch)\n        || ch === 0xB7\n        || (ch >= 0x0300 && ch <= 0x036F);\n}\n/**\n * Consumes identifier from given scanner\n */\nfunction ident(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(nameStartChar)) {\n        scanner.eatWhile(nameChar);\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Check if given code is tag terminator\n */\nfunction isTerminator(code) {\n    return code === 62 /* RightAngle */ || code === 47 /* Slash */;\n}\n/**\n * Check if given character code is valid unquoted value\n */\nfunction isUnquoted(code) {\n    return !isNaN(code) && !isQuote(code) && !isSpace(code) && !isTerminator(code);\n}\n/**\n * Consumes paired tokens (like `[` and `]`) with respect of nesting and embedded\n * quoted values\n * @return `true` if paired token was consumed\n */\nfunction consumePaired(scanner) {\n    return eatPair(scanner, 60 /* LeftAngle */, 62 /* RightAngle */, opt)\n        || eatPair(scanner, 40 /* LeftRound */, 41 /* RightRound */, opt)\n        || eatPair(scanner, 91 /* LeftSquare */, 93 /* RightSquare */, opt)\n        || eatPair(scanner, 123 /* LeftCurly */, 125 /* RightCurly */, opt);\n}\n/**\n * Returns unquoted value of given string\n */\nfunction getUnquotedValue(value) {\n    // Trim quotes\n    if (isQuote(value.charCodeAt(0))) {\n        value = value.slice(1);\n    }\n    if (isQuote(value.charCodeAt(value.length - 1))) {\n        value = value.slice(0, -1);\n    }\n    return value;\n}\n\n/**\n * Parses given string as list of HTML attributes.\n * @param src A fragment to parse. If `name` argument is provided, it must be an\n * opening tag (`<a foo=\"bar\">`), otherwise it should be a fragment between element\n * name and tag closing angle (`foo=\"bar\"`)\n * @param name Tag name\n */\nfunction attributes(src, name) {\n    const result = [];\n    let start = 0;\n    let end = src.length;\n    if (name) {\n        start = name.length + 1;\n        end -= src.slice(-2) === '/>' ? 2 : 1;\n    }\n    const scanner = new Scanner(src, start, end);\n    while (!scanner.eof()) {\n        scanner.eatWhile(isSpace);\n        if (attributeName(scanner)) {\n            const token = {\n                name: scanner.current(),\n                nameStart: scanner.start,\n                nameEnd: scanner.pos\n            };\n            if (scanner.eat(61 /* Equals */) && attributeValue(scanner)) {\n                token.value = scanner.current();\n                token.valueStart = scanner.start;\n                token.valueEnd = scanner.pos;\n            }\n            result.push(token);\n        }\n        else {\n            // Do not break on invalid attributes: we are not validating parser\n            scanner.pos++;\n        }\n    }\n    return result;\n}\n/**\n * Consumes attribute name from given scanner context\n */\nfunction attributeName(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */) || scanner.eat(35 /* Hash */)) {\n        // Angular-style directives: `<section *ngIf=\"showSection\">`, `<video #movieplayer ...>`\n        ident(scanner);\n        scanner.start = start;\n        return true;\n    }\n    // Attribute name could be a regular name or expression:\n    // React-style – `<div {...props}>`\n    // Angular-style – `<div [ng-for]>` or `<div *ng-for>`\n    return consumePaired(scanner) || ident(scanner);\n}\n/**\n * Consumes attribute value\n */\nfunction attributeValue(scanner) {\n    // Supported attribute values are quoted, React-like expressions (`{foo}`)\n    // or unquoted literals\n    return eatQuoted(scanner, opt) || consumePaired(scanner) || unquoted(scanner);\n}\n/**\n * Returns clean (unquoted) value of `name` attribute\n */\nfunction getAttributeValue(attrs, name) {\n    for (let i = 0; i < attrs.length; i++) {\n        const attr = attrs[i];\n        if (attr.name === name) {\n            return attr.value && getUnquotedValue(attr.value);\n        }\n    }\n}\n/**\n * Consumes unquoted value\n */\nfunction unquoted(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isUnquoted)) {\n        scanner.start = start;\n        return true;\n    }\n}\n\nconst cdataOpen = toCharCodes('<![CDATA[');\nconst cdataClose = toCharCodes(']]>');\nconst commentOpen = toCharCodes('<!--');\nconst commentClose = toCharCodes('-->');\nconst piStart = toCharCodes('<?');\nconst piEnd = toCharCodes('?>');\nconst erbStart = toCharCodes('<%');\nconst erbEnd = toCharCodes('%>');\n/**\n * Performs fast scan of given source code: for each tag found it invokes callback\n * with tag name, its type (open, close, self-close) and range in original source.\n * Unlike regular scanner, fast scanner doesn’t provide info about attributes to\n * reduce object allocations hence increase performance.\n * If `callback` returns `false`, scanner stops parsing.\n * @param special List of “special” HTML tags which should be ignored. Most likely\n * it’s a \"script\" and \"style\" tags.\n */\nfunction scan(source, callback, options) {\n    const scanner = new Scanner(source);\n    const special = options ? options.special : null;\n    const allTokens = options ? options.allTokens : false;\n    let type;\n    let name;\n    let nameStart;\n    let nameEnd;\n    let nameCodes;\n    let found = false;\n    let piName = null;\n    while (!scanner.eof()) {\n        const start = scanner.pos;\n        if (cdata(scanner)) {\n            if (allTokens && callback('#cdata', 4 /* CData */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (comment(scanner)) {\n            if (allTokens && callback('#comment', 6 /* Comment */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (erb(scanner)) {\n            if (allTokens && callback('#erb', 7 /* ERB */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (piName = processingInstruction(scanner)) {\n            if (allTokens && callback(piName, 5 /* ProcessingInstruction */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (scanner.eat(60 /* LeftAngle */)) {\n            // Maybe a tag name?\n            type = scanner.eat(47 /* Slash */) ? 2 /* Close */ : 1 /* Open */;\n            nameStart = scanner.pos;\n            if (ident(scanner)) {\n                // Consumed tag name\n                nameEnd = scanner.pos;\n                if (type !== 2 /* Close */) {\n                    skipAttributes(scanner);\n                    scanner.eatWhile(isSpace);\n                    if (scanner.eat(47 /* Slash */)) {\n                        type = 3 /* SelfClose */;\n                    }\n                }\n                if (scanner.eat(62 /* RightAngle */)) {\n                    // Tag properly closed\n                    name = scanner.substring(nameStart, nameEnd);\n                    if (callback(name, type, start, scanner.pos) === false) {\n                        break;\n                    }\n                    if (type === 1 /* Open */ && special && isSpecial(special, name, source, start, scanner.pos)) {\n                        // Found opening tag of special element: we should skip\n                        // scanner contents until we find closing tag\n                        nameCodes = toCharCodes(name);\n                        found = false;\n                        while (!scanner.eof()) {\n                            if (consumeClosing(scanner, nameCodes)) {\n                                found = true;\n                                break;\n                            }\n                            scanner.pos++;\n                        }\n                        if (found && callback(name, 2 /* Close */, scanner.start, scanner.pos) === false) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n}\n/**\n * Skips attributes in current tag context\n */\nfunction skipAttributes(scanner) {\n    while (!scanner.eof()) {\n        scanner.eatWhile(isSpace);\n        if (attributeName(scanner)) {\n            if (scanner.eat(61 /* Equals */)) {\n                attributeValue(scanner);\n            }\n        }\n        else if (isTerminator(scanner.peek())) {\n            break;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n}\n/**\n * Consumes closing tag with given name from scanner\n */\nfunction consumeClosing(scanner, name) {\n    const start = scanner.pos;\n    if (scanner.eat(60 /* LeftAngle */) && scanner.eat(47 /* Slash */) && consumeArray(scanner, name) && scanner.eat(62 /* RightAngle */)) {\n        scanner.start = start;\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes CDATA from given scanner\n */\nfunction cdata(scanner) {\n    return consumeSection(scanner, cdataOpen, cdataClose, true);\n}\n/**\n * Consumes comments from given scanner\n */\nfunction comment(scanner) {\n    return consumeSection(scanner, commentOpen, commentClose, true);\n}\n/**\n * Consumes processing instruction from given scanner. If consumed, returns\n * processing instruction name\n */\nfunction processingInstruction(scanner) {\n    const start = scanner.pos;\n    if (consumeArray(scanner, piStart) && ident(scanner)) {\n        const name = scanner.current();\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, piEnd)) {\n                break;\n            }\n            eatQuoted(scanner) || scanner.pos++;\n        }\n        scanner.start = start;\n        return name;\n    }\n    scanner.pos = start;\n    return null;\n}\n/**\n * Consumes ERB-style entity: `<% ... %>` or `<%= ... %>`\n */\nfunction erb(scanner) {\n    const start = scanner.pos;\n    if (consumeArray(scanner, erbStart)) {\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, erbEnd)) {\n                break;\n            }\n            eatQuoted(scanner) || scanner.pos++;\n        }\n        scanner.start = start;\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Check if given tag name should be considered as special\n */\nfunction isSpecial(special, name, source, start, end) {\n    if (name in special) {\n        const typeValues = special[name];\n        if (!Array.isArray(typeValues)) {\n            return true;\n        }\n        const attrs = attributes(source.substring(start + name.length + 1, end - 1));\n        return typeValues.includes(getAttributeValue(attrs, 'type') || '');\n    }\n    return false;\n}\n\n/**\n * Finds matched tag for given `pos` location in XML/HTML `source`\n */\nfunction match(source, pos, opt) {\n    // Since we expect large input document, we’ll use pooling technique\n    // for storing tag data to reduce memory pressure and improve performance\n    const pool = [];\n    const stack = [];\n    const options = createOptions(opt);\n    let result = null;\n    scan(source, (name, type, start, end) => {\n        if (type === 1 /* Open */ && isSelfClose(name, options)) {\n            // Found empty element in HTML mode, mark is as self-closing\n            type = 3 /* SelfClose */;\n        }\n        if (type === 1 /* Open */) {\n            // Allocate tag object from pool\n            stack.push(allocTag(pool, name, start, end));\n        }\n        else if (type === 3 /* SelfClose */) {\n            if (start < pos && pos < end) {\n                // Matched given self-closing tag\n                result = {\n                    name,\n                    attributes: getAttributes(source, start, end, name),\n                    open: [start, end]\n                };\n                return false;\n            }\n        }\n        else {\n            const tag = last(stack);\n            if (tag && tag.name === name) {\n                // Matching closing tag found\n                if (tag.start < pos && pos < end) {\n                    result = {\n                        name,\n                        attributes: getAttributes(source, tag.start, tag.end, name),\n                        open: [tag.start, tag.end],\n                        close: [start, end]\n                    };\n                    return false;\n                }\n                else if (stack.length) {\n                    // Release tag object for further re-use\n                    releaseTag(pool, stack.pop());\n                }\n            }\n        }\n    }, options);\n    stack.length = pool.length = 0;\n    return result;\n}\n/**\n * Returns balanced tag model: a list of all XML/HTML tags that could possibly match\n * given location when moving in outward direction\n */\nfunction balancedOutward(source, pos, opt) {\n    const pool = [];\n    const stack = [];\n    const options = createOptions(opt);\n    const result = [];\n    scan(source, (name, type, start, end) => {\n        if (type === 2 /* Close */) {\n            const tag = last(stack);\n            if (tag && tag.name === name) { // XXX check for invalid tag names?\n                // Matching closing tag found, check if matched pair is a candidate\n                // for outward balancing\n                if (tag.start < pos && pos < end) {\n                    result.push({\n                        name,\n                        open: [tag.start, tag.end],\n                        close: [start, end]\n                    });\n                }\n                // Release tag object for further re-use\n                releaseTag(pool, stack.pop());\n            }\n        }\n        else if (type === 3 /* SelfClose */ || isSelfClose(name, options)) {\n            if (start < pos && pos < end) {\n                // Matched self-closed tag\n                result.push({ name, open: [start, end] });\n            }\n        }\n        else {\n            stack.push(allocTag(pool, name, start, end));\n        }\n    }, options);\n    stack.length = pool.length = 0;\n    return result;\n}\n/**\n * Returns balanced tag model: a list of all XML/HTML tags that could possibly match\n * given location when moving in inward direction\n */\nfunction balancedInward(source, pos, opt) {\n    // Collecting tags for inward balancing is a bit trickier: we have to store\n    // first child of every matched tag until we find the one that matches given\n    // location\n    const pool = [];\n    const stack = [];\n    const options = createOptions(opt);\n    const result = [];\n    const alloc = (name, start, end) => {\n        if (pool.length) {\n            const tag = pool.pop();\n            tag.name = name;\n            tag.ranges.push(start, end);\n            return tag;\n        }\n        return { name, ranges: [start, end] };\n    };\n    const release = (tag) => {\n        tag.ranges.length = 0;\n        tag.firstChild = void 0;\n        pool.push(tag);\n    };\n    scan(source, (name, type, start, end) => {\n        if (type === 2 /* Close */) {\n            if (!stack.length) {\n                // Some sort of lone closing tag, ignore it\n                return;\n            }\n            let tag = last(stack);\n            if (tag.name === name) { // XXX check for invalid tag names?\n                // Matching closing tag found, check if matched pair is a candidate\n                // for outward balancing\n                if (tag.ranges[0] <= pos && pos <= end) {\n                    result.push({\n                        name,\n                        open: tag.ranges.slice(0, 2),\n                        close: [start, end]\n                    });\n                    while (tag.firstChild) {\n                        const child = tag.firstChild;\n                        const res = {\n                            name: child.name,\n                            open: child.ranges.slice(0, 2)\n                        };\n                        if (child.ranges.length > 2) {\n                            res.close = child.ranges.slice(2, 4);\n                        }\n                        result.push(res);\n                        release(tag);\n                        tag = child;\n                    }\n                    return false;\n                }\n                else {\n                    stack.pop();\n                    const parent = last(stack);\n                    if (parent && !parent.firstChild) {\n                        // No first child in parent node: store current tag\n                        tag.ranges.push(start, end);\n                        parent.firstChild = tag;\n                    }\n                    else {\n                        release(tag);\n                    }\n                }\n            }\n        }\n        else if (type === 3 /* SelfClose */ || isSelfClose(name, options)) {\n            if (start < pos && pos < end) {\n                // Matched self-closed tag, no need to look further\n                result.push({ name, open: [start, end] });\n                return false;\n            }\n            const parent = last(stack);\n            if (parent && !parent.firstChild) {\n                parent.firstChild = alloc(name, start, end);\n            }\n        }\n        else {\n            stack.push(alloc(name, start, end));\n        }\n    }, options);\n    stack.length = pool.length = 0;\n    return result;\n}\nfunction allocTag(pool, name, start, end) {\n    if (pool.length) {\n        const tag = pool.pop();\n        tag.name = name;\n        tag.start = start;\n        tag.end = end;\n        return tag;\n    }\n    return { name, start, end };\n}\nfunction releaseTag(pool, tag) {\n    pool.push(tag);\n}\n/**\n * Returns parsed attributes from given source\n */\nfunction getAttributes(source, start, end, name) {\n    const tokens = attributes(source.slice(start, end), name);\n    tokens.forEach(attr => {\n        attr.nameStart += start;\n        attr.nameEnd += start;\n        if (attr.value != null) {\n            attr.valueStart += start;\n            attr.valueEnd += start;\n        }\n    });\n    return tokens;\n}\n/**\n * Check if given tag is self-close for current parsing context\n */\nfunction isSelfClose(name, options) {\n    return !options.xml && options.empty.includes(name);\n}\nfunction last(arr) {\n    return arr.length ? arr[arr.length - 1] : null;\n}\n\nexport default match;\nexport { attributes, balancedInward, balancedOutward, createOptions, scan };\n//# sourceMappingURL=html-matcher.es.js.map\n","import Scanner, { isSpace, isQuote } from '@emmetio/scanner';\n\n/**\n * Performs fast scan of given stylesheet (CSS, LESS, SCSS) source code and runs\n * callback for each token and its range found. The goal of this parser is to quickly\n * determine document structure: selector, property, value and block end.\n * It doesn’t provide detailed info about CSS atoms like compound selectors,\n * operators, quoted string etc. to reduce memory allocations: this data can be\n * parsed later on demand.\n */\nfunction scan(source, callback) {\n    const scanner = new Scanner(source);\n    const state = {\n        start: -1,\n        end: -1,\n        propertyStart: -1,\n        propertyEnd: -1,\n        propertyDelimiter: -1,\n        expression: 0,\n    };\n    let blockEnd;\n    const notify = (type, delimiter = scanner.start, start = state.start, end = state.end) => {\n        return callback(type, start, end, delimiter) === false;\n    };\n    while (!scanner.eof()) {\n        if (comment(scanner) || whitespace(scanner)) {\n            continue;\n        }\n        scanner.start = scanner.pos;\n        if ((blockEnd = scanner.eat(125 /* RightCurly */)) || scanner.eat(59 /* Semicolon */)) {\n            // Block or property end\n            if (state.propertyStart !== -1) {\n                // We have pending property\n                if (notify(\"propertyName\" /* PropertyName */, state.propertyDelimiter, state.propertyStart, state.propertyEnd)) {\n                    return;\n                }\n                if (state.start === -1) {\n                    // Explicit property value state: emit empty value\n                    state.start = state.end = scanner.start;\n                }\n                if (notify(\"propertyValue\" /* PropertyValue */)) {\n                    return;\n                }\n            }\n            else if (state.start !== -1 && notify(\"propertyName\" /* PropertyName */)) {\n                // Flush consumed token\n                return;\n            }\n            if (blockEnd) {\n                state.start = scanner.start;\n                state.end = scanner.pos;\n                if (notify(\"blockEnd\" /* BlockEnd */)) {\n                    return;\n                }\n            }\n            reset(state);\n        }\n        else if (scanner.eat(123 /* LeftCurly */)) {\n            // Block start\n            if (state.start === -1 && state.propertyStart === -1) {\n                // No consumed selector, emit empty value as selector start\n                state.start = state.end = scanner.pos;\n            }\n            if (state.propertyStart !== -1) {\n                // Now we know that value that looks like property name-value pair\n                // was actually a selector\n                state.start = state.propertyStart;\n            }\n            if (notify(\"selector\" /* Selector */)) {\n                return;\n            }\n            reset(state);\n        }\n        else if (scanner.eat(58 /* Colon */) && !isKnownSelectorColon(scanner, state)) {\n            // Colon could be one of the following:\n            // — property delimiter: `foo: bar`, must be in block context\n            // — variable delimiter: `$foo: bar`, could be anywhere\n            // — pseudo-selector: `a:hover`, could be anywhere (for LESS and SCSS)\n            // — media query expression: `min-width: 100px`, must be inside expression context\n            // Since I can’t easily detect `:` meaning for sure, we’ll update state\n            // to accumulate possible property name-value pair or selector\n            if (state.propertyStart === -1) {\n                state.propertyStart = state.start;\n            }\n            state.propertyEnd = state.end;\n            state.propertyDelimiter = scanner.pos - 1;\n            state.start = state.end = -1;\n        }\n        else {\n            if (state.start === -1) {\n                state.start = scanner.pos;\n            }\n            if (scanner.eat(40 /* LeftRound */)) {\n                state.expression++;\n            }\n            else if (scanner.eat(41 /* RightRound */)) {\n                state.expression--;\n            }\n            else if (!literal(scanner)) {\n                scanner.pos++;\n            }\n            state.end = scanner.pos;\n        }\n    }\n    if (state.propertyStart !== -1) {\n        // Pending property name\n        if (notify(\"propertyName\" /* PropertyName */, state.propertyDelimiter, state.propertyStart, state.propertyEnd)) {\n            return;\n        }\n    }\n    if (state.start !== -1) {\n        // There’s pending token in state\n        notify(state.propertyStart !== -1 ? \"propertyValue\" /* PropertyValue */ : \"propertyName\" /* PropertyName */, -1);\n    }\n}\nfunction whitespace(scanner) {\n    return scanner.eatWhile(isSpace);\n}\n/**\n * Consumes CSS comments from scanner: `/*  * /`\n * It’s possible that comment may not have closing part\n */\nfunction comment(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(47 /* Slash */) && scanner.eat(42 /* Asterisk */)) {\n        scanner.start = start;\n        while (!scanner.eof()) {\n            if (scanner.eat(42 /* Asterisk */)) {\n                if (scanner.eat(47 /* Slash */)) {\n                    return true;\n                }\n                continue;\n            }\n            scanner.pos++;\n        }\n        return true;\n    }\n    else {\n        scanner.pos = start;\n    }\n    return false;\n}\n/**\n * Consumes single- or double-quoted string literal\n */\nfunction literal(scanner) {\n    const ch = scanner.peek();\n    if (isQuote(ch)) {\n        scanner.start = scanner.pos++;\n        while (!scanner.eof()) {\n            if (scanner.eat(ch) || scanner.eat(10 /* LF */) || scanner.eat(13 /* CR */)) {\n                break;\n            }\n            // Skip escape character, if any\n            scanner.eat(92 /* Backslash */);\n            scanner.pos++;\n        }\n        // Do not throw if string is incomplete\n        return true;\n    }\n}\nfunction reset(state) {\n    state.start = state.end = state.propertyStart = state.propertyEnd = state.propertyDelimiter = -1;\n}\n/**\n * Check if current state is a known selector context for `:` delimiter\n */\nfunction isKnownSelectorColon(scanner, state) {\n    // Either inside expression like `(min-width: 10px)` or pseudo-element `::before`\n    return state.expression || scanner.eatWhile(58 /* Colon */);\n}\n\n// NB: no `Minus` operator, it must be handled differently\nconst operators = [\n    43 /* Plus */, 47 /* Division */, 42 /* Multiplication */,\n    44 /* Comma */\n];\n/**\n * Splits given CSS value into token list\n */\nfunction splitValue(value, offset = 0) {\n    let start = -1;\n    let expression = 0;\n    let pos = 0;\n    const result = [];\n    const scanner = new Scanner(value);\n    while (!scanner.eof()) {\n        pos = scanner.pos;\n        if (scanner.eat(isSpace) || scanner.eat(isOperator) || isMinusOperator(scanner)) {\n            // Use space as value delimiter but only if not in expression context,\n            // e.g. `1 2` are distinct values but `(1 2)` not\n            if (!expression && start !== -1) {\n                result.push([offset + start, offset + pos]);\n                start = -1;\n            }\n            scanner.eatWhile(isSpace);\n        }\n        else {\n            if (start === -1) {\n                start = scanner.pos;\n            }\n            if (scanner.eat(40 /* LeftRound */)) {\n                expression++;\n            }\n            else if (scanner.eat(41 /* RightRound */)) {\n                expression--;\n            }\n            else if (!literal(scanner)) {\n                scanner.pos++;\n            }\n        }\n    }\n    if (start !== -1 && start !== scanner.pos) {\n        result.push([offset + start, offset + scanner.pos]);\n    }\n    return result;\n}\nfunction isOperator(ch) {\n    return operators.includes(ch);\n}\n/**\n * Check if current scanner state is at minus operator\n */\nfunction isMinusOperator(scanner) {\n    // Minus operator is tricky since CSS supports dashes in keyword names like\n    // `no-repeat`\n    const start = scanner.pos;\n    if (scanner.eat(45 /* Minus */) && scanner.eat(isSpace)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n\nfunction match(source, pos) {\n    const pool = [];\n    const stack = [];\n    let result = null;\n    let pendingProperty = null;\n    const releasePending = () => {\n        if (pendingProperty) {\n            releaseRange(pool, pendingProperty);\n            pendingProperty = null;\n        }\n    };\n    scan(source, (type, start, end, delimiter) => {\n        if (type === \"selector\" /* Selector */) {\n            releasePending();\n            stack.push(allocRange(pool, start, end, delimiter));\n        }\n        else if (type === \"blockEnd\" /* BlockEnd */) {\n            releasePending();\n            const parent = stack.pop();\n            if (parent && parent[0] < pos && pos < end) {\n                result = {\n                    type: 'selector',\n                    start: parent[0],\n                    end,\n                    bodyStart: parent[2] + 1,\n                    bodyEnd: start\n                };\n                return false;\n            }\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            releasePending();\n            pendingProperty = allocRange(pool, start, end, delimiter);\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            if (pendingProperty && pendingProperty[0] < pos && pos < end) {\n                result = {\n                    type: 'property',\n                    start: pendingProperty[0],\n                    end: delimiter + 1,\n                    bodyStart: start,\n                    bodyEnd: end\n                };\n                return false;\n            }\n            releasePending();\n        }\n    });\n    return result;\n}\n/**\n * Returns balanced CSS model: a list of all ranges that could possibly match\n * given location when moving in outward direction\n */\nfunction balancedOutward(source, pos) {\n    const pool = [];\n    const stack = [];\n    const result = [];\n    let property = null;\n    scan(source, (type, start, end, delimiter) => {\n        if (type === \"selector\" /* Selector */) {\n            stack.push(allocRange(pool, start, end, delimiter));\n        }\n        else if (type === \"blockEnd\" /* BlockEnd */) {\n            const left = stack.pop();\n            if (left && left[0] < pos && end > pos) {\n                // Matching section found\n                const inner = innerRange(source, left[2] + 1, start);\n                inner && push(result, inner);\n                push(result, [left[0], end]);\n            }\n            left && releaseRange(pool, left);\n            if (!stack.length) {\n                return false;\n            }\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            property && releaseRange(pool, property);\n            property = allocRange(pool, start, end, delimiter);\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            if (property && property[0] < pos && Math.max(delimiter, end) > pos) {\n                // Push full token and value range\n                push(result, [start, end]);\n                push(result, [property[0], delimiter !== -1 ? delimiter + 1 : end]);\n            }\n        }\n        if (type !== \"propertyName\" /* PropertyName */ && property) {\n            releaseRange(pool, property);\n            property = null;\n        }\n    });\n    return result;\n}\n/**\n * Returns balanced CSS selectors: a list of all ranges that could possibly match\n * given location when moving in inward direction\n */\nfunction balancedInward(source, pos) {\n    // Collecting ranges for inward balancing is a bit trickier: we have to store\n    // first child of every matched selector until we find the one that matches given\n    // location\n    const pool = [];\n    const stack = [];\n    const result = [];\n    let pendingProperty = null;\n    const alloc = (start, end, delimiter) => {\n        if (pool.length) {\n            const range = pool.pop();\n            range.start = start;\n            range.end = end;\n            range.delimiter = delimiter;\n            return range;\n        }\n        return { start, end, delimiter, firstChild: null };\n    };\n    const release = (range) => {\n        range.firstChild = null;\n        pool.push(range);\n    };\n    const releasePending = () => {\n        if (pendingProperty) {\n            release(pendingProperty);\n            pendingProperty = null;\n        }\n    };\n    /**\n     * Pushes given inward range as a first child of current selector only if it’s\n     * not set yet\n     */\n    const pushChild = (start, end, delimiter) => {\n        const parent = last(stack);\n        if (parent && !parent.firstChild) {\n            parent.firstChild = alloc(start, end, delimiter);\n        }\n    };\n    scan(source, (type, start, end, delimiter) => {\n        if (type === \"blockEnd\" /* BlockEnd */) {\n            releasePending();\n            let range = stack.pop();\n            if (!range) {\n                // Some sort of lone closing brace, ignore it\n                return;\n            }\n            if (range.start <= pos && pos <= end) {\n                // Matching selector found: add it and its inner range into result\n                let inner = innerRange(source, range.delimiter + 1, start);\n                push(result, [range.start, end]);\n                inner && push(result, inner);\n                while (range.firstChild) {\n                    const child = range.firstChild;\n                    inner = innerRange(source, child.delimiter + 1, child.end - 1);\n                    push(result, [child.start, child.end]);\n                    inner && push(result, inner);\n                    range = child;\n                }\n                return false;\n            }\n            else {\n                const parent = last(stack);\n                if (parent && !parent.firstChild) {\n                    // No first child in parent node: store current selector\n                    range.end = end;\n                    parent.firstChild = range;\n                }\n                else {\n                    release(range);\n                }\n            }\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            releasePending();\n            pendingProperty = alloc(start, end, delimiter);\n            pushChild(start, end, delimiter);\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            if (pendingProperty) {\n                if (pendingProperty.start <= pos && end >= pos) {\n                    // Direct hit into property, no need to look further\n                    push(result, [pendingProperty.start, delimiter + 1]);\n                    push(result, [start, end]);\n                    releasePending();\n                    return false;\n                }\n                const parent = last(stack);\n                if (parent && parent.firstChild && parent.firstChild.start === pendingProperty.start) {\n                    // First child is an expected property name, update its range\n                    // to include property value\n                    parent.firstChild.end = delimiter !== -1 ? delimiter + 1 : end;\n                }\n                releasePending();\n            }\n        }\n        else {\n            // Selector start\n            stack.push(alloc(start, end, delimiter));\n            releasePending();\n        }\n    });\n    stack.length = pool.length = 0;\n    return result;\n}\n/**\n * Returns inner range for given selector bounds: narrows it to first non-empty\n * region. If resulting region is empty, returns `null`\n */\nfunction innerRange(source, start, end) {\n    while (start < end && isSpace(source.charCodeAt(start))) {\n        start++;\n    }\n    while (end > start && isSpace(source.charCodeAt(end - 1))) {\n        end--;\n    }\n    return start !== end ? [start, end] : null;\n}\nfunction allocRange(pool, start, end, delimiter) {\n    if (pool.length) {\n        const range = pool.pop();\n        range[0] = start;\n        range[1] = end;\n        range[2] = delimiter;\n        return range;\n    }\n    return [start, end, delimiter];\n}\nfunction releaseRange(pool, range) {\n    range && pool.push(range);\n    return null;\n}\nfunction push(ranges, range) {\n    const prev = ranges.length ? ranges[ranges.length - 1] : null;\n    if ((!prev || prev[0] !== range[0] || prev[1] !== range[1]) && range[0] !== range[1]) {\n        ranges.push(range);\n    }\n}\nfunction last(arr) {\n    return arr.length ? arr[arr.length - 1] : null;\n}\n\nexport default match;\nexport { balancedInward, balancedOutward, scan, splitValue };\n//# sourceMappingURL=css-matcher.es.js.map\n","import Scanner, { isAlphaNumericWord, isSpace, isQuote as isQuote$1, isNumber, isAlpha, ScannerError } from '@emmetio/scanner';\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    const token = peek(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner(abbr);\n    const result = statements(scanner, options);\n    if (readable(scanner)) {\n        throw error(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable(scanner)) {\n        if (node = element(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume(scanner, isSiblingOperator)) {\n                continue;\n            }\n            else if (consume(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket(token, 'group', false)) {\n            result.repeat = repeater(scanner);\n        }\n        return result;\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume(scanner, isWhiteSpace)) {\n                throw error(scanner, `Unexpected \"${peek(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator(peek(scanner), type)) {\n        scanner.pos++;\n        const attr = {\n            name: [createLiteral(type)]\n        };\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: it’s a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal(scanner, true)) {\n        return {\n            name: slice(scanner),\n            value: consume(scanner, isEquals) && (quoted(scanner) || literal(scanner, true))\n                ? slice(scanner)\n                : void 0\n        };\n    }\n}\nfunction repeater(scanner) {\n    return isRepeater(peek(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek(scanner);\n    if (isQuote(quote)) {\n        scanner.pos++;\n        while (readable(scanner)) {\n            if (isQuote(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable(scanner)) {\n        const token = peek(scanner);\n        if (brackets.expression) {\n            // If we’re inside expression, we should consume all content in it\n            if (isBracket(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote(token) || isOperator(token) || isWhiteSpace(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable(scanner)) {\n            const { pos } = scanner;\n            if (!consume(scanner, isClassNameOperator) || !consume(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable(scanner) && consume(scanner, isElementName)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable(scanner)) {\n            const token = next(scanner);\n            if (isBracket(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket(token, 'group', true);\n}\nfunction createLiteral(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator(token, 'child');\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator(token, 'close');\n}\n\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(92 /* Escape */)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken(scanner, ctx);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, ctx) {\n    return field(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater$1(scanner)\n        || whiteSpace(scanner)\n        || literal$1(scanner, ctx)\n        || operator(scanner)\n        || quote(scanner)\n        || bracket(scanner);\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal$1(scanner, ctx) {\n    const start = scanner.pos;\n    let value = '';\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n        const ch = scanner.peek();\n        if (ch === ctx.quote || ch === 36 /* Dollar */ || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (ctx.expression && ch === 125 /* CurlyBracketClose */) {\n            break;\n        }\n        if (!ctx.quote && !ctx.expression) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName$1(ch)) {\n                break;\n            }\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$1(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n        value += scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos,\n            value: scanner.substring(start, scanner.pos)\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote$1(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === 39 /* SingleQuote */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(35 /* Hash */)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(36 /* Dollar */)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(64 /* At */)) {\n            // Consume numbering modifiers\n            while (scanner.eat(94 /* Climb */)) {\n                parent++;\n            }\n            reverse = scanner.eat(45 /* Dash */);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and it’s allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === 42 /* Asterisk */ && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns it’s type\n */\nfunction bracketType(ch) {\n    if (ch === 40 /* RoundBracketOpen */ || ch === 41 /* RoundBracketClose */) {\n        return 'group';\n    }\n    if (ch === 91 /* SquareBracketOpen */ || ch === 93 /* SquareBracketClose */) {\n        return 'attribute';\n    }\n    if (ch === 123 /* CurlyBracketOpen */ || ch === 125 /* CurlyBracketClose */) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 62 /* Child */ && 'child')\n        || (ch === 43 /* Sibling */ && 'sibling')\n        || (ch === 94 /* Climb */ && 'climb')\n        || (ch === 46 /* Dot */ && 'class')\n        || (ch === 35 /* Hash */ && 'id')\n        || (ch === 47 /* Slash */ && 'close')\n        || (ch === 61 /* Equals */ && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyBracketOpen */\n        || ch === 91 /* SquareBracketOpen */\n        || ch === 40 /* RoundBracketOpen */;\n}\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName$1(ch) {\n    return isAlphaNumericWord(ch)\n        || ch === 45 /* Dash */\n        || ch === 58 /* Colon */\n        || ch === 33 /* Excl */;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // It’s a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // It’s a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value - 1\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace(token) {\n        return token.value;\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\nconst urlRegex = /^((https?:|ftp:|file:)?\\/\\/|(www|ftp)\\.)[^ ]*$/;\nconst emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,5}$/;\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    let cleanText;\n    if (options.text) {\n        if (Array.isArray(options.text)) {\n            cleanText = options.text.filter(s => s.trim());\n        }\n        else {\n            cleanText = options.text;\n        }\n    }\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            cleanText,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                var _a;\n                textInserted = true;\n                let value;\n                if (Array.isArray(options.text)) {\n                    if (pos !== undefined && pos >= 0 && pos < cleanText.length) {\n                        return cleanText[pos];\n                    }\n                    value = pos !== undefined ? options.text[pos] : options.text.join('\\n');\n                }\n                else {\n                    value = (_a = options.text) !== null && _a !== void 0 ? _a : '';\n                }\n                return value;\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n            if (deepest.name === 'a' && options.href) {\n                // Automatically update value of `<a>` element if inserting URL or email\n                insertHref(deepest, text);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.cleanText.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // It’s an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if it’s reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField)) {\n        // XXX it’s unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote(tokens[0])) {\n            // It’s a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket(last(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesn’t support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction insertHref(node, text) {\n    var _a;\n    let href = '';\n    if (urlRegex.test(text)) {\n        href = text;\n        if (!/\\w+:/.test(href) && !href.startsWith('//')) {\n            href = `http://${href}`;\n        }\n    }\n    else if (emailRegex.test(text)) {\n        href = `mailto:${text}`;\n    }\n    const hrefAttribute = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find(attr => attr.name === 'href');\n    if (!hrefAttribute) {\n        node.attributes = [{ name: 'href', value: [href], valueType: 'doubleQuote' }];\n    }\n    else if (!hrefAttribute.value) {\n        hrefAttribute.value = [href];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parseAbbreviation;\nexport { convert, getToken, abbreviation as parse, tokenize };\n//# sourceMappingURL=abbreviation.es.js.map\n","import Scanner, { isNumber, isAlpha, isAlphaWord, isQuote, isSpace, isAlphaNumericWord, ScannerError } from '@emmetio/scanner';\n\nfunction tokenize(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = getToken(scanner, brackets === 0 && !isValue);\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, short) {\n    return field(scanner)\n        || numberValue(scanner)\n        || colorValue(scanner)\n        || stringValue(scanner)\n        || bracket(scanner)\n        || operator(scanner)\n        || whiteSpace(scanner)\n        || literal(scanner, short);\n}\nfunction field(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n */\nfunction literal(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral : isKeyword);\n    }\n    else {\n        // Allow dots only at the beginning of literal\n        scanner.eat(46 /* Dot */);\n        scanner.eatWhile(isLiteral);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(37 /* Percent */) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === 39 /* SingleQuote */ ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc   → #aabbccc\n    // #0     → #000000\n    // #fff.5 → rgba(255, 255, 255, 0.5)\n    // #t     → transparent\n    const start = scanner.pos;\n    if (scanner.eat(35 /* Hash */)) {\n        const valueStart = scanner.pos;\n        let color = '';\n        let alpha = '';\n        if (scanner.eatWhile(isHex)) {\n            color = scanner.substring(valueStart, scanner.pos);\n            alpha = colorAlpha(scanner);\n        }\n        else if (scanner.eat(116 /* Transparent */)) {\n            color = '0';\n            alpha = colorAlpha(scanner) || '0';\n        }\n        else {\n            alpha = colorAlpha(scanner);\n        }\n        if (color || alpha || scanner.eof()) {\n            const { r, g, b, a } = parseColor(color, alpha);\n            return {\n                type: 'ColorValue',\n                r, g, b, a,\n                raw: scanner.substring(start + 1, scanner.pos),\n                start,\n                end: scanner.pos\n            };\n        }\n        else {\n            // Consumed # but no actual value: invalid color value, treat it as literal\n            return createLiteral(scanner, start);\n        }\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes alpha value of color: `.1`\n */\nfunction colorAlpha(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */)) {\n        scanner.start = start;\n        if (scanner.eatWhile(isNumber)) {\n            return scanner.current();\n        }\n        return '1';\n    }\n    return '';\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    if (isBracket(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === 40 /* RoundBracketOpen */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(45 /* Dash */);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber);\n    const prevPos = stream.pos;\n    if (stream.eat(46 /* Dot */)) {\n        // It’s perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === 64 /* At */ || code === 36 /* Dollar */;\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 43 /* Sibling */ && \"+\" /* Sibling */)\n        || (ch === 33 /* Excl */ && \"!\" /* Important */)\n        || (ch === 44 /* Comma */ && \",\" /* ArgumentDelimiter */)\n        || (ch === 58 /* Colon */ && \":\" /* PropertyDelimiter */)\n        || (ch === 45 /* Dash */ && \"-\" /* ValueDelimiter */)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber(code) || isAlpha(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === 45 /* Dash */;\n}\nfunction isBracket(code) {\n    return code === 40 /* RoundBracketOpen */ || code === 41 /* RoundBracketClose */;\n}\nfunction isLiteral(code) {\n    return isAlphaWord(code) || code === 37 /* Percent */ || code === 47 /* Slash */;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral(scanner, start, end));\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    if (test(peek(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner(tokens);\n    const result = [];\n    let property;\n    while (readable(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume(scanner, isSiblingOperator)) {\n            throw error(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek(scanner);\n    const valueMode = !!options.value;\n    if (!valueMode && isLiteral$1(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    if (valueMode) {\n        consume(scanner, isWhiteSpace);\n    }\n    while (readable(scanner)) {\n        if (consume(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner, valueMode)) {\n            value.push(valueFragment);\n        }\n        else if (!consume(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner, inArgument) {\n    const result = [];\n    let token;\n    let args;\n    while (readable(scanner)) {\n        token = peek(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral$1(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token) || (inArgument && isWhiteSpace(token))) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isOpenBracket)) {\n        const args = [];\n        let value;\n        while (readable(scanner) && !consume(scanner, isCloseBracket)) {\n            if (value = consumeValue(scanner, true)) {\n                args.push(value);\n            }\n            else if (!consume(scanner, isWhiteSpace) && !consume(scanner, isArgumentDelimiter)) {\n                throw error(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral$1(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket$1(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket(token) {\n    return isBracket$1(token, true);\n}\nfunction isCloseBracket(token) {\n    return isBracket$1(token, false);\n}\nfunction isWhiteSpace(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, \"+\" /* Sibling */);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator(token, \",\" /* ArgumentDelimiter */);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token);\n}\nfunction isImportant(token) {\n    return isOperator(token, \"!\" /* Important */);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field';\n}\nfunction isValueDelimiter(token) {\n    return isOperator(token, \":\" /* PropertyDelimiter */)\n        || isOperator(token, \"-\" /* ValueDelimiter */);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral$1(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parse;\nexport { getToken, parser, tokenize };\n","import parse$2 from '@emmetio/abbreviation';\nexport { default as markupAbbreviation } from '@emmetio/abbreviation';\nimport parse$3 from '@emmetio/css-abbreviation';\nexport { default as stylesheetAbbreviation } from '@emmetio/css-abbreviation';\n\n/**\n * Merges attributes in current node: de-duplicates attributes with the same name\n * and merges class names\n */\nfunction mergeAttributes(node, config) {\n    if (!node.attributes) {\n        return;\n    }\n    const attributes = [];\n    const lookup = {};\n    for (const attr of node.attributes) {\n        if (attr.name) {\n            const attrName = attr.name;\n            if (attrName in lookup) {\n                const prev = lookup[attrName];\n                if (attrName === 'class') {\n                    prev.value = mergeValue(prev.value, attr.value, ' ');\n                }\n                else {\n                    mergeDeclarations(prev, attr, config);\n                }\n            }\n            else {\n                // Create new attribute instance so we can safely modify it later\n                attributes.push(lookup[attrName] = Object.assign({}, attr));\n            }\n        }\n        else {\n            attributes.push(attr);\n        }\n    }\n    node.attributes = attributes;\n}\n/**\n * Merges two token lists into single list. Adjacent strings are merged together\n */\nfunction mergeValue(prev, next, glue) {\n    if (prev && next) {\n        if (prev.length && glue) {\n            append(prev, glue);\n        }\n        for (const t of next) {\n            append(prev, t);\n        }\n        return prev;\n    }\n    const result = prev || next;\n    return result && result.slice();\n}\n/**\n * Merges data from `src` attribute into `dest` and returns it\n */\nfunction mergeDeclarations(dest, src, config) {\n    dest.name = src.name;\n    if (!config.options['output.reverseAttributes']) {\n        dest.value = src.value;\n    }\n    // Keep high-priority properties\n    if (!dest.implied) {\n        dest.implied = src.implied;\n    }\n    if (!dest.boolean) {\n        dest.boolean = src.boolean;\n    }\n    if (dest.valueType !== 'expression') {\n        dest.valueType = src.valueType;\n    }\n    return dest;\n}\nfunction append(tokens, value) {\n    const lastIx = tokens.length - 1;\n    if (typeof tokens[lastIx] === 'string' && typeof value === 'string') {\n        tokens[lastIx] += value;\n    }\n    else {\n        tokens.push(value);\n    }\n}\n\n/**\n * Walks over each child node of given markup abbreviation AST node (not including\n * given one) and invokes `fn` on each node.\n * The `fn` callback accepts context node, list of ancestor nodes and optional\n * state object\n */\nfunction walk(node, fn, state) {\n    const ancestors = [node];\n    const callback = (ctx) => {\n        fn(ctx, ancestors, state);\n        ancestors.push(ctx);\n        ctx.children.forEach(callback);\n        ancestors.pop();\n    };\n    node.children.forEach(callback);\n}\n/**\n * Finds node which is the deepest for in current node or node itself.\n */\nfunction findDeepest(node) {\n    let parent;\n    while (node.children.length) {\n        parent = node;\n        node = node.children[node.children.length - 1];\n    }\n    return { parent, node };\n}\nfunction isNode(node) {\n    return node.type === 'AbbreviationNode';\n}\n\n/**\n * Finds matching snippet from `registry` and resolves it into a parsed abbreviation.\n * Resolved node is then updated or replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attributes and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n */\nfunction resolveSnippets(abbr, config) {\n    const stack = [];\n    const reversed = config.options['output.reverseAttributes'];\n    const resolve = (child) => {\n        const snippet = child.name && config.snippets[child.name];\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.includes(snippet)) {\n            return null;\n        }\n        const snippetAbbr = parse$2(snippet, config);\n        stack.push(snippet);\n        walkResolve(snippetAbbr, resolve);\n        stack.pop();\n        // Add attributes from current node into every top-level node of parsed abbreviation\n        for (const topNode of snippetAbbr.children) {\n            if (child.attributes) {\n                const from = topNode.attributes || [];\n                const to = child.attributes || [];\n                topNode.attributes = reversed ? to.concat(from) : from.concat(to);\n            }\n            mergeNodes(child, topNode);\n        }\n        return snippetAbbr;\n    };\n    walkResolve(abbr, resolve);\n    return abbr;\n}\nfunction walkResolve(node, resolve, config) {\n    let children = [];\n    for (const child of node.children) {\n        const resolved = resolve(child);\n        if (resolved) {\n            children = children.concat(resolved.children);\n            const deepest = findDeepest(resolved);\n            if (isNode(deepest.node)) {\n                deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));\n            }\n        }\n        else {\n            children.push(child);\n            child.children = walkResolve(child, resolve);\n        }\n    }\n    return node.children = children;\n}\n/**\n * Adds data from first node into second node\n */\nfunction mergeNodes(from, to) {\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n    if (from.value != null) {\n        to.value = from.value;\n    }\n    if (from.repeat) {\n        to.repeat = from.repeat;\n    }\n}\n\nfunction createOutputStream(options, level = 0) {\n    return {\n        options,\n        value: '',\n        level,\n        offset: 0,\n        line: 0,\n        column: 0\n    };\n}\n/**\n * Pushes plain string into output stream without newline processing\n */\nfunction push(stream, text) {\n    const processText = stream.options['output.text'];\n    _push(stream, processText(text, stream.offset, stream.line, stream.column));\n}\n/**\n * Pushes given string with possible newline formatting into output\n */\nfunction pushString(stream, value) {\n    // If given value contains newlines, we should push content line-by-line and\n    // use `pushNewline()` to maintain proper line/column state\n    const lines = splitByLines(value);\n    for (let i = 0, il = lines.length - 1; i <= il; i++) {\n        push(stream, lines[i]);\n        if (i !== il) {\n            pushNewline(stream, true);\n        }\n    }\n}\n/**\n * Pushes new line into given output stream\n */\nfunction pushNewline(stream, indent) {\n    const baseIndent = stream.options['output.baseIndent'];\n    const newline = stream.options['output.newline'];\n    push(stream, newline + baseIndent);\n    stream.line++;\n    stream.column = baseIndent.length;\n    if (indent) {\n        pushIndent(stream, indent === true ? stream.level : indent);\n    }\n}\n/**\n * Adds indentation of `size` to current output stream\n */\nfunction pushIndent(stream, size = stream.level) {\n    const indent = stream.options['output.indent'];\n    push(stream, indent.repeat(Math.max(size, 0)));\n}\n/**\n * Pushes field/tabstop into output stream\n */\nfunction pushField(stream, index, placeholder) {\n    const field = stream.options['output.field'];\n    // NB: use `_push` instead of `push` to skip text processing\n    _push(stream, field(index, placeholder, stream.offset, stream.line, stream.column));\n}\n/**\n * Returns given tag name formatted according to given config\n */\nfunction tagName(name, config) {\n    return strCase(name, config.options['output.tagCase']);\n}\n/**\n * Returns given attribute name formatted according to given config\n */\nfunction attrName(name, config) {\n    return strCase(name, config.options['output.attributeCase']);\n}\n/**\n * Returns character for quoting value of given attribute\n */\nfunction attrQuote(attr, config, isOpen) {\n    if (attr.valueType === 'expression') {\n        return isOpen ? '{' : '}';\n    }\n    return config.options['output.attributeQuotes'] === 'single' ? '\\'' : '\"';\n}\n/**\n * Check if given attribute is boolean\n */\nfunction isBooleanAttribute(attr, config) {\n    return attr.boolean\n        || config.options['output.booleanAttributes'].includes((attr.name || '').toLowerCase());\n}\n/**\n * Returns a token for self-closing tag, depending on current options\n */\nfunction selfClose(config) {\n    switch (config.options['output.selfClosingStyle']) {\n        case 'xhtml': return ' /';\n        case 'xml': return '/';\n        default: return '';\n    }\n}\n/**\n * Check if given tag name belongs to inline-level element\n * @param node Parsed node or tag name\n */\nfunction isInline(node, config) {\n    if (typeof node === 'string') {\n        return config.options.inlineElements.includes(node.toLowerCase());\n    }\n    // inline node is a node either with inline-level name or text-only node\n    return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);\n}\n/**\n * Splits given text by lines\n */\nfunction splitByLines(text) {\n    return text.split(/\\r\\n|\\r|\\n/g);\n}\n/**\n * Pushes raw string into output stream without any processing\n */\nfunction _push(stream, text) {\n    stream.value += text;\n    stream.offset += text.length;\n    stream.column += text.length;\n}\nfunction strCase(str, type) {\n    if (type) {\n        return type === 'upper' ? str.toUpperCase() : str.toLowerCase();\n    }\n    return str;\n}\n\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\nfunction implicitTag(node, ancestors, config) {\n    if (!node.name && node.attributes) {\n        resolveImplicitTag(node, ancestors, config);\n    }\n}\nfunction resolveImplicitTag(node, ancestors, config) {\n    const parent = getParentElement(ancestors);\n    const contextName = config.context ? config.context.name : '';\n    const parentName = lowercase(parent ? parent.name : contextName);\n    node.name = elementMap[parentName]\n        || (isInline(parentName, config) ? 'span' : 'div');\n}\nfunction lowercase(str) {\n    return (str || '').toLowerCase();\n}\n/**\n * Returns closest element node from given ancestors list\n */\nfunction getParentElement(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const elem = ancestors[i];\n        if (isNode(elem)) {\n            return elem;\n        }\n    }\n}\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst vocabularies = { ru, sp, latin };\nconst reLorem = /^lorem([a-z]*)(\\d*)(-\\d*)?$/i;\nfunction lorem(node, ancestors, config) {\n    let m;\n    if (node.name && (m = node.name.match(reLorem))) {\n        const db = vocabularies[m[1]] || vocabularies.latin;\n        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;\n        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;\n        const wordCount = rand(minWordCount, maxWordCount);\n        const repeat = node.repeat || findRepeater(ancestors);\n        node.name = node.attributes = void 0;\n        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];\n        if (node.repeat && ancestors.length > 1) {\n            resolveImplicitTag(node, ancestors, config);\n        }\n    }\n}\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n */\nfunction rand(from, to) {\n    return Math.floor(Math.random() * (to - from) + from);\n}\nfunction sample(arr, count) {\n    const len = arr.length;\n    const iterations = Math.min(len, count);\n    const result = [];\n    while (result.length < iterations) {\n        const str = arr[rand(0, len)];\n        if (!result.includes(str)) {\n            result.push(str);\n        }\n    }\n    return result;\n}\nfunction choice(val) {\n    return val[rand(0, val.length - 1)];\n}\nfunction sentence(words, end) {\n    if (words.length) {\n        words = [capitalize(words[0])].concat(words.slice(1));\n    }\n    return words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\nfunction capitalize(word) {\n    return word[0].toUpperCase() + word.slice(1);\n}\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside `words` array\n */\nfunction insertCommas(words) {\n    if (words.length < 2) {\n        return words;\n    }\n    words = words.slice();\n    const len = words.length;\n    const hasComma = /,$/;\n    let totalCommas = 0;\n    if (len > 3 && len <= 6) {\n        totalCommas = rand(0, 1);\n    }\n    else if (len > 6 && len <= 12) {\n        totalCommas = rand(0, 2);\n    }\n    else {\n        totalCommas = rand(1, 4);\n    }\n    for (let i = 0, pos; i < totalCommas; i++) {\n        pos = rand(0, len - 2);\n        if (!hasComma.test(words[pos])) {\n            words[pos] += ',';\n        }\n    }\n    return words;\n}\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param dict Words dictionary\n * @param wordCount Words count in paragraph\n * @param startWithCommon Should paragraph start with common \"lorem ipsum\" sentence.\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n    const result = [];\n    let totalWords = 0;\n    let words;\n    if (startWithCommon && dict.common) {\n        words = dict.common.slice(0, wordCount);\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words), '.'));\n    }\n    while (totalWords < wordCount) {\n        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words)));\n    }\n    return result.join(' ');\n}\nfunction findRepeater(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const element = ancestors[i];\n        if (element.type === 'AbbreviationNode' && element.repeat) {\n            return element.repeat;\n        }\n    }\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nfunction jsx(node) {\n    if (node.attributes) {\n        node.attributes.forEach(rename);\n    }\n}\nfunction rename(attr) {\n    if (attr.name === 'class') {\n        attr.name = 'className';\n    }\n    else if (attr.name === 'for') {\n        attr.name = 'htmlFor';\n    }\n}\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nfunction xsl(node) {\n    if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {\n        node.attributes = node.attributes.filter(isAllowed);\n    }\n}\nfunction isAllowed(attr) {\n    return attr.name !== 'select';\n}\nfunction matchesName(name) {\n    return name === 'xsl:variable' || name === 'xsl:with-param';\n}\n\nconst reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = (className) => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = (className) => /^[a-z]/i.test(className);\nfunction bem(node, ancestors, config) {\n    expandClassNames(node);\n    expandShortNotation(node, ancestors, config);\n}\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n */\nfunction expandClassNames(node) {\n    const data = getBEMData(node);\n    const classNames = [];\n    for (const cl of data.classNames) {\n        // remove all modifiers and element prefixes from class name to get a base element name\n        const ix = cl.indexOf('_');\n        if (ix > 0 && !cl.startsWith('-')) {\n            classNames.push(cl.slice(0, ix));\n            classNames.push(cl.slice(ix));\n        }\n        else {\n            classNames.push(cl);\n        }\n    }\n    if (classNames.length) {\n        data.classNames = classNames.filter(uniqueClass);\n        data.block = findBlockName(data.classNames);\n        updateClass(node, data.classNames.join(' '));\n    }\n}\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n */\nfunction expandShortNotation(node, ancestors, config) {\n    const data = getBEMData(node);\n    const classNames = [];\n    const { options } = config;\n    const path = ancestors.slice(1).concat(node);\n    for (let cl of data.classNames) {\n        let prefix = '';\n        let m;\n        const originalClass = cl;\n        // parse element definition (could be only one)\n        if (m = cl.match(reElement)) {\n            prefix = getBlockName(path, m[1].length, config.context) + options['bem.element'] + m[2];\n            classNames.push(prefix);\n            cl = cl.slice(m[0].length);\n        }\n        // parse modifiers definitions\n        if (m = cl.match(reModifier)) {\n            if (!prefix) {\n                prefix = getBlockName(path, m[1].length);\n                classNames.push(prefix);\n            }\n            classNames.push(`${prefix}${options['bem.modifier']}${m[2]}`);\n            cl = cl.slice(m[0].length);\n        }\n        if (cl === originalClass) {\n            // class name wasn’t modified: it’s not a BEM-specific class,\n            // add it as-is into output\n            classNames.push(originalClass);\n        }\n    }\n    const arrClassNames = classNames.filter(uniqueClass);\n    if (arrClassNames.length) {\n        updateClass(node, arrClassNames.join(' '));\n    }\n}\n/**\n * Returns BEM data from given abbreviation node\n */\nfunction getBEMData(node) {\n    if (!node._bem) {\n        let classValue = '';\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (attr.name === 'class' && attr.value) {\n                    classValue = stringifyValue(attr.value);\n                    break;\n                }\n            }\n        }\n        node._bem = parseBEM(classValue);\n    }\n    return node._bem;\n}\nfunction getBEMDataFromContext(context) {\n    if (!context._bem) {\n        context._bem = parseBEM(context.attributes && context.attributes.class || '');\n    }\n    return context._bem;\n}\n/**\n * Parses BEM data from given class name\n */\nfunction parseBEM(classValue) {\n    const classNames = classValue ? classValue.split(/\\s+/) : [];\n    return {\n        classNames,\n        block: findBlockName(classNames)\n    };\n}\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n */\nfunction getBlockName(ancestors, depth = 0, context) {\n    const maxParentIx = 0;\n    let parentIx = Math.max(ancestors.length - depth, maxParentIx);\n    do {\n        const parent = ancestors[parentIx];\n        if (parent) {\n            const data = getBEMData(parent);\n            if (data.block) {\n                return data.block;\n            }\n        }\n    } while (maxParentIx < parentIx--);\n    if (context) {\n        const data = getBEMDataFromContext(context);\n        if (data.block) {\n            return data.block;\n        }\n    }\n    return '';\n}\nfunction findBlockName(classNames) {\n    return find(classNames, blockCandidates1)\n        || find(classNames, blockCandidates2)\n        || void 0;\n}\n/**\n * Finds class name from given list which may be used as block name\n */\nfunction find(classNames, filter) {\n    for (const cl of classNames) {\n        if (reElement.test(cl) || reModifier.test(cl)) {\n            break;\n        }\n        if (filter(cl)) {\n            return cl;\n        }\n    }\n}\nfunction updateClass(node, value) {\n    for (const attr of node.attributes) {\n        if (attr.name === 'class') {\n            attr.value = [value];\n            break;\n        }\n    }\n}\nfunction stringifyValue(value) {\n    let result = '';\n    for (const t of value) {\n        result += typeof t === 'string' ? t : t.name;\n    }\n    return result;\n}\nfunction uniqueClass(item, ix, arr) {\n    return !!item && arr.indexOf(item) === ix;\n}\n\nfunction walk$1(abbr, visitor, state) {\n    const callback = (ctx, index, items) => {\n        const { parent, current } = state;\n        state.parent = current;\n        state.current = ctx;\n        visitor(ctx, index, items, state, next);\n        state.current = current;\n        state.parent = parent;\n    };\n    const next = (node, index, items) => {\n        state.ancestors.push(state.current);\n        callback(node, index, items);\n        state.ancestors.pop();\n    };\n    abbr.children.forEach(callback);\n}\nfunction createWalkState(config) {\n    return {\n        // @ts-ignore: Will set value in iterator\n        current: null,\n        parent: void 0,\n        ancestors: [],\n        config,\n        field: 1,\n        out: createOutputStream(config.options)\n    };\n}\n\nconst caret = [{ type: 'Field', index: 0, name: '' }];\n/**\n * Check if given node is a snippet: a node without name and attributes\n */\nfunction isSnippet(node) {\n    return node ? !node.name && !node.attributes : false;\n}\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n */\nfunction isInlineElement(node, config) {\n    return node ? isInline(node, config) : false;\n}\n/**\n * Check if given value token is a field\n */\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field';\n}\nfunction pushTokens(tokens, state) {\n    const { out } = state;\n    let largestIndex = -1;\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            pushString(out, t);\n        }\n        else {\n            pushField(out, state.field + t.index, t.name);\n            if (t.index > largestIndex) {\n                largestIndex = t.index;\n            }\n        }\n    }\n    if (largestIndex !== -1) {\n        state.field += largestIndex + 1;\n    }\n}\n/**\n * Splits given value token by lines: returns array where each entry is a token list\n * for a single line\n */\nfunction splitByLines$1(tokens) {\n    const result = [];\n    let line = [];\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            const lines = t.split(/\\r\\n?|\\n/g);\n            line.push(lines.shift() || '');\n            while (lines.length) {\n                result.push(line);\n                line = [lines.shift() || ''];\n            }\n        }\n        else {\n            line.push(t);\n        }\n    }\n    line.length && result.push(line);\n    return result;\n}\n/**\n * Check if given attribute should be outputted\n */\nfunction shouldOutputAttribute(attr) {\n    // In case if attribute is implied, check if it has a defined value:\n    // either non-empty value or quoted empty value\n    return !attr.implied || attr.valueType !== 'raw' || (!!attr.value && attr.value.length > 0);\n}\n\n/**\n * Splits given string into template tokens.\n * Template is a string which contains placeholders which are uppercase names\n * between `[` and `]`, for example: `[PLACEHOLDER]`.\n * Unlike other templates, a placeholder may contain extra characters before and\n * after name: `[%PLACEHOLDER.]`. If data for `PLACEHOLDER` is defined, it will\n * be outputted with with these extra character, otherwise will be completely omitted.\n */\nfunction template(text) {\n    const tokens = [];\n    const scanner = { pos: 0, text };\n    let placeholder;\n    let offset = scanner.pos;\n    let pos = scanner.pos;\n    while (scanner.pos < scanner.text.length) {\n        pos = scanner.pos;\n        if (placeholder = consumePlaceholder(scanner)) {\n            if (offset !== scanner.pos) {\n                tokens.push(text.slice(offset, pos));\n            }\n            tokens.push(placeholder);\n            offset = scanner.pos;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n    if (offset !== scanner.pos) {\n        tokens.push(text.slice(offset));\n    }\n    return tokens;\n}\n/**\n * Consumes placeholder like `[#ID]` from given scanner\n */\nfunction consumePlaceholder(scanner) {\n    if (peek(scanner) === 91 /* Start */) {\n        const start = ++scanner.pos;\n        let namePos = start;\n        let afterPos = start;\n        let stack = 1;\n        while (scanner.pos < scanner.text.length) {\n            const code = peek(scanner);\n            if (isTokenStart(code)) {\n                namePos = scanner.pos;\n                while (isToken(peek(scanner))) {\n                    scanner.pos++;\n                }\n                afterPos = scanner.pos;\n            }\n            else {\n                if (code === 91 /* Start */) {\n                    stack++;\n                }\n                else if (code === 93 /* End */) {\n                    if (--stack === 0) {\n                        return {\n                            before: scanner.text.slice(start, namePos),\n                            after: scanner.text.slice(afterPos, scanner.pos++),\n                            name: scanner.text.slice(namePos, afterPos)\n                        };\n                    }\n                }\n                scanner.pos++;\n            }\n        }\n    }\n}\nfunction peek(scanner, pos = scanner.pos) {\n    return scanner.text.charCodeAt(pos);\n}\nfunction isTokenStart(code) {\n    return code >= 65 && code <= 90; // A-Z\n}\nfunction isToken(code) {\n    return isTokenStart(code)\n        || (code > 47 && code < 58) /* 0-9 */\n        || code === 95 /* Underscore */\n        || code === 45 /* Dash */;\n}\n\nfunction createCommentState(config) {\n    const { options } = config;\n    return {\n        enabled: options['comment.enabled'],\n        trigger: options['comment.trigger'],\n        before: options['comment.before'] ? template(options['comment.before']) : void 0,\n        after: options['comment.after'] ? template(options['comment.after']) : void 0\n    };\n}\n/**\n * Adds comment prefix for given node, if required\n */\nfunction commentNodeBefore(node, state) {\n    if (shouldComment(node, state) && state.comment.before) {\n        output(node, state.comment.before, state);\n    }\n}\n/**\n * Adds comment suffix for given node, if required\n */\nfunction commentNodeAfter(node, state) {\n    if (shouldComment(node, state) && state.comment.after) {\n        output(node, state.comment.after, state);\n    }\n}\n/**\n * Check if given node should be commented\n */\nfunction shouldComment(node, state) {\n    const { comment } = state;\n    if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {\n        return false;\n    }\n    for (const attr of node.attributes) {\n        if (attr.name && comment.trigger.includes(attr.name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Pushes given template tokens into output stream\n */\nfunction output(node, tokens, state) {\n    const attrs = {};\n    const { out } = state;\n    // Collect attributes payload\n    for (const attr of node.attributes) {\n        if (attr.name && attr.value) {\n            attrs[attr.name.toUpperCase()] = attr.value;\n        }\n    }\n    // Output parsed tokens\n    for (const token of tokens) {\n        if (typeof token === 'string') {\n            pushString(out, token);\n        }\n        else if (attrs[token.name]) {\n            pushString(out, token.before);\n            pushTokens(attrs[token.name], state);\n            pushString(out, token.after);\n        }\n    }\n}\n\nconst htmlTagRegex = /^<([\\w\\-:]+)[\\s>]/;\nfunction html(abbr, config) {\n    const state = createWalkState(config);\n    state.comment = createCommentState(config);\n    walk$1(abbr, element, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element(node, index, items, state, next) {\n    const { out, config } = state;\n    const format = shouldFormat(node, index, items, state);\n    // Pick offset level for current node\n    const level = getIndent(state);\n    out.level += level;\n    format && pushNewline(out, true);\n    if (node.name) {\n        const name = tagName(node.name, config);\n        commentNodeBefore(node, state);\n        pushString(out, `<${name}`);\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (shouldOutputAttribute(attr)) {\n                    pushAttribute(attr, state);\n                }\n            }\n        }\n        if (node.selfClosing && !node.children.length && !node.value) {\n            pushString(out, `${selfClose(config)}>`);\n        }\n        else {\n            pushString(out, '>');\n            if (!pushSnippet(node, state, next)) {\n                if (node.value) {\n                    const innerFormat = node.value.some(hasNewline) || startsWithBlockTag(node.value, config);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(node.value, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n                node.children.forEach(next);\n                if (!node.value && !node.children.length) {\n                    const innerFormat = config.options['output.formatLeafNode']\n                        || config.options['output.formatForce'].includes(node.name);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(caret, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n            }\n            pushString(out, `</${name}>`);\n            commentNodeAfter(node, state);\n        }\n    }\n    else if (!pushSnippet(node, state, next) && node.value) {\n        // A text-only node (snippet)\n        pushTokens(node.value, state);\n        node.children.forEach(next);\n    }\n    if (format && index === items.length - 1 && state.parent) {\n        const offset = isSnippet(state.parent) ? 0 : 1;\n        pushNewline(out, out.level - offset);\n    }\n    out.level -= level;\n}\n/**\n * Outputs given attribute’s content into output stream\n */\nfunction pushAttribute(attr, state) {\n    const { out, config } = state;\n    if (attr.name) {\n        const name = attrName(attr.name, config);\n        const lQuote = attrQuote(attr, config, true);\n        const rQuote = attrQuote(attr, config);\n        let value = attr.value;\n        if (isBooleanAttribute(attr, config) && !value) {\n            // If attribute value is omitted and it’s a boolean value, check for\n            // `compactBoolean` option: if it’s disabled, set value to attribute name\n            // (XML style)\n            if (!config.options['output.compactBoolean']) {\n                value = [name];\n            }\n        }\n        else if (!value) {\n            value = caret;\n        }\n        pushString(out, ' ' + name);\n        if (value) {\n            pushString(out, '=' + lQuote);\n            pushTokens(value, state);\n            pushString(out, rQuote);\n        }\n        else if (config.options['output.selfClosingStyle'] !== 'html') {\n            pushString(out, '=' + lQuote + rQuote);\n        }\n    }\n}\nfunction pushSnippet(node, state, next) {\n    if (node.value && node.children.length) {\n        // We have a value and child nodes. In case if value contains fields,\n        // we should output children as a content of first field\n        const fieldIx = node.value.findIndex(isField);\n        if (fieldIx !== -1) {\n            pushTokens(node.value.slice(0, fieldIx), state);\n            const line = state.out.line;\n            let pos = fieldIx + 1;\n            node.children.forEach(next);\n            // If there was a line change, trim leading whitespace for better result\n            if (state.out.line !== line && typeof node.value[pos] === 'string') {\n                pushString(state.out, node.value[pos++].trimLeft());\n            }\n            pushTokens(node.value.slice(pos), state);\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Check if given node should be formatted in its parent context\n */\nfunction shouldFormat(node, index, items, state) {\n    const { config, parent } = state;\n    if (!config.options['output.format']) {\n        return false;\n    }\n    if (index === 0 && !parent) {\n        // Do not format very first node\n        return false;\n    }\n    // Do not format single child of snippet\n    if (parent && isSnippet(parent) && items.length === 1) {\n        return false;\n    }\n    /**\n     * Adjacent text-only/snippet nodes\n     */\n    if (isSnippet(node)) {\n        // Adjacent text-only/snippet nodes\n        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1])\n            // Has newlines: looks like wrapping code fragment\n            || node.value.some(hasNewline)\n            // Format as wrapper: contains children which will be outputted as field content\n            || (node.value.some(isField) && node.children.length);\n        if (format) {\n            return true;\n        }\n    }\n    if (isInline(node, config)) {\n        // Check if inline node is the next sibling of block-level node\n        if (index === 0) {\n            // First node in parent: format if it’s followed by a block-level element\n            for (let i = 0; i < items.length; i++) {\n                if (!isInline(items[i], config)) {\n                    return true;\n                }\n            }\n        }\n        else if (!isInline(items[index - 1], config)) {\n            // Node is right after block-level element\n            return true;\n        }\n        if (config.options['output.inlineBreak']) {\n            // check for adjacent inline elements before and after current element\n            let adjacentInline = 1;\n            let before = index;\n            let after = index;\n            while (isInlineElement(items[--before], config)) {\n                adjacentInline++;\n            }\n            while (isInlineElement(items[++after], config)) {\n                adjacentInline++;\n            }\n            if (adjacentInline >= config.options['output.inlineBreak']) {\n                return true;\n            }\n        }\n        // Edge case: inline node contains node that should receive formatting\n        for (let i = 0, il = node.children.length; i < il; i++) {\n            if (shouldFormat(node.children[i], i, node.children, state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Returns indentation offset for given node\n */\nfunction getIndent(state) {\n    const { config, parent } = state;\n    if (!parent || isSnippet(parent) || (parent.name && config.options['output.formatSkip'].includes(parent.name))) {\n        return 0;\n    }\n    return 1;\n}\n/**\n * Check if given node value contains newlines\n */\nfunction hasNewline(value) {\n    return typeof value === 'string' && /\\r|\\n/.test(value);\n}\n/**\n * Check if given node value starts with block-level tag\n */\nfunction startsWithBlockTag(value, config) {\n    if (value.length && typeof value[0] === 'string') {\n        const matches = htmlTagRegex.exec(value[0]);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) && !config.options['inlineElements'].includes(matches[1].toLowerCase())) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction indentFormat(abbr, config, options) {\n    const state = createWalkState(config);\n    state.options = options || {};\n    walk$1(abbr, element$1, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element$1(node, index, items, state, next) {\n    const { out, options } = state;\n    const { primary, secondary } = collectAttributes(node);\n    // Pick offset level for current node\n    const level = state.parent ? 1 : 0;\n    out.level += level;\n    // Do not indent top-level elements\n    if (shouldFormat$1(node, index, items, state)) {\n        pushNewline(out, true);\n    }\n    if (node.name && (node.name !== 'div' || !primary.length)) {\n        pushString(out, (options.beforeName || '') + node.name + (options.afterName || ''));\n    }\n    pushPrimaryAttributes(primary, state);\n    pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);\n    if (node.selfClosing && !node.value && !node.children.length) {\n        if (state.options.selfClose) {\n            pushString(out, state.options.selfClose);\n        }\n    }\n    else {\n        pushValue(node, state);\n        node.children.forEach(next);\n    }\n    out.level -= level;\n}\n/**\n * From given node, collects all attributes as `primary` (id, class) and\n * `secondary` (all the rest) lists. In most indent-based syntaxes, primary attribute\n * has special syntax\n */\nfunction collectAttributes(node) {\n    const primary = [];\n    const secondary = [];\n    if (node.attributes) {\n        for (const attr of node.attributes) {\n            if (isPrimaryAttribute(attr)) {\n                primary.push(attr);\n            }\n            else {\n                secondary.push(attr);\n            }\n        }\n    }\n    return { primary, secondary };\n}\n/**\n * Outputs given attributes as primary into output stream\n */\nfunction pushPrimaryAttributes(attrs, state) {\n    for (const attr of attrs) {\n        if (attr.value) {\n            if (attr.name === 'class') {\n                pushString(state.out, '.');\n                // All whitespace characters must be replaced with dots in class names\n                const tokens = attr.value.map(t => typeof t === 'string' ? t.replace(/\\s+/g, '.') : t);\n                pushTokens(tokens, state);\n            }\n            else {\n                // ID attribute\n                pushString(state.out, '#');\n                pushTokens(attr.value, state);\n            }\n        }\n    }\n}\n/**\n * Outputs given attributes as secondary into output stream\n */\nfunction pushSecondaryAttributes(attrs, state) {\n    if (attrs.length) {\n        const { out, config, options } = state;\n        options.beforeAttribute && pushString(out, options.beforeAttribute);\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            pushString(out, attrName(attr.name || '', config));\n            if (isBooleanAttribute(attr, config) && !attr.value) {\n                if (!config.options['output.compactBoolean'] && options.booleanValue) {\n                    pushString(out, '=' + options.booleanValue);\n                }\n            }\n            else {\n                pushString(out, '=' + attrQuote(attr, config, true));\n                pushTokens(attr.value || caret, state);\n                pushString(out, attrQuote(attr, config));\n            }\n            if (i !== attrs.length - 1 && options.glueAttribute) {\n                pushString(out, options.glueAttribute);\n            }\n        }\n        options.afterAttribute && pushString(out, options.afterAttribute);\n    }\n}\n/**\n * Outputs given node value into state output stream\n */\nfunction pushValue(node, state) {\n    // We should either output value or add caret but for leaf nodes only (no children)\n    if (!node.value && node.children.length) {\n        return;\n    }\n    const value = node.value || caret;\n    const lines = splitByLines$1(value);\n    const { out, options } = state;\n    if (lines.length === 1) {\n        if (node.name || node.attributes) {\n            push(out, ' ');\n        }\n        pushTokens(value, state);\n    }\n    else {\n        // We should format multi-line value with terminating `|` character\n        // and same line length\n        const lineLengths = [];\n        let maxLength = 0;\n        // Calculate lengths of all lines and max line length\n        for (const line of lines) {\n            const len = valueLength(line);\n            lineLengths.push(len);\n            if (len > maxLength) {\n                maxLength = len;\n            }\n        }\n        // Output each line, padded to max length\n        out.level++;\n        for (let i = 0; i < lines.length; i++) {\n            pushNewline(out, true);\n            options.beforeTextLine && push(out, options.beforeTextLine);\n            pushTokens(lines[i], state);\n            if (options.afterTextLine) {\n                push(out, ' '.repeat(maxLength - lineLengths[i]));\n                push(out, options.afterTextLine);\n            }\n        }\n        out.level--;\n    }\n}\nfunction isPrimaryAttribute(attr) {\n    return attr.name === 'class' || attr.name === 'id';\n}\n/**\n * Calculates string length from given tokens\n */\nfunction valueLength(tokens) {\n    let len = 0;\n    for (const token of tokens) {\n        len += typeof token === 'string' ? token.length : token.name.length;\n    }\n    return len;\n}\nfunction shouldFormat$1(node, index, items, state) {\n    // Do not format first top-level element or snippets\n    if (!state.parent && index === 0) {\n        return false;\n    }\n    return !isSnippet(node);\n}\n\nfunction haml(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeName: '%',\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ' ',\n        afterTextLine: ' |',\n        booleanValue: 'true',\n        selfClose: '/'\n    });\n}\n\nfunction slim(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: ' ',\n        glueAttribute: ' ',\n        beforeTextLine: '| ',\n        selfClose: '/'\n    });\n}\n\nfunction pug(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ', ',\n        beforeTextLine: '| ',\n        selfClose: config.options['output.selfClosingStyle'] === 'xml' ? '/' : ''\n    });\n}\n\nconst formatters = { html, haml, slim, pug };\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse(abbr, config) {\n    let oldTextValue;\n    if (typeof abbr === 'string') {\n        let parseOpt = config;\n        if (config.options['jsx.enabled']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { jsx: true });\n        }\n        if (config.options['markup.href']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { href: true });\n        }\n        abbr = parse$2(abbr, parseOpt);\n        // remove text field before snippets(abbr, config) call\n        // as abbreviation(abbr, parseOpt) already handled it\n        oldTextValue = config.text;\n        config.text = undefined;\n    }\n    // Run abbreviation resolve in two passes:\n    // 1. Map each node to snippets, which are abbreviations as well. A single snippet\n    // may produce multiple nodes\n    // 2. Transform every resolved node\n    abbr = resolveSnippets(abbr, config);\n    walk(abbr, transform, config);\n    config.text = oldTextValue !== null && oldTextValue !== void 0 ? oldTextValue : config.text;\n    return abbr;\n}\n/**\n * Converts given abbreviation to string according to provided `config`\n */\nfunction stringify(abbr, config) {\n    const formatter = formatters[config.syntax] || html;\n    return formatter(abbr, config);\n}\n/**\n * Modifies given node and prepares it for output\n */\nfunction transform(node, ancestors, config) {\n    implicitTag(node, ancestors, config);\n    mergeAttributes(node, config);\n    lorem(node, ancestors, config);\n    if (config.syntax === 'xsl') {\n        xsl(node);\n    }\n    if (config.options['jsx.enabled']) {\n        jsx(node);\n    }\n    if (config.options['bem.enabled']) {\n        bem(node, ancestors, config);\n    }\n}\n\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r;]+?);*)?$/;\nconst opt = { value: true };\n/**\n * Creates structure for holding resolved CSS snippet\n */\nfunction createSnippet(key, value) {\n    // A snippet could be a raw text snippet (e.g. arbitrary text string) or a\n    // CSS property with possible values separated by `|`.\n    // In latter case, we have to parse snippet as CSS abbreviation\n    const m = value.match(reProperty);\n    if (m) {\n        const keywords = {};\n        const parsed = m[2] ? m[2].split('|').map(parseValue) : [];\n        for (const item of parsed) {\n            for (const cssVal of item) {\n                collectKeywords(cssVal, keywords);\n            }\n        }\n        return {\n            type: \"Property\" /* Property */,\n            key,\n            property: m[1],\n            value: parsed,\n            keywords,\n            dependencies: []\n        };\n    }\n    return { type: \"Raw\" /* Raw */, key, value };\n}\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * `background-position-x` -> `background-position` -> `background`\n */\nfunction nest(snippets) {\n    snippets = snippets.slice().sort(snippetsSort);\n    const stack = [];\n    let prev;\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // background -> background-position -> background-position-x\n    for (const cur of snippets.filter(isProperty)) {\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n            if (cur.property.startsWith(prev.property)\n                && cur.property.charCodeAt(prev.property.length) === 45 /* - */) {\n                prev.dependencies.push(cur);\n                stack.push(cur);\n                break;\n            }\n            stack.pop();\n        }\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n    return snippets;\n}\n/**\n * A sorting function for array of snippets\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n    return a.key < b.key ? -1 : 1;\n}\nfunction parseValue(value) {\n    return parse$3(value.trim(), opt)[0].value;\n}\nfunction isProperty(snippet) {\n    return snippet.type === \"Property\" /* Property */;\n}\nfunction collectKeywords(cssVal, dest) {\n    for (const v of cssVal.value) {\n        if (v.type === 'Literal') {\n            dest[v.value] = v;\n        }\n        else if (v.type === 'FunctionCall') {\n            dest[v.name] = v;\n        }\n        else if (v.type === 'Field') {\n            // Create literal from field, if available\n            const value = v.name.trim();\n            if (value) {\n                dest[value] = { type: 'Literal', value };\n            }\n        }\n    }\n}\n\n/**\n * Calculates how close `str1` matches `str2` using fuzzy match.\n * How matching works:\n * – first characters of both `str1` and `str2` *must* match\n * – `str1` length larger than `str2` length is allowed only when `unmatched` is true\n * – ideal match is when `str1` equals to `str2` (score: 1)\n * – next best match is `str2` starts with `str1` (score: 1 × percent of matched characters)\n * – other scores depend on how close characters of `str1` to the beginning of `str2`\n * @param partialMatch Allow length `str1` to be greater than `str2` length\n */\nfunction scoreMatch(str1, str2, partialMatch = false) {\n    str1 = str1.toLowerCase();\n    str2 = str2.toLowerCase();\n    if (str1 === str2) {\n        return 1;\n    }\n    // Both strings MUST start with the same character\n    if (!str1 || !str2 || str1.charCodeAt(0) !== str2.charCodeAt(0)) {\n        return 0;\n    }\n    const str1Len = str1.length;\n    const str2Len = str2.length;\n    if (!partialMatch && str1Len > str2Len) {\n        return 0;\n    }\n    // Characters from `str1` which are closer to the beginning of a `str2` should\n    // have higher score.\n    // For example, if `str2` is `abcde`, it’s max score is:\n    // 5 + 4 + 3 + 2 + 1 = 15 (sum of character positions in reverse order)\n    // Matching `abd` against `abcde` should produce:\n    // 5 + 4 + 2 = 11\n    // Acronym bonus for match right after `-`. Matching `abd` against `abc-de`\n    // should produce:\n    // 6 + 5 + 4 (use `d` position in `abd`, not in abc-de`)\n    const minLength = Math.min(str1Len, str2Len);\n    const maxLength = Math.max(str1Len, str2Len);\n    let i = 1;\n    let j = 1;\n    let score = maxLength;\n    let ch1 = 0;\n    let ch2 = 0;\n    let found = false;\n    let acronym = false;\n    while (i < str1Len) {\n        ch1 = str1.charCodeAt(i);\n        found = false;\n        acronym = false;\n        while (j < str2Len) {\n            ch2 = str2.charCodeAt(j);\n            if (ch1 === ch2) {\n                found = true;\n                score += maxLength - (acronym ? i : j);\n                break;\n            }\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === 45 /* - */;\n            j++;\n        }\n        if (!found) {\n            if (!partialMatch) {\n                return 0;\n            }\n            break;\n        }\n        i++;\n    }\n    const matchRatio = i / maxLength;\n    const delta = maxLength - minLength;\n    const maxScore = sum(maxLength) - sum(delta);\n    return (score * matchRatio) / maxScore;\n}\n/**\n * Calculates sum of first `n` numbers, e.g. 1+2+3+...n\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nfunction color(token, shortHex) {\n    if (!token.r && !token.g && !token.b && !token.a) {\n        return 'transparent';\n    }\n    else if (token.a === 1) {\n        return asHex(token, shortHex);\n    }\n    return asRGB(token);\n}\n/**\n * Output given color as hex value\n * @param short Produce short value (e.g. #fff instead of #ffffff), if possible\n */\nfunction asHex(token, short) {\n    const fn = (short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b))\n        ? toShortHex : toHex;\n    return '#' + fn(token.r) + fn(token.g) + fn(token.b);\n}\n/**\n * Output current color as `rgba?(...)` CSS color\n */\nfunction asRGB(token) {\n    const values = [token.r, token.g, token.b];\n    if (token.a !== 1) {\n        values.push(frac(token.a, 8));\n    }\n    return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n}\nfunction frac(num, digits = 4) {\n    return num.toFixed(digits).replace(/\\.?0+$/, '');\n}\nfunction isShortHex(hex) {\n    return !(hex % 17);\n}\nfunction toShortHex(num) {\n    return (num >> 4).toString(16);\n}\nfunction toHex(num) {\n    return pad(num.toString(16), 2);\n}\nfunction pad(value, len) {\n    while (value.length < len) {\n        value = '0' + value;\n    }\n    return value;\n}\n\nfunction css(abbr, config) {\n    var _a;\n    const out = createOutputStream(config.options);\n    const format = config.options['output.format'];\n    if (((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === \"@@section\" /* Section */) {\n        // For section context, filter out unmatched snippets\n        abbr = abbr.filter(node => node.snippet);\n    }\n    for (let i = 0; i < abbr.length; i++) {\n        if (format && i !== 0) {\n            pushNewline(out, true);\n        }\n        property(abbr[i], out, config);\n    }\n    return out.value;\n}\n/**\n * Outputs given abbreviation node into output stream\n */\nfunction property(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    if (node.name) {\n        // It’s a CSS property\n        const name = isJSON ? toCamelCase(node.name) : node.name;\n        pushString(out, name + config.options['stylesheet.between']);\n        if (node.value.length) {\n            propertyValue(node, out, config);\n        }\n        else {\n            pushField(out, 0, '');\n        }\n        if (isJSON) {\n            // For CSS-in-JS, always finalize property with comma\n            // NB: seems like `important` is not available in CSS-in-JS syntaxes\n            push(out, ',');\n        }\n        else {\n            outputImportant(node, out, true);\n            push(out, config.options['stylesheet.after']);\n        }\n    }\n    else {\n        // It’s a regular snippet, output plain tokens without any additional formatting\n        for (const cssVal of node.value) {\n            for (const v of cssVal.value) {\n                outputToken(v, out, config);\n            }\n        }\n        outputImportant(node, out, node.value.length > 0);\n    }\n}\nfunction propertyValue(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    const num = isJSON ? getSingleNumeric(node) : null;\n    if (num && (!num.unit || num.unit === 'px')) {\n        // For CSS-in-JS, if property contains single numeric value, output it\n        // as JS number\n        push(out, String(num.value));\n    }\n    else {\n        const quote = getQuote(config);\n        isJSON && push(out, quote);\n        for (let i = 0; i < node.value.length; i++) {\n            if (i !== 0) {\n                push(out, ', ');\n            }\n            outputValue(node.value[i], out, config);\n        }\n        isJSON && push(out, quote);\n    }\n}\nfunction outputImportant(node, out, separator) {\n    if (node.important) {\n        if (separator) {\n            push(out, ' ');\n        }\n        push(out, '!important');\n    }\n}\nfunction outputValue(value, out, config) {\n    for (let i = 0, prevEnd = -1; i < value.value.length; i++) {\n        const token = value.value[i];\n        // Handle edge case: a field is written close to previous token like this: `foo${bar}`.\n        // We should not add delimiter here\n        if (i !== 0 && (token.type !== 'Field' || token.start !== prevEnd)) {\n            push(out, ' ');\n        }\n        outputToken(token, out, config);\n        prevEnd = token['end'];\n    }\n}\nfunction outputToken(token, out, config) {\n    if (token.type === 'ColorValue') {\n        push(out, color(token, config.options['stylesheet.shortHex']));\n    }\n    else if (token.type === 'Literal') {\n        pushString(out, token.value);\n    }\n    else if (token.type === 'NumberValue') {\n        pushString(out, frac(token.value, 4) + token.unit);\n    }\n    else if (token.type === 'StringValue') {\n        const quote = token.quote === 'double' ? '\"' : '\\'';\n        pushString(out, quote + token.value + quote);\n    }\n    else if (token.type === 'Field') {\n        pushField(out, token.index, token.name);\n    }\n    else if (token.type === 'FunctionCall') {\n        push(out, token.name + '(');\n        for (let i = 0; i < token.arguments.length; i++) {\n            if (i) {\n                push(out, ', ');\n            }\n            outputValue(token.arguments[i], out, config);\n        }\n        push(out, ')');\n    }\n}\n/**\n * If value of given property is a single numeric value, returns this token\n */\nfunction getSingleNumeric(node) {\n    if (node.value.length === 1) {\n        const cssVal = node.value[0];\n        if (cssVal.value.length === 1 && cssVal.value[0].type === 'NumberValue') {\n            return cssVal.value[0];\n        }\n    }\n}\n/**\n * Converts kebab-case string to camelCase\n */\nfunction toCamelCase(str) {\n    return str.replace(/\\-(\\w)/g, (_, letter) => letter.toUpperCase());\n}\nfunction getQuote(config) {\n    return config.options['stylesheet.jsonDoubleQuotes'] ? '\"' : '\\'';\n}\n\nconst gradientName = 'lg';\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse$1(abbr, config) {\n    var _a;\n    const snippets = ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.stylesheetSnippets) || convertSnippets(config.snippets);\n    if (config.cache) {\n        config.cache.stylesheetSnippets = snippets;\n    }\n    if (typeof abbr === 'string') {\n        abbr = parse$3(abbr, { value: isValueScope(config) });\n    }\n    const filteredSnippets = getSnippetsForScope(snippets, config);\n    for (const node of abbr) {\n        resolveNode(node, filteredSnippets, config);\n    }\n    return abbr;\n}\n/**\n * Converts given raw snippets into internal snippets representation\n */\nfunction convertSnippets(snippets) {\n    const result = [];\n    for (const key of Object.keys(snippets)) {\n        result.push(createSnippet(key, snippets[key]));\n    }\n    return nest(result);\n}\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n */\nfunction resolveNode(node, snippets, config) {\n    if (!resolveGradient(node, config)) {\n        const score = config.options['stylesheet.fuzzySearchMinScore'];\n        if (isValueScope(config)) {\n            // Resolve as value of given CSS property\n            const propName = config.context.name;\n            const snippet = snippets.find(s => s.type === \"Property\" /* Property */ && s.property === propName);\n            resolveValueKeywords(node, config, snippet, score);\n            node.snippet = snippet;\n        }\n        else if (node.name) {\n            const snippet = findBestMatch(node.name, snippets, score, true);\n            node.snippet = snippet;\n            if (snippet) {\n                if (snippet.type === \"Property\" /* Property */) {\n                    resolveAsProperty(node, snippet, config);\n                }\n                else {\n                    resolveAsSnippet(node, snippet);\n                }\n            }\n        }\n    }\n    if (node.name || config.context) {\n        // Resolve numeric values for CSS properties only\n        resolveNumericValue(node, config);\n    }\n    return node;\n}\n/**\n * Resolves CSS gradient shortcut from given property, if possible\n */\nfunction resolveGradient(node, config) {\n    let gradientFn = null;\n    const cssVal = node.value.length === 1 ? node.value[0] : null;\n    if (cssVal && cssVal.value.length === 1) {\n        const v = cssVal.value[0];\n        if (v.type === 'FunctionCall' && v.name === gradientName) {\n            gradientFn = v;\n        }\n    }\n    if (gradientFn || node.name === gradientName) {\n        if (!gradientFn) {\n            gradientFn = {\n                type: 'FunctionCall',\n                name: 'linear-gradient',\n                arguments: [cssValue(field(0, ''))]\n            };\n        }\n        else {\n            gradientFn = Object.assign(Object.assign({}, gradientFn), { name: 'linear-gradient' });\n        }\n        if (!config.context) {\n            node.name = 'background-image';\n        }\n        node.value = [cssValue(gradientFn)];\n        return true;\n    }\n    return false;\n}\n/**\n * Resolves given parsed abbreviation node as CSS property\n */\nfunction resolveAsProperty(node, snippet, config) {\n    const abbr = node.name;\n    // Check for unmatched part of abbreviation\n    // For example, in `dib` abbreviation the matched part is `d` and `ib` should\n    // be considered as inline value. If unmatched fragment exists, we should check\n    // if it matches actual value of snippet. If either explicit value is specified\n    // or unmatched fragment did not resolve to to a keyword, we should consider\n    // matched snippet as invalid\n    const inlineValue = getUnmatchedPart(abbr, snippet.key);\n    if (inlineValue) {\n        if (node.value.length) {\n            // Already have value: unmatched part indicates matched snippet is invalid\n            return node;\n        }\n        const kw = resolveKeyword(inlineValue, config, snippet);\n        if (!kw) {\n            return node;\n        }\n        node.value.push(cssValue(kw));\n    }\n    node.name = snippet.property;\n    if (node.value.length) {\n        // Replace keyword alias from current abbreviation node with matched keyword\n        resolveValueKeywords(node, config, snippet);\n    }\n    else if (snippet.value.length) {\n        const defaultValue = snippet.value[0];\n        // https://github.com/emmetio/emmet/issues/558\n        // We should auto-select inserted value only if there’s multiple value\n        // choice\n        node.value = snippet.value.length === 1 || defaultValue.some(hasField)\n            ? defaultValue\n            : defaultValue.map(n => wrapWithField(n, config));\n    }\n    return node;\n}\nfunction resolveValueKeywords(node, config, snippet, minScore) {\n    for (const cssVal of node.value) {\n        const value = [];\n        for (const token of cssVal.value) {\n            if (token.type === 'Literal') {\n                value.push(resolveKeyword(token.value, config, snippet, minScore) || token);\n            }\n            else if (token.type === 'FunctionCall') {\n                // For function calls, we should find matching function call\n                // and merge arguments\n                const match = resolveKeyword(token.name, config, snippet, minScore);\n                if (match && match.type === 'FunctionCall') {\n                    value.push(Object.assign(Object.assign({}, match), { arguments: token.arguments.concat(match.arguments.slice(token.arguments.length)) }));\n                }\n                else {\n                    value.push(token);\n                }\n            }\n            else {\n                value.push(token);\n            }\n        }\n        cssVal.value = value;\n    }\n}\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n */\nfunction resolveAsSnippet(node, snippet) {\n    // When resolving snippets, we have to do the following:\n    // 1. Replace field placeholders with actual field tokens.\n    // 2. If input values given, put them instead of fields\n    let offset = 0;\n    let m;\n    const reField = /\\$\\{(\\d+)(:[^}]+)?\\}/g;\n    const inputValue = node.value[0];\n    const outputValue = [];\n    while (m = reField.exec(snippet.value)) {\n        if (offset !== m.index) {\n            outputValue.push(literal(snippet.value.slice(offset, m.index)));\n        }\n        offset = m.index + m[0].length;\n        if (inputValue && inputValue.value.length) {\n            outputValue.push(inputValue.value.shift());\n        }\n        else {\n            outputValue.push(field(Number(m[1]), m[2] ? m[2].slice(1) : ''));\n        }\n    }\n    const tail = snippet.value.slice(offset);\n    if (tail) {\n        outputValue.push(literal(tail));\n    }\n    node.name = void 0;\n    node.value = [cssValue(...outputValue)];\n    return node;\n}\n/**\n * Finds best matching item from `items` array\n * @param abbr  Abbreviation to match\n * @param items List of items for match\n * @param minScore The minimum score the best matched item should have to be a valid match.\n */\nfunction findBestMatch(abbr, items, minScore = 0, partialMatch = false) {\n    let matchedItem = null;\n    let maxScore = 0;\n    for (const item of items) {\n        const score = scoreMatch(abbr, getScoringPart(item), partialMatch);\n        if (score === 1) {\n            // direct hit, no need to look further\n            return item;\n        }\n        if (score && score >= maxScore) {\n            maxScore = score;\n            matchedItem = item;\n        }\n    }\n    return maxScore >= minScore ? matchedItem : null;\n}\nfunction getScoringPart(item) {\n    return typeof item === 'string' ? item : item.key;\n}\n/**\n * Returns a part of `abbr` that wasn’t directly matched against `str`.\n * For example, if abbreviation `poas` is matched against `position`,\n * the unmatched part will be `as` since `a` wasn’t found in string stream\n */\nfunction getUnmatchedPart(abbr, str) {\n    for (let i = 0, lastPos = 0; i < abbr.length; i++) {\n        lastPos = str.indexOf(abbr[i], lastPos);\n        if (lastPos === -1) {\n            return abbr.slice(i);\n        }\n        lastPos++;\n    }\n    return '';\n}\n/**\n * Resolves given keyword shorthand into matched snippet keyword or global keyword,\n * if possible\n */\nfunction resolveKeyword(kw, config, snippet, minScore) {\n    let ref;\n    if (snippet) {\n        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {\n            return snippet.keywords[ref];\n        }\n        for (const dep of snippet.dependencies) {\n            if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {\n                return dep.keywords[ref];\n            }\n        }\n    }\n    if (ref = findBestMatch(kw, config.options['stylesheet.keywords'], minScore)) {\n        return literal(ref);\n    }\n    return null;\n}\n/**\n * Resolves numeric values in given abbreviation node\n */\nfunction resolveNumericValue(node, config) {\n    const aliases = config.options['stylesheet.unitAliases'];\n    const unitless = config.options['stylesheet.unitless'];\n    for (const v of node.value) {\n        for (const t of v.value) {\n            if (t.type === 'NumberValue') {\n                if (t.unit) {\n                    t.unit = aliases[t.unit] || t.unit;\n                }\n                else if (t.value !== 0 && !unitless.includes(node.name)) {\n                    t.unit = t.rawValue.includes('.')\n                        ? config.options['stylesheet.floatUnit']\n                        : config.options['stylesheet.intUnit'];\n                }\n            }\n        }\n    }\n}\n/**\n * Constructs CSS value token\n */\nfunction cssValue(...args) {\n    return {\n        type: 'CSSValue',\n        value: args\n    };\n}\n/**\n * Constructs literal token\n */\nfunction literal(value) {\n    return { type: 'Literal', value };\n}\n/**\n * Constructs field token\n */\nfunction field(index, name) {\n    return { type: 'Field', index, name };\n}\n/**\n * Check if given value contains fields\n */\nfunction hasField(value) {\n    for (const v of value.value) {\n        if (v.type === 'Field' || (v.type === 'FunctionCall' && v.arguments.some(hasField))) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Wraps tokens of given abbreviation with fields\n */\nfunction wrapWithField(node, config, state = { index: 1 }) {\n    let value = [];\n    for (const v of node.value) {\n        switch (v.type) {\n            case 'ColorValue':\n                value.push(field(state.index++, color(v, config.options['stylesheet.shortHex'])));\n                break;\n            case 'Literal':\n                value.push(field(state.index++, v.value));\n                break;\n            case 'NumberValue':\n                value.push(field(state.index++, `${v.value}${v.unit}`));\n                break;\n            case 'StringValue':\n                const q = v.quote === 'single' ? '\\'' : '\"';\n                value.push(field(state.index++, q + v.value + q));\n                break;\n            case 'FunctionCall':\n                value.push(field(state.index++, v.name), literal('('));\n                for (let i = 0, il = v.arguments.length; i < il; i++) {\n                    value = value.concat(wrapWithField(v.arguments[i], config, state).value);\n                    if (i !== il - 1) {\n                        value.push(literal(', '));\n                    }\n                }\n                value.push(literal(')'));\n                break;\n            default:\n                value.push(v);\n        }\n    }\n    return Object.assign(Object.assign({}, node), { value });\n}\n/**\n * Check if abbreviation should be expanded in CSS value context\n */\nfunction isValueScope(config) {\n    if (config.context) {\n        return config.context.name === \"@@value\" /* Value */ || !config.context.name.startsWith('@@');\n    }\n    return false;\n}\n/**\n * Returns snippets for given scope\n */\nfunction getSnippetsForScope(snippets, config) {\n    if (config.context) {\n        if (config.context.name === \"@@section\" /* Section */) {\n            return snippets.filter(s => s.type === \"Raw\" /* Raw */);\n        }\n        if (config.context.name === \"@@property\" /* Property */) {\n            return snippets.filter(s => s.type === \"Property\" /* Property */);\n        }\n    }\n    return snippets;\n}\n\nvar markupSnippets = {\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:btn|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"sum\": \"summary\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta[http-equiv='X-UA-Compatible'][content='IE=edge']+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar stylesheetSnippets = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${2});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n\t\"cr\": \"color:rgb(${1:0}, ${2:0}, ${3:0})\",\n\t\"cra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, ${4:.5})\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|grid|inline-grid|subgrid|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"gtc\": \"grid-template-columns:repeat()|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat()|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op|opa\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xslSnippets = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar pugSnippets = {\n\t\"!!!\": \"{doctype html}\"\n};\n\nvar variables = {\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n};\n\n/**\n * Default syntaxes for abbreviation types\n */\nconst defaultSyntaxes = {\n    markup: 'html',\n    stylesheet: 'css'\n};\nconst defaultOptions = {\n    'inlineElements': [\n        'a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n        'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n        'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n        's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n        'textarea', 'tt', 'u', 'var'\n    ],\n    'output.indent': '\\t',\n    'output.baseIndent': '',\n    'output.newline': '\\n',\n    'output.tagCase': '',\n    'output.attributeCase': '',\n    'output.attributeQuotes': 'double',\n    'output.format': true,\n    'output.formatLeafNode': false,\n    'output.formatSkip': ['html'],\n    'output.formatForce': ['body'],\n    'output.inlineBreak': 3,\n    'output.compactBoolean': false,\n    'output.booleanAttributes': [\n        'contenteditable', 'seamless', 'async', 'autofocus',\n        'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n        'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n        'required', 'reversed', 'selected', 'typemustmatch'\n    ],\n    'output.reverseAttributes': false,\n    'output.selfClosingStyle': 'html',\n    'output.field': (index, placeholder) => placeholder,\n    'output.text': text => text,\n    'markup.href': true,\n    'comment.enabled': false,\n    'comment.trigger': ['id', 'class'],\n    'comment.before': '',\n    'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n    'bem.enabled': false,\n    'bem.element': '__',\n    'bem.modifier': '_',\n    'jsx.enabled': false,\n    'stylesheet.keywords': ['auto', 'inherit', 'unset', 'none'],\n    'stylesheet.unitless': ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'],\n    'stylesheet.shortHex': true,\n    'stylesheet.between': ': ',\n    'stylesheet.after': ';',\n    'stylesheet.intUnit': 'px',\n    'stylesheet.floatUnit': 'em',\n    'stylesheet.unitAliases': { e: 'em', p: '%', x: 'ex', r: 'rem' },\n    'stylesheet.json': false,\n    'stylesheet.jsonDoubleQuotes': false,\n    'stylesheet.fuzzySearchMinScore': 0\n};\nconst defaultConfig = {\n    type: 'markup',\n    syntax: 'html',\n    variables,\n    snippets: {},\n    options: defaultOptions\n};\n/**\n * Default per-syntax config\n */\nconst syntaxConfig = {\n    markup: {\n        snippets: parseSnippets(markupSnippets),\n    },\n    xhtml: {\n        options: {\n            'output.selfClosingStyle': 'xhtml'\n        }\n    },\n    xml: {\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    xsl: {\n        snippets: parseSnippets(xslSnippets),\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    jsx: {\n        options: {\n            'jsx.enabled': true\n        }\n    },\n    pug: {\n        snippets: parseSnippets(pugSnippets)\n    },\n    stylesheet: {\n        snippets: parseSnippets(stylesheetSnippets)\n    },\n    sass: {\n        options: {\n            'stylesheet.after': ''\n        }\n    },\n    stylus: {\n        options: {\n            'stylesheet.between': ' ',\n            'stylesheet.after': '',\n        }\n    }\n};\n/**\n * Parses raw snippets definitions with possibly multiple keys into a plan\n * snippet map\n */\nfunction parseSnippets(snippets) {\n    const result = {};\n    Object.keys(snippets).forEach(k => {\n        for (const name of k.split('|')) {\n            result[name] = snippets[k];\n        }\n    });\n    return result;\n}\nfunction resolveConfig(config = {}, globals = {}) {\n    const type = config.type || 'markup';\n    const syntax = config.syntax || defaultSyntaxes[type];\n    return Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { type,\n        syntax, variables: mergedData(type, syntax, 'variables', config, globals), snippets: mergedData(type, syntax, 'snippets', config, globals), options: mergedData(type, syntax, 'options', config, globals) });\n}\nfunction mergedData(type, syntax, key, config, globals = {}) {\n    const typeDefaults = syntaxConfig[type];\n    const typeOverride = globals[type];\n    const syntaxDefaults = syntaxConfig[syntax];\n    const syntaxOverride = globals[syntax];\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfig[key]), (typeDefaults && typeDefaults[key])), (syntaxDefaults && syntaxDefaults[key])), (typeOverride && typeOverride[key])), (syntaxOverride && syntaxOverride[key])), config[key]);\n}\n\n/**\n * Creates structure for scanning given string in backward direction\n */\nfunction backwardScanner(text, start = 0) {\n    return { text, start, pos: text.length };\n}\n/**\n * Check if given scanner position is at start of scanned text\n */\nfunction sol(scanner) {\n    return scanner.pos === scanner.start;\n}\n/**\n * “Peeks” character code an current scanner location without advancing it\n */\nfunction peek$1(scanner, offset = 0) {\n    return scanner.text.charCodeAt(scanner.pos - 1 + offset);\n}\n/**\n * Returns current character code and moves character location one symbol back\n */\nfunction previous(scanner) {\n    if (!sol(scanner)) {\n        return scanner.text.charCodeAt(--scanner.pos);\n    }\n}\n/**\n * Consumes current character code if it matches given `match` code or function\n */\nfunction consume(scanner, match) {\n    if (sol(scanner)) {\n        return false;\n    }\n    const ok = typeof match === 'function'\n        ? match(peek$1(scanner))\n        : match === peek$1(scanner);\n    if (ok) {\n        scanner.pos--;\n    }\n    return !!ok;\n}\nfunction consumeWhile(scanner, match) {\n    const start = scanner.pos;\n    while (consume(scanner, match)) {\n        // empty\n    }\n    return scanner.pos < start;\n}\n\n/**\n * Check if given character code is a quote\n */\nfunction isQuote(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\n/**\n * Consumes quoted value, if possible\n * @return Returns `true` is value was consumed\n */\nfunction consumeQuoted(scanner) {\n    const start = scanner.pos;\n    const quote = previous(scanner);\n    if (isQuote(quote)) {\n        while (!sol(scanner)) {\n            if (previous(scanner) === quote && peek$1(scanner) !== 92 /* Escape */) {\n                return true;\n            }\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n\nconst bracePairs = {\n    [91 /* SquareL */]: 93 /* SquareR */,\n    [40 /* RoundL */]: 41 /* RoundR */,\n    [123 /* CurlyL */]: 125 /* CurlyR */,\n};\n\n/**\n * Check if given reader’s current position points at the end of HTML tag\n */\nfunction isHtml(scanner) {\n    const start = scanner.pos;\n    if (!consume(scanner, 62 /* AngleRight */)) {\n        return false;\n    }\n    let ok = false;\n    consume(scanner, 47 /* Slash */); // possibly self-closed element\n    while (!sol(scanner)) {\n        consumeWhile(scanner, isWhiteSpace);\n        if (consumeIdent(scanner)) {\n            // ate identifier: could be a tag name, boolean attribute or unquoted\n            // attribute value\n            if (consume(scanner, 47 /* Slash */)) {\n                // either closing tag or invalid tag\n                ok = consume(scanner, 60 /* AngleLeft */);\n                break;\n            }\n            else if (consume(scanner, 60 /* AngleLeft */)) {\n                // opening tag\n                ok = true;\n                break;\n            }\n            else if (consume(scanner, isWhiteSpace)) {\n                // boolean attribute\n                continue;\n            }\n            else if (consume(scanner, 61 /* Equals */)) {\n                // simple unquoted value or invalid attribute\n                if (consumeIdent(scanner)) {\n                    continue;\n                }\n                break;\n            }\n            else if (consumeAttributeWithUnquotedValue(scanner)) {\n                // identifier was a part of unquoted value\n                ok = true;\n                break;\n            }\n            // invalid tag\n            break;\n        }\n        if (consumeAttribute(scanner)) {\n            continue;\n        }\n        break;\n    }\n    scanner.pos = start;\n    return ok;\n}\n/**\n * Consumes HTML attribute from given string.\n * @return `true` if attribute was consumed.\n */\nfunction consumeAttribute(scanner) {\n    return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);\n}\nfunction consumeAttributeWithQuotedValue(scanner) {\n    const start = scanner.pos;\n    if (consumeQuoted(scanner) && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\nfunction consumeAttributeWithUnquotedValue(scanner) {\n    const start = scanner.pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        const ch = peek$1(scanner);\n        if (isCloseBracket(ch)) {\n            stack.push(ch);\n        }\n        else if (isOpenBracket(ch)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // Unexpected open bracket\n                break;\n            }\n        }\n        else if (!isUnquotedValue(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (start !== scanner.pos && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes HTML identifier from stream\n */\nfunction consumeIdent(scanner) {\n    return consumeWhile(scanner, isIdent);\n}\n/**\n * Check if given character code belongs to HTML identifier\n */\nfunction isIdent(ch) {\n    return ch === 58 /* Colon */ || ch === 45 /* Dash */ || isAlpha(ch) || isNumber(ch);\n}\n/**\n * Check if given character code is alpha code (letter though A to Z)\n */\nfunction isAlpha(ch) {\n    ch &= ~32; // quick hack to convert any char code to uppercase char code\n    return ch >= 65 && ch <= 90; // A-Z\n}\n/**\n * Check if given code is a number\n */\nfunction isNumber(ch) {\n    return ch > 47 && ch < 58;\n}\n/**\n * Check if given code is a whitespace\n */\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* Space */ || ch === 9 /* Tab */;\n}\n/**\n * Check if given code may belong to unquoted attribute value\n */\nfunction isUnquotedValue(ch) {\n    return !isNaN(ch) && ch !== 61 /* Equals */ && !isWhiteSpace(ch) && !isQuote(ch);\n}\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyL */ || ch === 40 /* RoundL */ || ch === 91 /* SquareL */;\n}\nfunction isCloseBracket(ch) {\n    return ch === 125 /* CurlyR */ || ch === 41 /* RoundR */ || ch === 93 /* SquareR */;\n}\n\nconst code = (ch) => ch.charCodeAt(0);\nconst specialChars = '#.*:$-_!@%^+>/'.split('').map(code);\nconst defaultOptions$1 = {\n    type: 'markup',\n    lookAhead: true,\n    prefix: ''\n};\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editor’s line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param line A text line where abbreviation should be expanded\n * @param pos Caret position in line. If not given, uses end of line\n * @param options Extracting options\n */\nfunction extractAbbreviation(line, pos = line.length, options = {}) {\n    // make sure `pos` is within line range\n    const opt = Object.assign(Object.assign({}, defaultOptions$1), options);\n    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n    if (opt.lookAhead) {\n        pos = offsetPastAutoClosed(line, pos, opt);\n    }\n    let ch;\n    const start = getStartOffset(line, pos, opt.prefix || '');\n    if (start === -1) {\n        return void 0;\n    }\n    const scanner = backwardScanner(line, start);\n    scanner.pos = pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        ch = peek$1(scanner);\n        if (stack.includes(125 /* CurlyR */)) {\n            if (ch === 125 /* CurlyR */) {\n                stack.push(ch);\n                scanner.pos--;\n                continue;\n            }\n            if (ch !== 123 /* CurlyL */) {\n                scanner.pos--;\n                continue;\n            }\n        }\n        if (isCloseBrace(ch, opt.type)) {\n            stack.push(ch);\n        }\n        else if (isOpenBrace(ch, opt.type)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // unexpected brace\n                break;\n            }\n        }\n        else if (stack.includes(93 /* SquareR */) || stack.includes(125 /* CurlyR */)) {\n            // respect all characters inside attribute sets or text nodes\n            scanner.pos--;\n            continue;\n        }\n        else if (isHtml(scanner) || !isAbbreviation(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (!stack.length && scanner.pos !== pos) {\n        // Found something, remove some invalid symbols from the\n        // beginning and return abbreviation\n        const abbreviation = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, '');\n        return {\n            abbreviation,\n            location: pos - abbreviation.length,\n            start: options.prefix\n                ? start - options.prefix.length\n                : pos - abbreviation.length,\n            end: pos\n        };\n    }\n}\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n */\nfunction offsetPastAutoClosed(line, pos, options) {\n    // closing quote is allowed only as a next character\n    if (isQuote(line.charCodeAt(pos))) {\n        pos++;\n    }\n    // offset pointer until non-autoclosed character is found\n    while (isCloseBrace(line.charCodeAt(pos), options.type)) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: it’s nearest to `pos` location of `prefix` token\n */\nfunction getStartOffset(line, pos, prefix) {\n    if (!prefix) {\n        return 0;\n    }\n    const scanner = backwardScanner(line);\n    const compiledPrefix = prefix.split('').map(code);\n    scanner.pos = pos;\n    let result;\n    while (!sol(scanner)) {\n        if (consumePair(scanner, 93 /* SquareR */, 91 /* SquareL */) || consumePair(scanner, 125 /* CurlyR */, 123 /* CurlyL */)) {\n            continue;\n        }\n        result = scanner.pos;\n        if (consumeArray(scanner, compiledPrefix)) {\n            return result;\n        }\n        scanner.pos--;\n    }\n    return -1;\n}\n/**\n * Consumes full character pair, if possible\n */\nfunction consumePair(scanner, close, open) {\n    const start = scanner.pos;\n    if (consume(scanner, close)) {\n        while (!sol(scanner)) {\n            if (consume(scanner, open)) {\n                return true;\n            }\n            scanner.pos--;\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n */\nfunction consumeArray(scanner, arr) {\n    const start = scanner.pos;\n    let consumed = false;\n    for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {\n        if (!consume(scanner, arr[i])) {\n            break;\n        }\n        consumed = i === 0;\n    }\n    if (!consumed) {\n        scanner.pos = start;\n    }\n    return consumed;\n}\nfunction isAbbreviation(ch) {\n    return (ch > 64 && ch < 91) // uppercase letter\n        || (ch > 96 && ch < 123) // lowercase letter\n        || (ch > 47 && ch < 58) // number\n        || specialChars.includes(ch); // special character\n}\nfunction isOpenBrace(ch, syntax) {\n    return ch === 40 /* RoundL */ || (syntax === 'markup' && (ch === 91 /* SquareL */ || ch === 123 /* CurlyL */));\n}\nfunction isCloseBrace(ch, syntax) {\n    return ch === 41 /* RoundR */ || (syntax === 'markup' && (ch === 93 /* SquareR */ || ch === 125 /* CurlyR */));\n}\n\nfunction expandAbbreviation(abbr, config) {\n    const resolvedConfig = resolveConfig(config);\n    return resolvedConfig.type === 'stylesheet'\n        ? stylesheet(abbr, resolvedConfig)\n        : markup(abbr, resolvedConfig);\n}\n/**\n * Expands given *markup* abbreviation (e.g. regular Emmet abbreviation that\n * produces structured output like HTML) and outputs it according to options\n * provided in config\n */\nfunction markup(abbr, config) {\n    return stringify(parse(abbr, config), config);\n}\n/**\n * Expands given *stylesheet* abbreviation (a special Emmet abbreviation designed for\n * stylesheet languages like CSS, SASS etc.) and outputs it according to options\n * provided in config\n */\nfunction stylesheet(abbr, config) {\n    return css(parse$1(abbr, config), config);\n}\n\nexport default expandAbbreviation;\nexport { extractAbbreviation as extract, markup, parse as parseMarkup, parse$1 as parseStylesheet, convertSnippets as parseStylesheetSnippets, resolveConfig, stringify as stringifyMarkup, css as stringifyStylesheet, stylesheet };\n//# sourceMappingURL=emmet.es.js.map\n","import { scan, attributes, createOptions } from '@emmetio/html-matcher';\nimport { scan as scan$1, splitValue } from '@emmetio/css-matcher';\nimport expand, { stylesheetAbbreviation, markupAbbreviation } from 'emmet';\n\nconst pairs = {\n    '{': '}',\n    '[': ']',\n    '(': ')'\n};\nconst pairsEnd = [];\nfor (const key of Object.keys(pairs)) {\n    pairsEnd.push(pairs[key]);\n}\n/**\n * Returns `true` if given character code is a space\n */\nfunction isSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160 /* non-breaking space */\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\nfunction pushRange(ranges, range) {\n    const prev = ranges[ranges.length - 1];\n    if (range && range[0] !== range[1] && (!prev || prev[0] !== range[0] || prev[1] !== range[1])) {\n        ranges.push(range);\n    }\n}\n/**\n * Returns ranges of tokens in given value. Tokens are space-separated words.\n */\nfunction tokenList(value, offset = 0) {\n    const ranges = [];\n    const len = value.length;\n    let pos = 0;\n    let start = 0;\n    let end = 0;\n    while (pos < len) {\n        end = pos;\n        const ch = value.charCodeAt(pos++);\n        if (isSpace(ch)) {\n            if (start !== end) {\n                ranges.push([offset + start, offset + end]);\n            }\n            while (isSpace(value.charCodeAt(pos))) {\n                pos++;\n            }\n            start = pos;\n        }\n    }\n    if (start !== pos) {\n        ranges.push([offset + start, offset + pos]);\n    }\n    return ranges;\n}\n/**\n * Check if given character is a quote\n */\nfunction isQuote(ch) {\n    return ch === '\"' || ch === '\\'';\n}\n/**\n * Returns value of given attribute, parsed by Emmet HTML matcher\n */\nfunction attributeValue(attr) {\n    const { value } = attr;\n    return value && isQuoted(value)\n        ? value.slice(1, -1)\n        : value;\n}\nfunction attributeValueRange(tag, attr, offset = 0) {\n    let valueStart = attr.valueStart;\n    let valueEnd = attr.valueEnd;\n    if (isQuote(tag[valueStart])) {\n        valueStart++;\n    }\n    if (isQuote(tag[valueEnd - 1]) && valueEnd > valueStart) {\n        valueEnd--;\n    }\n    return [offset + valueStart, offset + valueEnd];\n}\n/**\n * Check if given value is either quoted or written as expression\n */\nfunction isQuoted(value) {\n    return !!value && (isQuotedString(value) || isExprString(value));\n}\n/**\n * Check if given string is quoted with single or double quotes\n */\nfunction isQuotedString(str) {\n    return str.length > 1 && isQuote(str[0]) && str[0] === str.slice(-1);\n}\n/**\n * Check if given string contains expression, e.g. wrapped with `{` and `}`\n */\nfunction isExprString(str) {\n    return str[0] === '{' && str.slice(-1) === '}';\n}\n/**\n * Returns last element of given array\n */\nfunction last(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n\n/**\n * Check if there’s open or self-closing tag under given `pos` location in source code.\n * If found, returns its name, range in source and parsed attributes\n */\nfunction getOpenTag(code, pos) {\n    let tag = void 0;\n    // Find open or self-closing tag, closest to given position\n    scan(code, (name, type, start, end) => {\n        if (start < pos && end > pos) {\n            tag = { name, type, start, end };\n            if (type === 1 /* Open */ || type === 3 /* SelfClose */) {\n                tag.attributes = shiftAttributeRanges(attributes(code.slice(start, end), name), start);\n            }\n            return false;\n        }\n        if (end > pos) {\n            return false;\n        }\n    });\n    return tag;\n}\n/**\n * Returns list of matched tags in given source code\n */\nfunction getTagMatches(code, options) {\n    const opt = createOptions(options);\n    const stack = [];\n    const result = [];\n    scan(code, (name, type, start, end) => {\n        if (type === 3 /* SelfClose */) {\n            result.push({ name, open: [start, end] });\n        }\n        else if (type === 1 /* Open */) {\n            const item = { name, open: [start, end] };\n            stack.push(item);\n            result.push(item);\n        }\n        else {\n            // Handle closing tag\n            while (stack.length) {\n                const item = stack.pop();\n                if (item.name === name) {\n                    item.close = [start, end];\n                    break;\n                }\n            }\n        }\n    }, opt);\n    return result;\n}\n/**\n * Finds tag match for given position\n */\nfunction findTagMatch(source, pos, options) {\n    if (typeof source === 'string') {\n        source = getTagMatches(source, options);\n    }\n    let candidate;\n    source.some(match => {\n        const start = match.open[0];\n        const end = match.close ? match.close[1] : match.open[1];\n        if (pos < start) {\n            // All the following tags will be after given position, stop searching\n            return true;\n        }\n        if (pos > start && pos < end) {\n            candidate = match;\n        }\n    });\n    return candidate;\n}\n/**\n * Returns list of ranges for Select Next/Previous Item action\n */\nfunction selectItemHTML(code, pos, isPrev) {\n    return isPrev ? selectPreviousItem(code, pos) : selectNextItem(code, pos);\n}\n/**\n * Returns list of ranges for Select Next Item action\n */\nfunction selectNextItem(code, pos) {\n    let result = void 0;\n    // Find open or self-closing tag, closest to given position\n    scan(code, (name, type, start, end) => {\n        if ((type === 1 /* Open */ || type === 3 /* SelfClose */) && end > pos) {\n            // Found open or self-closing tag\n            result = getTagSelectionModel(code, name, start, end);\n            return false;\n        }\n    });\n    return result;\n}\n/**\n * Returns list of ranges for Select Previous Item action\n */\nfunction selectPreviousItem(code, pos) {\n    let lastType = null;\n    let lastName = '';\n    let lastStart = -1;\n    let lastEnd = -1;\n    // We should find the closest open or self-closing tag left to given `pos`.\n    scan(code, (name, type, start, end) => {\n        if (start >= pos) {\n            return false;\n        }\n        if (type === 1 /* Open */ || type === 3 /* SelfClose */) {\n            // Found open or self-closing tag\n            lastName = name;\n            lastType = type;\n            lastStart = start;\n            lastEnd = end;\n        }\n    });\n    if (lastType !== null) {\n        return getTagSelectionModel(code, lastName, lastStart, lastEnd);\n    }\n}\n/**\n * Parses open or self-closing tag in `start:end` range of `code` and returns its\n * model for selecting items\n * @param code Document source code\n * @param name Name of matched tag\n */\nfunction getTagSelectionModel(code, name, start, end) {\n    const ranges = [\n        // Add tag name range\n        [start + 1, start + 1 + name.length]\n    ];\n    // Parse and add attributes ranges\n    const tagSrc = code.slice(start, end);\n    for (const attr of attributes(tagSrc, name)) {\n        if (attr.value != null) {\n            // Attribute with value\n            pushRange(ranges, [start + attr.nameStart, start + attr.valueEnd]);\n            // Add (unquoted) value range\n            const val = valueRange(attr);\n            if (val[0] !== val[1]) {\n                pushRange(ranges, [start + val[0], start + val[1]]);\n                if (attr.name === 'class') {\n                    // For class names, split value into space-separated tokens\n                    const tokens = tokenList(tagSrc.slice(val[0], val[1]), start + val[0]);\n                    for (const token of tokens) {\n                        pushRange(ranges, token);\n                    }\n                }\n            }\n        }\n        else {\n            // Attribute without value (boolean)\n            pushRange(ranges, [start + attr.nameStart, start + attr.nameEnd]);\n        }\n    }\n    return { start, end, ranges };\n}\n/**\n * Returns value range of given attribute. Value range is unquoted.\n */\nfunction valueRange(attr) {\n    const value = attr.value;\n    const ch = value[0];\n    const lastCh = value[value.length - 1];\n    if (ch === '\"' || ch === '\\'') {\n        return [\n            attr.valueStart + 1,\n            attr.valueEnd - (lastCh === ch ? 1 : 0)\n        ];\n    }\n    if (ch === '{' && lastCh === '}') {\n        return [\n            attr.valueStart + 1,\n            attr.valueEnd - 1\n        ];\n    }\n    return [attr.valueStart, attr.valueEnd];\n}\nfunction shiftAttributeRanges(attrs, offset) {\n    attrs.forEach(attr => {\n        attr.nameStart += offset;\n        attr.nameEnd += offset;\n        if ('value' in attr) {\n            attr.valueStart += offset;\n            attr.valueEnd += offset;\n        }\n    });\n    return attrs;\n}\n\n/**\n * Returns context CSS section for given location in source code\n * @param properties Parse inner properties\n */\nfunction getCSSSection(code, pos, properties) {\n    const stack = [];\n    const pool = [];\n    let result;\n    scan$1(code, (type, start, end, delimiter) => {\n        if (start > pos && !stack.length) {\n            return false;\n        }\n        if (type === \"selector\" /* Selector */) {\n            stack.push(allocRange(pool, start, end, delimiter));\n        }\n        else if (type === \"blockEnd\" /* BlockEnd */) {\n            const sel = stack.pop();\n            if (sel && sel[0] <= pos && pos <= end) {\n                result = {\n                    start: sel[0],\n                    end,\n                    bodyStart: sel[2] + 1,\n                    bodyEnd: start\n                };\n                return false;\n            }\n            releaseRange(pool, sel);\n        }\n    });\n    if (result && properties) {\n        result.properties = parseProperties(code, result.bodyStart, result.bodyEnd);\n    }\n    return result;\n}\n/**\n * Returns list of ranges for Select Next/Previous CSS Item  action\n */\nfunction selectItemCSS(code, pos, isPrev) {\n    return isPrev ? selectPreviousItem$1(code, pos) : selectNextItem$1(code, pos);\n}\n/**\n * Returns regions for selecting next item in CSS\n */\nfunction selectNextItem$1(code, pos) {\n    let result = void 0;\n    let pendingProperty = void 0;\n    scan$1(code, (type, start, end, delimiter) => {\n        if (start < pos) {\n            return;\n        }\n        if (type === \"selector\" /* Selector */) {\n            result = { start, end, ranges: [[start, end]] };\n            return false;\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            pendingProperty = [start, end, delimiter];\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            result = {\n                start,\n                end: delimiter !== -1 ? delimiter + 1 : end,\n                ranges: []\n            };\n            if (pendingProperty) {\n                // Full property range\n                result.start = pendingProperty[0];\n                pushRange(result.ranges, [pendingProperty[0], result.end]);\n            }\n            // Full value range\n            pushRange(result.ranges, [start, end]);\n            // Value fragments\n            for (const r of splitValue(code.substring(start, end))) {\n                pushRange(result.ranges, [r[0] + start, r[1] + start]);\n            }\n            return false;\n        }\n        else if (pendingProperty) {\n            result = {\n                start: pendingProperty[0],\n                end: pendingProperty[1],\n                ranges: [[pendingProperty[0], pendingProperty[1]]]\n            };\n            return false;\n        }\n    });\n    return result;\n}\n/**\n * Returns regions for selecting previous item in CSS\n */\nfunction selectPreviousItem$1(code, pos) {\n    const state = {\n        type: null,\n        start: -1,\n        end: -1,\n        valueStart: -1,\n        valueEnd: -1,\n        valueDelimiter: -1,\n    };\n    scan$1(code, (type, start, end, delimiter) => {\n        // Accumulate context until we reach given position\n        if (start >= pos && type !== \"propertyValue\" /* PropertyValue */) {\n            return false;\n        }\n        if (type === \"selector\" /* Selector */ || type === \"propertyName\" /* PropertyName */) {\n            state.start = start;\n            state.end = end;\n            state.type = type;\n            state.valueStart = state.valueEnd = state.valueDelimiter = -1;\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            state.valueStart = start;\n            state.valueEnd = end;\n            state.valueDelimiter = delimiter;\n        }\n    });\n    if (state.type === \"selector\" /* Selector */) {\n        return {\n            start: state.start,\n            end: state.end,\n            ranges: [[state.start, state.end]]\n        };\n    }\n    if (state.type === \"propertyName\" /* PropertyName */) {\n        const result = {\n            start: state.start,\n            end: state.end,\n            ranges: []\n        };\n        if (state.valueStart !== -1) {\n            result.end = state.valueDelimiter !== -1 ? state.valueDelimiter + 1 : state.valueEnd;\n            // Full property range\n            pushRange(result.ranges, [state.start, result.end]);\n            // Full value range\n            pushRange(result.ranges, [state.valueStart, state.valueEnd]);\n            // Value fragments\n            for (const r of splitValue(code.substring(state.valueStart, state.valueEnd))) {\n                pushRange(result.ranges, [r[0] + state.valueStart, r[1] + state.valueStart]);\n            }\n        }\n        else {\n            pushRange(result.ranges, [state.start, state.end]);\n        }\n        return result;\n    }\n}\n/**\n * Parses properties in `from:to` fragment of `code`. Note that `from:to` must\n * point to CSS section content, e.g. *inside* `{` and `}` (or top-level code context),\n * all properties found in nested sections will be ignored\n */\nfunction parseProperties(code, from = 0, to = code.length) {\n    const fragment = code.substring(from, to);\n    const result = [];\n    const pool = [];\n    let pendingName;\n    let nested = 0;\n    let before = from;\n    scan$1(fragment, (type, start, end, delimiter) => {\n        if (type === \"selector\" /* Selector */) {\n            nested++;\n        }\n        else if (type === \"blockEnd\" /* BlockEnd */) {\n            nested--;\n            before = from + end;\n        }\n        else if (!nested) {\n            if (type === \"propertyName\" /* PropertyName */) {\n                if (pendingName) {\n                    // Create property with empty value\n                    const valuePos = pendingName[2];\n                    result.push(createProperty(fragment, pendingName, before, valuePos, valuePos, valuePos, from));\n                    releaseRange(pool, pendingName);\n                    before = from + start;\n                }\n                pendingName = allocRange(pool, start, end, delimiter);\n            }\n            else if (type === \"propertyValue\" /* PropertyValue */) {\n                if (pendingName) {\n                    result.push(createProperty(fragment, pendingName, before, start, end, delimiter, from));\n                    releaseRange(pool, pendingName);\n                    pendingName = void 0;\n                }\n                before = from + delimiter + 1;\n            }\n        }\n    });\n    return result;\n}\nfunction createProperty(code, name, before, start, end, delimiter, offset = 0) {\n    return {\n        name: [offset + name[0], offset + name[1]],\n        value: [offset + start, offset + end],\n        valueTokens: splitValue(code.substring(start, end), offset + start),\n        before,\n        after: offset + delimiter + 1,\n    };\n}\n/**\n * Allocates new token range from pool\n */\nfunction allocRange(pool, start, end, delimiter) {\n    if (pool.length) {\n        const range = pool.pop();\n        range[0] = start;\n        range[1] = end;\n        range[2] = delimiter;\n        return range;\n    }\n    return [start, end, delimiter];\n}\n/**\n * Releases given token range and pushes it back into the pool\n */\nfunction releaseRange(pool, range) {\n    range && pool.push(range);\n    return null;\n}\n\n/**\n * Returns HTML context for given location in source code\n */\nfunction getHTMLContext(code, pos, opt = {}) {\n    const result = {\n        type: 'html',\n        ancestors: [],\n        current: null,\n        css: null\n    };\n    // Since we expect large input document, we’ll use pooling technique\n    // for storing tag data to reduce memory pressure and improve performance\n    const pool = [];\n    const stack = [];\n    const options = createOptions({ xml: opt.xml, allTokens: true });\n    scan(code, (name, type, start, end) => {\n        if (start >= pos) {\n            // Moved beyond location, stop parsing\n            return false;\n        }\n        if (start < pos && pos < end) {\n            // Direct hit on element\n            result.current = { name, type, range: [start, end] };\n            return false;\n        }\n        if (type === 1 /* Open */ && isSelfClose(name, options)) {\n            // Found empty element in HTML mode, mark is as self-closing\n            type = 3 /* SelfClose */;\n        }\n        if (type === 1 /* Open */) {\n            // Allocate tag object from pool\n            stack.push(allocItem(pool, name, type, start, end));\n        }\n        else if (type === 2 /* Close */ && stack.length && last(stack).name === name) {\n            // Release tag object for further re-use\n            releaseItem(pool, stack.pop());\n        }\n    }, options);\n    // Record stack elements as ancestors\n    stack.forEach(item => {\n        result.ancestors.push({\n            name: item.name,\n            range: [item.start, item.end]\n        });\n    });\n    if (!opt.skipCSS) {\n        // Detect if position is inside CSS context\n        result.css = detectCSSContextFromHTML(code, pos, result);\n    }\n    return result;\n}\n/**\n * Returns CSS context for given location in source code\n */\nfunction getCSSContext(code, pos, embedded) {\n    const result = {\n        type: 'css',\n        ancestors: [],\n        current: null,\n        inline: false,\n        embedded\n    };\n    const pool = [];\n    const stack = [];\n    scan$1(code, (type, start, end) => {\n        if (start >= pos) {\n            // Token behind specified location, stop parsing\n            return false;\n        }\n        if (start < pos && pos <= end) {\n            // Direct hit on token\n            result.current = {\n                name: code.slice(start, end),\n                type,\n                range: [start, end]\n            };\n            return false;\n        }\n        switch (type) {\n            case \"selector\" /* Selector */:\n            case \"propertyName\" /* PropertyName */:\n                stack.push(allocItem(pool, code.slice(start, end), type, start, end));\n                break;\n            case \"propertyValue\" /* PropertyValue */:\n            case \"blockEnd\" /* BlockEnd */:\n                releaseItem(pool, stack.pop());\n                break;\n        }\n    });\n    stack.forEach(item => {\n        result.ancestors.push({\n            name: item.name,\n            type: item.type,\n            range: [item.start, item.end]\n        });\n    });\n    return result;\n}\n/**\n * Returns embedded stylesheet syntax from given HTML context\n */\nfunction getEmbeddedStyleSyntax(code, ctx) {\n    const parent = last(ctx.ancestors);\n    if (parent && parent.name === 'style') {\n        for (const attr of attributes(code.slice(parent.range[0], parent.range[1]), parent.name)) {\n            if (attr.name === 'type') {\n                return attributeValue(attr);\n            }\n        }\n    }\n}\n/**\n * Returns context for Emmet abbreviation from given HTML context\n */\nfunction getMarkupAbbreviationContext(code, ctx) {\n    const parent = last(ctx.ancestors);\n    if (parent) {\n        const attrs = {};\n        for (const attr of attributes(code.slice(parent.range[0], parent.range[1]), parent.name)) {\n            attrs[attr.name] = attributeValue(attr) || '';\n        }\n        return {\n            name: parent.name,\n            attributes: attrs\n        };\n    }\n}\n/**\n * Returns context for Emmet abbreviation from given CSS context\n */\nfunction getStylesheetAbbreviationContext(ctx) {\n    if (ctx.inline) {\n        return { name: \"@@property\" /* Property */ };\n    }\n    const parent = last(ctx.ancestors);\n    let scope = \"@@global\" /* Global */;\n    if (ctx.current) {\n        if (ctx.current.type === \"propertyValue\" /* PropertyValue */ && parent) {\n            scope = parent.name;\n        }\n        else if ((ctx.current.type === \"selector\" /* Selector */ || ctx.current.type === \"propertyName\" /* PropertyName */) && !parent) {\n            scope = \"@@section\" /* Section */;\n        }\n    }\n    return {\n        name: scope\n    };\n}\n/**\n * Tries to detect CSS context from given HTML context and returns it\n */\nfunction detectCSSContextFromHTML(code, pos, ctx) {\n    let cssCtx = null;\n    if (ctx.current) {\n        // Maybe inline CSS?\n        const elem = ctx.current;\n        if (elem.type === 1 /* Open */ || elem.type === 2 /* Close */) {\n            const tag = code.slice(elem.range[0], elem.range[1]);\n            attributes(tag, elem.name).some(attr => {\n                if (attr.name === 'style' && attr.value != null) {\n                    const [valueStart, valueEnd] = attributeValueRange(tag, attr, elem.range[0]);\n                    if (pos >= valueStart && pos <= valueEnd) {\n                        cssCtx = getCSSContext(code.slice(valueStart, valueEnd), pos - valueStart, [valueStart, valueEnd]);\n                        applyOffset(cssCtx, valueStart);\n                        cssCtx.inline = true;\n                        return true;\n                    }\n                }\n            });\n        }\n    }\n    else if (ctx.ancestors.length) {\n        // Maybe inside `<style>` element?\n        const parent = last(ctx.ancestors);\n        if (parent.name === 'style') {\n            // Find closing </style> tag\n            const styleStart = parent.range[1];\n            let styleEnd = code.length;\n            scan(code.slice(parent.range[1]), (name, type, start) => {\n                if (name === parent.name && type === 2 /* Close */) {\n                    styleEnd = start + styleStart;\n                    return false;\n                }\n            });\n            cssCtx = getCSSContext(code.slice(styleStart, styleEnd), pos - styleStart, [styleStart, styleEnd]);\n            applyOffset(cssCtx, styleStart);\n        }\n    }\n    return cssCtx;\n}\n/**\n * Check if given tag is self-close for current parsing context\n */\nfunction isSelfClose(name, options) {\n    return !options.xml && options.empty.includes(name);\n}\nfunction allocItem(pool, name, type, start, end) {\n    if (pool.length) {\n        const tag = pool.pop();\n        tag.name = name;\n        tag.type = type;\n        tag.start = start;\n        tag.end = end;\n        return tag;\n    }\n    return { name, type, start, end };\n}\nfunction releaseItem(pool, item) {\n    if (item) {\n        pool.push(item);\n    }\n}\nfunction applyOffset(ctx, offset) {\n    ctx.ancestors.forEach(item => {\n        offsetRange(item.range, offset);\n    });\n    if (ctx.current) {\n        offsetRange(ctx.current.range, offset);\n    }\n}\nfunction offsetRange(range, offset) {\n    range[0] += offset;\n    range[1] += offset;\n}\n\nconst JSX_PREFIX = '<';\nconst reJSXAbbrStart = /^[a-zA-Z.#\\[\\(]$/;\nconst reWordBound = /^[\\s>;\"\\']?[a-zA-Z.#!@\\[\\(]$/;\nconst reStylesheetWordBound = /^[\\s;\"\\']?[a-zA-Z!@]$/;\n/**\n * Controller for tracking Emmet abbreviations in editor as user types.\n * Controller designed to be extended ad-hoc in editor plugins, overriding some\n * methods `mark()` to match editor behavior\n */\nclass AbbreviationTrackingController {\n    constructor() {\n        this.cache = new Map();\n        this.trackers = new Map();\n        this.lastPos = new Map();\n    }\n    /**\n     * Returns last known location of caret in given editor\n     */\n    getLastPost(editor) {\n        return this.lastPos.get(editor.id);\n    }\n    /**\n     * Sets last known caret location for given editor\n     */\n    setLastPos(editor, pos) {\n        this.lastPos.set(editor.id, pos);\n    }\n    /**\n     * Returns abbreviation tracker for given editor, if any\n     */\n    getTracker(editor) {\n        return this.trackers.get(editor.id);\n    }\n    /**\n     * Detects if user is typing abbreviation at given location\n     */\n    typingAbbreviation(editor, pos) {\n        var _a;\n        // Start tracking only if user starts abbreviation typing: entered first\n        // character at the word bound\n        // NB: get last 2 characters: first should be a word bound(or empty),\n        // second must be abbreviation start\n        const prefix = editor.substr(Math.max(0, pos - 2), pos);\n        const syntax = editor.syntax();\n        let start = -1;\n        let end = pos;\n        let offset = 0;\n        if (editor.isJSX(syntax)) {\n            // In JSX, abbreviations should be prefixed\n            if (prefix.length === 2 && prefix[0] === JSX_PREFIX && reJSXAbbrStart.test(prefix[1])) {\n                start = pos - 2;\n                offset = JSX_PREFIX.length;\n            }\n        }\n        else if (reWordBound.test(prefix)) {\n            start = pos - 1;\n        }\n        if (start >= 0) {\n            // Check if there’s paired character\n            const lastCh = prefix[prefix.length - 1];\n            if (lastCh in pairs && editor.substr(pos, pos + 1) === pairs[lastCh]) {\n                end++;\n            }\n            const config = this.getActivationContext(editor, pos);\n            if (config) {\n                if (config.type === 'stylesheet' && !reStylesheetWordBound.test(prefix)) {\n                    // Additional check for stylesheet abbreviation start: it’s slightly\n                    // differs from markup prefix, but we need activation context\n                    // to ensure that context under caret is CSS\n                    return;\n                }\n                const tracker = this.startTracking(editor, start, end, { offset, config });\n                if (tracker && tracker.type === \"abbreviation\" /* Abbreviation */ && ((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === \"@@section\" /* Section */) {\n                    // Make a silly check for section context: if user start typing\n                    // CSS selector at the end of file, it will be treated as property\n                    // name and provide unrelated completion by default.\n                    // We should check if captured abbreviation actually matched\n                    // snippet to continue. Otherwise, ignore this abbreviation.\n                    // By default, unresolved abbreviations are converted to CSS properties,\n                    // e.g. `a` → `a: ;`. If that’s the case, stop tracking\n                    const { abbreviation, preview } = tracker;\n                    if (preview.startsWith(abbreviation) && /^:\\s*;?$/.test(preview.slice(abbreviation.length))) {\n                        this.stopTracking(editor);\n                        return;\n                    }\n                }\n                return tracker;\n            }\n        }\n    }\n    /**\n     * Starts abbreviation tracking for given editor\n     * @param start Location of abbreviation start\n     * @param pos Current caret position, must be greater that `start`\n     */\n    startTracking(editor, start, pos, params) {\n        const config = (params === null || params === void 0 ? void 0 : params.config) || editor.config(start);\n        const tracker = this.createTracker(editor, [start, pos], Object.assign({ config }, params));\n        if (tracker) {\n            this.trackers.set(editor.id, tracker);\n            return tracker;\n        }\n        this.trackers.delete(editor.id);\n    }\n    /**\n     * Stops abbreviation tracking in given editor instance\n     */\n    stopTracking(editor, params) {\n        const tracker = this.getTracker(editor);\n        if (tracker) {\n            editor.unmark(tracker);\n            if (tracker.forced && !(params === null || params === void 0 ? void 0 : params.skipRemove)) {\n                // Contents of forced abbreviation must be removed\n                editor.replace('', tracker.range[0], tracker.range[1]);\n            }\n            if (params === null || params === void 0 ? void 0 : params.force) {\n                this.cache.delete(editor.id);\n            }\n            else {\n                // Store tracker in history to restore it if user continues editing\n                this.storeTracker(editor, tracker);\n            }\n            this.trackers.delete(editor.id);\n        }\n    }\n    /**\n     * Creates abbreviation tracker for given range in editor. Parses contents\n     * of abbreviation in range and returns either valid abbreviation tracker,\n     * error tracker or `null` if abbreviation cannot be created from given range\n     */\n    createTracker(editor, range, params) {\n        if (range[0] >= range[1]) {\n            // Invalid range\n            return null;\n        }\n        let abbreviation = editor.substr(range[0], range[1]);\n        const { config } = params;\n        if (params.offset) {\n            abbreviation = abbreviation.slice(params.offset);\n        }\n        // Basic validation: do not allow empty abbreviations\n        // or newlines in abbreviations\n        if (!abbreviation || /[\\r\\n]/.test(abbreviation)) {\n            return null;\n        }\n        const base = {\n            abbreviation,\n            range,\n            config,\n            forced: !!params.forced,\n            offset: params.offset || 0,\n            lastPos: range[1],\n            lastLength: editor.size(),\n        };\n        try {\n            let parsedAbbr;\n            let simple = false;\n            if (config.type === 'stylesheet') {\n                parsedAbbr = stylesheetAbbreviation(abbreviation);\n            }\n            else {\n                parsedAbbr = markupAbbreviation(abbreviation, {\n                    jsx: config.syntax === 'jsx'\n                });\n                simple = this.isSimpleMarkupAbbreviation(parsedAbbr);\n            }\n            const previewConfig = editor.previewConfig(config);\n            return Object.assign(Object.assign({}, base), { type: \"abbreviation\" /* Abbreviation */, simple, preview: expand(parsedAbbr, previewConfig) });\n        }\n        catch (error) {\n            return Object.assign(Object.assign({}, base), { type: \"error\" /* Error */, error });\n        }\n    }\n    /**\n     * Stores given tracker in separate cache to restore later\n     */\n    storeTracker(editor, tracker) {\n        this.cache.set(editor.id, tracker);\n    }\n    /**\n     * Returns stored tracker for given editor proxy, if any\n     */\n    getStoredTracker(editor) {\n        return this.cache.get(editor.id);\n    }\n    /**\n     * Tries to restore abbreviation tracker for given editor at specified position\n     */\n    restoreTracker(editor, pos) {\n        const tracker = this.getStoredTracker(editor);\n        if (tracker && tracker.range[0] <= pos && tracker.range[1] >= pos) {\n            const [from, to] = tracker.range;\n            if (editor.substr(from + tracker.offset, to) === tracker.abbreviation) {\n                this.trackers.set(editor.id, tracker);\n                tracker.lastLength = editor.size();\n                return tracker;\n            }\n        }\n    }\n    /**\n     * Handle content change in given editor instance\n     */\n    handleChange(editor, pos) {\n        const tracker = this.getTracker(editor);\n        const editorLastPos = this.getLastPost(editor);\n        this.setLastPos(editor, pos);\n        if (!tracker) {\n            // No active tracker, check if we user is actually typing it\n            if (editorLastPos != null && editorLastPos === pos - 1 && editor.allowTracking(pos)) {\n                return this.typingAbbreviation(editor, pos);\n            }\n            return;\n        }\n        const { lastPos } = tracker;\n        let { range } = tracker;\n        if (lastPos < range[0] || lastPos > range[1]) {\n            // Updated content outside abbreviation: reset tracker\n            this.stopTracking(editor);\n            return;\n        }\n        const length = editor.size();\n        const delta = length - tracker.lastLength;\n        range = range.slice();\n        // Modify range and validate it: if it leads to invalid abbreviation, reset tracker\n        updateRange(range, delta, lastPos);\n        // Handle edge case: empty forced abbreviation is allowed\n        if (range[0] === range[1] && tracker.forced) {\n            tracker.abbreviation = '';\n            return tracker;\n        }\n        const nextTracker = this.createTracker(editor, range, tracker);\n        if (!nextTracker || (!tracker.forced && !isValidTracker(nextTracker, range, pos))) {\n            this.stopTracking(editor);\n            return;\n        }\n        nextTracker.lastPos = pos;\n        this.trackers.set(editor.id, nextTracker);\n        editor.mark(nextTracker);\n        return nextTracker;\n    }\n    /**\n     * Handle selection (caret) change in given editor instance\n     */\n    handleSelectionChange(editor, pos) {\n        this.setLastPos(editor, pos);\n        const tracker = this.getTracker(editor) || this.restoreTracker(editor, pos);\n        if (tracker) {\n            tracker.lastPos = pos;\n            return tracker;\n        }\n    }\n    /**\n     * Detects and returns valid abbreviation activation context for given location\n     * in editor which can be used for abbreviation expanding.\n     * For example, in given HTML code:\n     * `<div title=\"Sample\" style=\"\">Hello world</div>`\n     * it’s not allowed to expand abbreviations inside `<div ...>` or `</div>`,\n     * yet it’s allowed inside `style` attribute and between tags.\n     *\n     * This method ensures that given `pos` is inside location allowed for expanding\n     * abbreviations and returns context data about it.\n     *\n     * Default implementation works for any editor since it uses own parsers for HTML\n     * and CSS but might be slow: if your editor supports low-level access to document\n     * parse tree or tokens, authors should override this method and provide alternative\n     * based on editor native features.\n     */\n    getActivationContext(editor, pos) {\n        const syntax = editor.syntax();\n        const content = editor.substr();\n        if (editor.isCSS(syntax)) {\n            return this.getCSSActivationContext(editor, pos, syntax, getCSSContext(content, pos));\n        }\n        if (editor.isHTML(syntax)) {\n            const ctx = getHTMLContext(content, pos, { xml: editor.isXML(syntax) });\n            if (ctx.css) {\n                return this.getCSSActivationContext(editor, pos, getEmbeddedStyleSyntax(content, ctx) || 'css', ctx.css);\n            }\n            if (!ctx.current) {\n                return {\n                    syntax,\n                    type: 'markup',\n                    context: getMarkupAbbreviationContext(content, ctx),\n                    options: editor.outputOptions(pos)\n                };\n            }\n        }\n        else {\n            return {\n                syntax,\n                type: editor.syntaxType(syntax),\n                options: editor.outputOptions(pos)\n            };\n        }\n    }\n    getCSSActivationContext(editor, pos, syntax, ctx) {\n        // CSS abbreviations can be activated only when a character is entered, e.g.\n        // it should be either property name or value.\n        // In come cases, a first character of selector should also be considered\n        // as activation context\n        if (!ctx.current) {\n            return void 0;\n        }\n        const allowedContext = ctx.current.type === \"propertyName\" /* PropertyName */\n            || ctx.current.type === \"propertyValue\" /* PropertyValue */\n            || this.isTypingBeforeSelector(editor, pos, ctx);\n        if (allowedContext) {\n            return {\n                syntax,\n                type: 'stylesheet',\n                context: getStylesheetAbbreviationContext(ctx),\n                options: editor.outputOptions(pos, ctx.inline)\n            };\n        }\n    }\n    /**\n     * Handle edge case: start typing abbreviation before selector. In this case,\n     * entered character becomes part of selector\n     * Activate only if it’s a nested section and it’s a first character of selector\n     */\n    isTypingBeforeSelector(editor, pos, { current }) {\n        if (current && current.type === \"selector\" /* Selector */ && current.range[0] === pos - 1) {\n            // Typing abbreviation before selector is tricky one:\n            // ensure it’s on its own line\n            const line = editor.substr(current.range[0], current.range[1]).split(/[\\n\\r]/)[0];\n            return line.trim().length === 1;\n        }\n        return false;\n    }\n    /**\n     * Check if given parsed markup abbreviation is simple.A simple abbreviation\n     * may not be displayed to user as preview to reduce distraction\n     */\n    isSimpleMarkupAbbreviation(abbr) {\n        if (abbr.children.length === 1 && !abbr.children[0].children.length) {\n            // Single element: might be a HTML element or text snippet\n            const first = abbr.children[0];\n            // XXX silly check for common snippets like `!`. Should read contents\n            // of expanded abbreviation instead\n            return !first.name || /^[a-z]/i.test(first.name);\n        }\n        return !abbr.children.length;\n    }\n    /**\n     * Method should be called when given editor instance will be no longer\n     * available to clean up cached data\n     */\n    disposeEditor(editor) {\n        this.cache.delete(editor.id);\n        this.trackers.delete(editor.id);\n        this.lastPos.delete(editor.id);\n    }\n}\nfunction updateRange(range, delta, lastPos) {\n    if (delta < 0) {\n        // Content removed\n        if (lastPos === range[0]) {\n            // Updated content at the abbreviation edge\n            range[0] += delta;\n            range[1] += delta;\n        }\n        else if (range[0] < lastPos && lastPos <= range[1]) {\n            range[1] += delta;\n        }\n    }\n    else if (delta > 0 && range[0] <= lastPos && lastPos <= range[1]) {\n        // Content inserted\n        range[1] += delta;\n    }\n    return range;\n}\n/**\n * Check if given tracker is in valid state for keeping it marked\n */\nfunction isValidTracker(tracker, range, pos) {\n    if (tracker.type === \"error\" /* Error */) {\n        if (range[1] === pos) {\n            // Last entered character is invalid\n            return false;\n        }\n        const { abbreviation } = tracker;\n        const start = range[0];\n        let targetPos = range[1];\n        while (targetPos > start) {\n            if (pairsEnd.includes(abbreviation[targetPos - start - 1])) {\n                targetPos--;\n            }\n            else {\n                break;\n            }\n        }\n        return targetPos !== pos;\n    }\n    return true;\n}\n\nexport { AbbreviationTrackingController, JSX_PREFIX, findTagMatch, getCSSContext, getCSSSection, getHTMLContext, getOpenTag, getTagMatches, selectItemCSS, selectItemHTML };\n//# sourceMappingURL=action-utils.es.js.map\n","import { AttributeToken } from '@emmetio/html-matcher';\nimport { CSSProperty, TextRange } from '@emmetio/action-utils';\n\n/** Characters to indicate tab stop start and end in generated snippet */\nexport const tabStopStart = String.fromCodePoint(0xFFF0);\nexport const tabStopEnd = String.fromCodePoint(0xFFF1);\nexport const stateKey = '$$emmet';\n\nexport interface AbbrError {\n    message: string,\n    pos: number\n}\n\nexport interface CMRange {\n    anchor: CodeMirror.Position;\n    head: CodeMirror.Position;\n}\n\nexport type DisposeFn = () => void;\n\nexport interface EmmetState {\n    id: string;\n    tracker?: DisposeFn | null;\n    tagMatch?: DisposeFn | null;\n}\n\nexport const pairs = {\n    '{': '}',\n    '[': ']',\n    '(': ')'\n};\n\nexport const pairsEnd: string[] = [];\nfor (const key of Object.keys(pairs)) {\n    pairsEnd.push(pairs[key]);\n}\n\nlet idCounter = 0;\n\n/**\n * Returns copy of region which starts and ends at non-space character\n */\nexport function narrowToNonSpace(editor: CodeMirror.Editor, range: TextRange): TextRange {\n    const text = substr(editor, range);\n    let startOffset = 0;\n    let endOffset = text.length;\n\n    while (startOffset < endOffset && isSpace(text[startOffset])) {\n        startOffset++;\n    }\n\n    while (endOffset > startOffset && isSpace(text[endOffset - 1])) {\n        endOffset--;\n    }\n\n    return [range[0] + startOffset, range[0] + endOffset];\n}\n\n/**\n * Replaces given range in editor with snippet contents\n */\nexport function replaceWithSnippet(editor: CodeMirror.Editor, range: TextRange, snippet: string): boolean {\n    return editor.operation(() => {\n        const snippetPayload = getSelectionsFromSnippet(snippet, range[0]);\n        const [from, to] = toRange(editor, range);\n        editor.replaceRange(snippetPayload.snippet, from, to);\n\n        // Position cursor\n        if (snippetPayload.ranges.length) {\n            const selections = snippetPayload.ranges.map(r => {\n                const [head, anchor] = toRange(editor, r);\n                return {  head, anchor } as CodeMirror.Range;\n            });\n            editor.setSelections(selections);\n        }\n\n        return true;\n    });\n}\n\n/**\n * Returns current caret position for single selection\n */\nexport function getCaret(editor: CodeMirror.Editor): number {\n    const pos = editor.getCursor();\n    return editor.indexFromPos(pos);\n}\n\n/**\n * Returns full text content of given editor\n */\nexport function getContent(editor: CodeMirror.Editor): string {\n    return editor.getValue();\n}\n\n/**\n * Returns substring of given editor content for specified range\n */\nexport function substr(editor: CodeMirror.Editor, range: TextRange): string {\n    const [from, to] = toRange(editor, range);\n    return editor.getRange(from, to);\n}\n\n/**\n * Converts given index range to editor’s position range\n */\nexport function toRange(editor: CodeMirror.Editor, range: TextRange): [CodeMirror.Position, CodeMirror.Position] {\n    return [\n        editor.posFromIndex(range[0]),\n        editor.posFromIndex(range[1])\n    ];\n}\n\n/**\n * Returns value of given attribute, parsed by Emmet HTML matcher\n */\nexport function attributeValue(attr: AttributeToken): string | undefined {\n    const { value } = attr\n    return value && isQuoted(value)\n        ? value.slice(1, -1)\n        : value;\n}\n\n/**\n * Returns region that covers entire attribute\n */\nexport function attributeRange(attr: AttributeToken): TextRange {\n    const end = attr.value != null ? attr.valueEnd! : attr.nameEnd;\n    return [attr.nameStart, end];\n}\n\n/**\n * Returns patched version of given HTML attribute, parsed by Emmet HTML matcher\n */\nexport function patchAttribute(attr: AttributeToken, value: string | number, name = attr.name) {\n    let before = '';\n    let after = '';\n\n    if (attr.value != null) {\n        if (isQuoted(attr.value)) {\n            // Quoted value or React-like expression\n            before = attr.value[0];\n            after = attr.value[attr.value.length - 1];\n        }\n    } else {\n        // Attribute without value (boolean)\n        before = after = '\"';\n    }\n\n    return `${name}=${before}${value}${after}`;\n}\n\n/**\n * Returns patched version of given CSS property, parsed by Emmet CSS matcher\n */\nexport function patchProperty(editor: CodeMirror.Editor, prop: CSSProperty, value: string, name?: string) {\n    if (name == null) {\n        name = substr(editor, prop.name);\n    }\n\n    const before = substr(editor, [prop.before, prop.name[0]]);\n    const between = substr(editor, [prop.name[1], prop.value[0]]);\n    const after = substr(editor, [prop.value[1], prop.after]);\n\n    return [before, name, between, value, after].join('');\n}\n\n/**\n * Check if given value is either quoted or written as expression\n */\nexport function isQuoted(value: string | undefined): boolean {\n    return !!value && (isQuotedString(value) || isExprString(value));\n}\n\nexport function isQuote(ch: string | undefined) {\n    return ch === '\"' || ch === \"'\";\n}\n\n/**\n * Check if given string is quoted with single or double quotes\n */\nexport function isQuotedString(str: string): boolean {\n    return str.length > 1 && isQuote(str[0]) && str[0] === str.slice(-1);\n}\n\n/**\n * Check if given string contains expression, e.g. wrapped with `{` and `}`\n */\nfunction isExprString(str: string): boolean {\n    return str[0] === '{' && str.slice(-1) === '}';\n}\n\nexport function isSpace(ch: string): boolean {\n    return /^[\\s\\n\\r]+$/.test(ch);\n}\n\nexport function htmlEscape(str: string): string {\n    const replaceMap = {\n        '<': '&lt;',\n        '>': '&gt;',\n        '&': '&amp;',\n    };\n    return str.replace(/[<>&]/g, ch => replaceMap[ch]);\n}\n\n/**\n * Returns special object for bypassing command handling\n */\nexport function pass(editor: CodeMirror.Editor) {\n    return editor.constructor['Pass'];\n}\n\n/**\n * Converts given CodeMirror range to text range\n */\nexport function textRange(editor: CodeMirror.Editor, range: CMRange): TextRange {\n    const head = editor.indexFromPos(range.head);\n    const anchor = editor.indexFromPos(range.anchor);\n    return [\n        Math.min(head, anchor),\n        Math.max(head, anchor)\n    ];\n}\n\n/**\n * Check if `a` and `b` contains the same range\n */\nexport function rangesEqual(a: TextRange, b: TextRange): boolean {\n    return a[0] === b[0] && a[1] === b[1];\n}\n\n/**\n * Check if range `a` fully contains range `b`\n */\nexport function rangeContains(a: TextRange, b: TextRange): boolean {\n    return a[0] <= b[0] && a[1] >= b[1];\n}\n\n/**\n * Check if given range is empty\n */\nexport function rangeEmpty(r: TextRange): boolean {\n    return r[0] === r[1];\n}\n\n/**\n * Generates snippet with error pointer\n */\nexport function errorSnippet(err: AbbrError, baseClass = 'emmet-error-snippet'): string {\n    const msg = err.message.split('\\n')[0];\n    const spacer = ' '.repeat(err.pos || 0);\n    return `<div class=\"${baseClass}\">\n        <div class=\"${baseClass}-ptr\">\n            <div class=\"${baseClass}-line\"></div>\n            <div class=\"${baseClass}-tip\"></div>\n            <div class=\"${baseClass}-spacer\">${spacer}</div>\n        </div>\n        <div class=\"${baseClass}-message\">${htmlEscape(msg.replace(/\\s+at\\s+\\d+$/, ''))}</div>\n    </div>`;\n}\n\n/**\n * Returns last element in given array\n */\nexport function last<T>(arr: T[]): T | undefined {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n\n/**\n * Check if given editor instance has internal Emmet state\n */\nexport function hasInternalState(editor: CodeMirror.Editor): boolean {\n    return stateKey in editor;\n}\n\n/**\n * Returns internal Emmet state for given editor instance\n */\nexport function getInternalState(editor: CodeMirror.Editor): EmmetState {\n    if (!hasInternalState(editor)) {\n        editor[stateKey] = { id: String(idCounter++) } as EmmetState;\n    }\n\n    return editor[stateKey];\n}\n\n/**\n * Finds and collects selections ranges from given snippet\n */\nfunction getSelectionsFromSnippet(snippet: string, base = 0): { ranges: TextRange[], snippet: string } {\n    // Find and collect selection ranges from snippet\n    const ranges: TextRange[] = [];\n    let result = '';\n    let sel: TextRange | null = null;\n    let offset = 0;\n    let i = 0;\n    let ch: string;\n\n    while (i < snippet.length) {\n        ch = snippet.charAt(i++);\n        if (ch === tabStopStart || ch === tabStopEnd) {\n            result += snippet.slice(offset, i - 1);\n            offset = i;\n\n            if (ch === tabStopStart) {\n                sel = [base + result.length, base + result.length];\n                ranges.push(sel);\n            } else if (sel) {\n                sel[1] = base + result.length;\n                sel = null;\n            }\n        }\n    }\n\n    return {\n        ranges,\n        snippet: result + snippet.slice(offset)\n    };\n}\n","import Scanner, { eatPair, isAlpha, isNumber, isQuote, isSpace, eatQuoted } from '@emmetio/scanner';\n\nconst defaultOptions = {\n    xml: false,\n    allTokens: false,\n    special: {\n        style: null,\n        script: ['', 'text/javascript', 'application/x-javascript', 'javascript', 'typescript', 'ts', 'coffee', 'coffeescript']\n    },\n    empty: ['img', 'meta', 'link', 'br', 'base', 'hr', 'area', 'wbr', 'col', 'embed', 'input', 'param', 'source', 'track']\n};\n/** Options for `Scanner` utils */\nconst opt = { throws: false };\nfunction createOptions(options = {}) {\n    return Object.assign(Object.assign({}, defaultOptions), options);\n}\n/**\n * Converts given string into array of character codes\n */\nfunction toCharCodes(str) {\n    return str.split('').map(ch => ch.charCodeAt(0));\n}\n/**\n * Consumes array of character codes from given scanner\n */\nfunction consumeArray(scanner, codes) {\n    const start = scanner.pos;\n    for (let i = 0; i < codes.length; i++) {\n        if (!scanner.eat(codes[i])) {\n            scanner.pos = start;\n            return false;\n        }\n    }\n    scanner.start = start;\n    return true;\n}\n/**\n * Consumes section from given string which starts with `open` character codes\n * and ends with `close` character codes\n * @return Returns `true` if section was consumed\n */\nfunction consumeSection(scanner, open, close, allowUnclosed) {\n    const start = scanner.pos;\n    if (consumeArray(scanner, open)) {\n        // consumed `<!--`, read next until we find ending part or reach the end of input\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, close)) {\n                scanner.start = start;\n                return true;\n            }\n            scanner.pos++;\n        }\n        // unclosed section is allowed\n        if (allowUnclosed) {\n            scanner.start = start;\n            return true;\n        }\n        scanner.pos = start;\n        return false;\n    }\n    // unable to find section, revert to initial position\n    scanner.pos = start;\n    return false;\n}\n/**\n * Check if given character can be used as a start of tag name or attribute\n */\nfunction nameStartChar(ch) {\n    // Limited XML spec: https://www.w3.org/TR/xml/#NT-NameStartChar\n    return isAlpha(ch) || ch === 58 /* Colon */ || ch === 95 /* Underscore */\n        || (ch >= 0xC0 && ch <= 0xD6)\n        || (ch >= 0xD8 && ch <= 0xF6)\n        || (ch >= 0xF8 && ch <= 0x2FF)\n        || (ch >= 0x370 && ch <= 0x37D)\n        || (ch >= 0x37F && ch <= 0x1FFF);\n}\n/**\n * Check if given character can be used in a tag or attribute name\n */\nfunction nameChar(ch) {\n    // Limited XML spec: https://www.w3.org/TR/xml/#NT-NameChar\n    return nameStartChar(ch) || ch === 45 /* Dash */ || ch === 46 /* Dot */ || isNumber(ch)\n        || ch === 0xB7\n        || (ch >= 0x0300 && ch <= 0x036F);\n}\n/**\n * Consumes identifier from given scanner\n */\nfunction ident(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(nameStartChar)) {\n        scanner.eatWhile(nameChar);\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Check if given code is tag terminator\n */\nfunction isTerminator(code) {\n    return code === 62 /* RightAngle */ || code === 47 /* Slash */;\n}\n/**\n * Check if given character code is valid unquoted value\n */\nfunction isUnquoted(code) {\n    return !isNaN(code) && !isQuote(code) && !isSpace(code) && !isTerminator(code);\n}\n/**\n * Consumes paired tokens (like `[` and `]`) with respect of nesting and embedded\n * quoted values\n * @return `true` if paired token was consumed\n */\nfunction consumePaired(scanner) {\n    return eatPair(scanner, 60 /* LeftAngle */, 62 /* RightAngle */, opt)\n        || eatPair(scanner, 40 /* LeftRound */, 41 /* RightRound */, opt)\n        || eatPair(scanner, 91 /* LeftSquare */, 93 /* RightSquare */, opt)\n        || eatPair(scanner, 123 /* LeftCurly */, 125 /* RightCurly */, opt);\n}\n/**\n * Returns unquoted value of given string\n */\nfunction getUnquotedValue(value) {\n    // Trim quotes\n    if (isQuote(value.charCodeAt(0))) {\n        value = value.slice(1);\n    }\n    if (isQuote(value.charCodeAt(value.length - 1))) {\n        value = value.slice(0, -1);\n    }\n    return value;\n}\n\n/**\n * Parses given string as list of HTML attributes.\n * @param src A fragment to parse. If `name` argument is provided, it must be an\n * opening tag (`<a foo=\"bar\">`), otherwise it should be a fragment between element\n * name and tag closing angle (`foo=\"bar\"`)\n * @param name Tag name\n */\nfunction attributes(src, name) {\n    const result = [];\n    let start = 0;\n    let end = src.length;\n    if (name) {\n        start = name.length + 1;\n        end -= src.slice(-2) === '/>' ? 2 : 1;\n    }\n    const scanner = new Scanner(src, start, end);\n    while (!scanner.eof()) {\n        scanner.eatWhile(isSpace);\n        if (attributeName(scanner)) {\n            const token = {\n                name: scanner.current(),\n                nameStart: scanner.start,\n                nameEnd: scanner.pos\n            };\n            if (scanner.eat(61 /* Equals */) && attributeValue(scanner)) {\n                token.value = scanner.current();\n                token.valueStart = scanner.start;\n                token.valueEnd = scanner.pos;\n            }\n            result.push(token);\n        }\n        else {\n            // Do not break on invalid attributes: we are not validating parser\n            scanner.pos++;\n        }\n    }\n    return result;\n}\n/**\n * Consumes attribute name from given scanner context\n */\nfunction attributeName(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */) || scanner.eat(35 /* Hash */)) {\n        // Angular-style directives: `<section *ngIf=\"showSection\">`, `<video #movieplayer ...>`\n        ident(scanner);\n        scanner.start = start;\n        return true;\n    }\n    // Attribute name could be a regular name or expression:\n    // React-style – `<div {...props}>`\n    // Angular-style – `<div [ng-for]>` or `<div *ng-for>`\n    return consumePaired(scanner) || ident(scanner);\n}\n/**\n * Consumes attribute value\n */\nfunction attributeValue(scanner) {\n    // Supported attribute values are quoted, React-like expressions (`{foo}`)\n    // or unquoted literals\n    return eatQuoted(scanner, opt) || consumePaired(scanner) || unquoted(scanner);\n}\n/**\n * Returns clean (unquoted) value of `name` attribute\n */\nfunction getAttributeValue(attrs, name) {\n    for (let i = 0; i < attrs.length; i++) {\n        const attr = attrs[i];\n        if (attr.name === name) {\n            return attr.value && getUnquotedValue(attr.value);\n        }\n    }\n}\n/**\n * Consumes unquoted value\n */\nfunction unquoted(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isUnquoted)) {\n        scanner.start = start;\n        return true;\n    }\n}\n\nconst cdataOpen = toCharCodes('<![CDATA[');\nconst cdataClose = toCharCodes(']]>');\nconst commentOpen = toCharCodes('<!--');\nconst commentClose = toCharCodes('-->');\nconst piStart = toCharCodes('<?');\nconst piEnd = toCharCodes('?>');\nconst erbStart = toCharCodes('<%');\nconst erbEnd = toCharCodes('%>');\n/**\n * Performs fast scan of given source code: for each tag found it invokes callback\n * with tag name, its type (open, close, self-close) and range in original source.\n * Unlike regular scanner, fast scanner doesn’t provide info about attributes to\n * reduce object allocations hence increase performance.\n * If `callback` returns `false`, scanner stops parsing.\n * @param special List of “special” HTML tags which should be ignored. Most likely\n * it’s a \"script\" and \"style\" tags.\n */\nfunction scan(source, callback, options) {\n    const scanner = new Scanner(source);\n    const special = options ? options.special : null;\n    const allTokens = options ? options.allTokens : false;\n    let type;\n    let name;\n    let nameStart;\n    let nameEnd;\n    let nameCodes;\n    let found = false;\n    let piName = null;\n    while (!scanner.eof()) {\n        const start = scanner.pos;\n        if (cdata(scanner)) {\n            if (allTokens && callback('#cdata', 4 /* CData */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (comment(scanner)) {\n            if (allTokens && callback('#comment', 6 /* Comment */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (erb(scanner)) {\n            if (allTokens && callback('#erb', 7 /* ERB */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (piName = processingInstruction(scanner)) {\n            if (allTokens && callback(piName, 5 /* ProcessingInstruction */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (scanner.eat(60 /* LeftAngle */)) {\n            // Maybe a tag name?\n            type = scanner.eat(47 /* Slash */) ? 2 /* Close */ : 1 /* Open */;\n            nameStart = scanner.pos;\n            if (ident(scanner)) {\n                // Consumed tag name\n                nameEnd = scanner.pos;\n                if (type !== 2 /* Close */) {\n                    skipAttributes(scanner);\n                    scanner.eatWhile(isSpace);\n                    if (scanner.eat(47 /* Slash */)) {\n                        type = 3 /* SelfClose */;\n                    }\n                }\n                if (scanner.eat(62 /* RightAngle */)) {\n                    // Tag properly closed\n                    name = scanner.substring(nameStart, nameEnd);\n                    if (callback(name, type, start, scanner.pos) === false) {\n                        break;\n                    }\n                    if (type === 1 /* Open */ && special && isSpecial(special, name, source, start, scanner.pos)) {\n                        // Found opening tag of special element: we should skip\n                        // scanner contents until we find closing tag\n                        nameCodes = toCharCodes(name);\n                        found = false;\n                        while (!scanner.eof()) {\n                            if (consumeClosing(scanner, nameCodes)) {\n                                found = true;\n                                break;\n                            }\n                            scanner.pos++;\n                        }\n                        if (found && callback(name, 2 /* Close */, scanner.start, scanner.pos) === false) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n}\n/**\n * Skips attributes in current tag context\n */\nfunction skipAttributes(scanner) {\n    while (!scanner.eof()) {\n        scanner.eatWhile(isSpace);\n        if (attributeName(scanner)) {\n            if (scanner.eat(61 /* Equals */)) {\n                attributeValue(scanner);\n            }\n        }\n        else if (isTerminator(scanner.peek())) {\n            break;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n}\n/**\n * Consumes closing tag with given name from scanner\n */\nfunction consumeClosing(scanner, name) {\n    const start = scanner.pos;\n    if (scanner.eat(60 /* LeftAngle */) && scanner.eat(47 /* Slash */) && consumeArray(scanner, name) && scanner.eat(62 /* RightAngle */)) {\n        scanner.start = start;\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes CDATA from given scanner\n */\nfunction cdata(scanner) {\n    return consumeSection(scanner, cdataOpen, cdataClose, true);\n}\n/**\n * Consumes comments from given scanner\n */\nfunction comment(scanner) {\n    return consumeSection(scanner, commentOpen, commentClose, true);\n}\n/**\n * Consumes processing instruction from given scanner. If consumed, returns\n * processing instruction name\n */\nfunction processingInstruction(scanner) {\n    const start = scanner.pos;\n    if (consumeArray(scanner, piStart) && ident(scanner)) {\n        const name = scanner.current();\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, piEnd)) {\n                break;\n            }\n            eatQuoted(scanner) || scanner.pos++;\n        }\n        scanner.start = start;\n        return name;\n    }\n    scanner.pos = start;\n    return null;\n}\n/**\n * Consumes ERB-style entity: `<% ... %>` or `<%= ... %>`\n */\nfunction erb(scanner) {\n    const start = scanner.pos;\n    if (consumeArray(scanner, erbStart)) {\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, erbEnd)) {\n                break;\n            }\n            eatQuoted(scanner) || scanner.pos++;\n        }\n        scanner.start = start;\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Check if given tag name should be considered as special\n */\nfunction isSpecial(special, name, source, start, end) {\n    if (name in special) {\n        const typeValues = special[name];\n        if (!Array.isArray(typeValues)) {\n            return true;\n        }\n        const attrs = attributes(source.substring(start + name.length + 1, end - 1));\n        return typeValues.includes(getAttributeValue(attrs, 'type') || '');\n    }\n    return false;\n}\n\n/**\n * Finds matched tag for given `pos` location in XML/HTML `source`\n */\nfunction match(source, pos, opt) {\n    // Since we expect large input document, we’ll use pooling technique\n    // for storing tag data to reduce memory pressure and improve performance\n    const pool = [];\n    const stack = [];\n    const options = createOptions(opt);\n    let result = null;\n    scan(source, (name, type, start, end) => {\n        if (type === 1 /* Open */ && isSelfClose(name, options)) {\n            // Found empty element in HTML mode, mark is as self-closing\n            type = 3 /* SelfClose */;\n        }\n        if (type === 1 /* Open */) {\n            // Allocate tag object from pool\n            stack.push(allocTag(pool, name, start, end));\n        }\n        else if (type === 3 /* SelfClose */) {\n            if (start < pos && pos < end) {\n                // Matched given self-closing tag\n                result = {\n                    name,\n                    attributes: getAttributes(source, start, end, name),\n                    open: [start, end]\n                };\n                return false;\n            }\n        }\n        else {\n            const tag = last(stack);\n            if (tag && tag.name === name) {\n                // Matching closing tag found\n                if (tag.start < pos && pos < end) {\n                    result = {\n                        name,\n                        attributes: getAttributes(source, tag.start, tag.end, name),\n                        open: [tag.start, tag.end],\n                        close: [start, end]\n                    };\n                    return false;\n                }\n                else if (stack.length) {\n                    // Release tag object for further re-use\n                    releaseTag(pool, stack.pop());\n                }\n            }\n        }\n    }, options);\n    stack.length = pool.length = 0;\n    return result;\n}\n/**\n * Returns balanced tag model: a list of all XML/HTML tags that could possibly match\n * given location when moving in outward direction\n */\nfunction balancedOutward(source, pos, opt) {\n    const pool = [];\n    const stack = [];\n    const options = createOptions(opt);\n    const result = [];\n    scan(source, (name, type, start, end) => {\n        if (type === 2 /* Close */) {\n            const tag = last(stack);\n            if (tag && tag.name === name) { // XXX check for invalid tag names?\n                // Matching closing tag found, check if matched pair is a candidate\n                // for outward balancing\n                if (tag.start < pos && pos < end) {\n                    result.push({\n                        name,\n                        open: [tag.start, tag.end],\n                        close: [start, end]\n                    });\n                }\n                // Release tag object for further re-use\n                releaseTag(pool, stack.pop());\n            }\n        }\n        else if (type === 3 /* SelfClose */ || isSelfClose(name, options)) {\n            if (start < pos && pos < end) {\n                // Matched self-closed tag\n                result.push({ name, open: [start, end] });\n            }\n        }\n        else {\n            stack.push(allocTag(pool, name, start, end));\n        }\n    }, options);\n    stack.length = pool.length = 0;\n    return result;\n}\n/**\n * Returns balanced tag model: a list of all XML/HTML tags that could possibly match\n * given location when moving in inward direction\n */\nfunction balancedInward(source, pos, opt) {\n    // Collecting tags for inward balancing is a bit trickier: we have to store\n    // first child of every matched tag until we find the one that matches given\n    // location\n    const pool = [];\n    const stack = [];\n    const options = createOptions(opt);\n    const result = [];\n    const alloc = (name, start, end) => {\n        if (pool.length) {\n            const tag = pool.pop();\n            tag.name = name;\n            tag.ranges.push(start, end);\n            return tag;\n        }\n        return { name, ranges: [start, end] };\n    };\n    const release = (tag) => {\n        tag.ranges.length = 0;\n        tag.firstChild = void 0;\n        pool.push(tag);\n    };\n    scan(source, (name, type, start, end) => {\n        if (type === 2 /* Close */) {\n            if (!stack.length) {\n                // Some sort of lone closing tag, ignore it\n                return;\n            }\n            let tag = last(stack);\n            if (tag.name === name) { // XXX check for invalid tag names?\n                // Matching closing tag found, check if matched pair is a candidate\n                // for outward balancing\n                if (tag.ranges[0] <= pos && pos <= end) {\n                    result.push({\n                        name,\n                        open: tag.ranges.slice(0, 2),\n                        close: [start, end]\n                    });\n                    while (tag.firstChild) {\n                        const child = tag.firstChild;\n                        const res = {\n                            name: child.name,\n                            open: child.ranges.slice(0, 2)\n                        };\n                        if (child.ranges.length > 2) {\n                            res.close = child.ranges.slice(2, 4);\n                        }\n                        result.push(res);\n                        release(tag);\n                        tag = child;\n                    }\n                    return false;\n                }\n                else {\n                    stack.pop();\n                    const parent = last(stack);\n                    if (parent && !parent.firstChild) {\n                        // No first child in parent node: store current tag\n                        tag.ranges.push(start, end);\n                        parent.firstChild = tag;\n                    }\n                    else {\n                        release(tag);\n                    }\n                }\n            }\n        }\n        else if (type === 3 /* SelfClose */ || isSelfClose(name, options)) {\n            if (start < pos && pos < end) {\n                // Matched self-closed tag, no need to look further\n                result.push({ name, open: [start, end] });\n                return false;\n            }\n            const parent = last(stack);\n            if (parent && !parent.firstChild) {\n                parent.firstChild = alloc(name, start, end);\n            }\n        }\n        else {\n            stack.push(alloc(name, start, end));\n        }\n    }, options);\n    stack.length = pool.length = 0;\n    return result;\n}\nfunction allocTag(pool, name, start, end) {\n    if (pool.length) {\n        const tag = pool.pop();\n        tag.name = name;\n        tag.start = start;\n        tag.end = end;\n        return tag;\n    }\n    return { name, start, end };\n}\nfunction releaseTag(pool, tag) {\n    pool.push(tag);\n}\n/**\n * Returns parsed attributes from given source\n */\nfunction getAttributes(source, start, end, name) {\n    const tokens = attributes(source.slice(start, end), name);\n    tokens.forEach(attr => {\n        attr.nameStart += start;\n        attr.nameEnd += start;\n        if (attr.value != null) {\n            attr.valueStart += start;\n            attr.valueEnd += start;\n        }\n    });\n    return tokens;\n}\n/**\n * Check if given tag is self-close for current parsing context\n */\nfunction isSelfClose(name, options) {\n    return !options.xml && options.empty.includes(name);\n}\nfunction last(arr) {\n    return arr.length ? arr[arr.length - 1] : null;\n}\n\nexport default match;\nexport { attributes, balancedInward, balancedOutward, createOptions, scan };\n//# sourceMappingURL=html-matcher.es.js.map\n","import { SyntaxType, CSSAbbreviationScope, AbbreviationContext } from 'emmet';\nimport { TokenType } from '@emmetio/css-matcher';\nimport { attributes } from '@emmetio/html-matcher';\nimport { CSSContext, HTMLContext, getHTMLContext, getCSSContext } from '@emmetio/action-utils';\nimport { EnableForSyntax } from './config';\nimport { getContent, last, attributeValue } from './utils';\n\nconst xmlSyntaxes = ['xml', 'xsl', 'jsx'];\nconst htmlSyntaxes = ['html', 'htmlmixed', 'vue'];\nconst cssSyntaxes = ['css', 'scss', 'less'];\nconst jsxSyntaxes = ['jsx', 'tsx'];\nconst markupSyntaxes = ['haml', 'jade', 'pug', 'slim'].concat(htmlSyntaxes, xmlSyntaxes, jsxSyntaxes);\nconst stylesheetSyntaxes = ['sass', 'sss', 'stylus', 'postcss'].concat(cssSyntaxes);\n\nexport interface SyntaxInfo {\n    type: SyntaxType;\n    syntax?: string;\n    inline?: boolean;\n    context?: HTMLContext | CSSContext;\n}\n\nexport interface StylesheetRegion {\n    range: [number, number];\n    syntax: string;\n    inline?: boolean;\n}\n\nexport interface SyntaxCache {\n    stylesheetRegions?: StylesheetRegion[];\n}\n\n/**\n * Returns Emmet syntax info for given location in view.\n * Syntax info is an abbreviation type (either 'markup' or 'stylesheet') and syntax\n * name, which is used to apply syntax-specific options for output.\n *\n * By default, if given location doesn’t match any known context, this method\n * returns `null`, but if `fallback` argument is provided, it returns data for\n * given fallback syntax\n */\nexport function syntaxInfo(editor: CodeMirror.Editor, pos: number): SyntaxInfo {\n    let syntax = docSyntax(editor);\n    let inline: boolean | undefined;\n    let context: HTMLContext | CSSContext | undefined;\n\n    if (isHTML(syntax)) {\n        const content = getContent(editor);\n        context = getHTMLContext(content, pos, {\n            xml: isXML(syntax)\n        });\n\n        if (context.css) {\n            // `pos` is in embedded CSS\n            syntax = getEmbeddedStyleSyntax(content, context) || 'css';\n            inline = context.css.inline;\n            context = context.css;\n        }\n    } else if (isCSS(syntax)) {\n        context = getCSSContext(getContent(editor), pos);\n    }\n\n    return {\n        type: getSyntaxType(syntax),\n        syntax,\n        inline,\n        context\n    };\n}\n\n/**\n * Returns syntax for given position in editor\n */\nexport function syntaxFromPos(editor: CodeMirror.Editor, pos: number): string | undefined {\n    const p = editor.posFromIndex(pos);\n    const mode = editor.getModeAt(p);\n    if (mode && mode.name === 'xml') {\n        // XML mode is used for styling HTML as well\n        return mode.configuration || mode.name;\n    }\n    return mode && mode.name;\n}\n\n/**\n * Returns main editor syntax\n */\nexport function docSyntax(editor: CodeMirror.Editor): string {\n    const mode = editor.getMode();\n    if (mode) {\n        return mode.name === 'htmlmixed' ? 'html' : (mode.name || '');\n    }\n    return '';\n}\n\n/**\n * Returns Emmet abbreviation type for given syntax\n */\nexport function getSyntaxType(syntax?: string): SyntaxType {\n    return syntax && stylesheetSyntaxes.includes(syntax) ? 'stylesheet' : 'markup';\n}\n\n/**\n * Check if given syntax is XML dialect\n */\nexport function isXML(syntax?: string): boolean {\n    return syntax ? xmlSyntaxes.includes(syntax) : false;\n}\n\n/**\n * Check if given syntax is HTML dialect (including XML)\n */\nexport function isHTML(syntax?: string): boolean {\n    return syntax\n        ? htmlSyntaxes.includes(syntax) || isXML(syntax)\n        : false;\n}\n\n/**\n * Check if given syntax name is supported by Emmet\n */\nexport function isSupported(syntax: string): boolean {\n    return syntax\n        ? markupSyntaxes.includes(syntax) || stylesheetSyntaxes.includes(syntax)\n        : false;\n}\n\n/**\n * Check if given syntax is a CSS dialect. Note that it’s not the same as stylesheet\n * syntax: for example, SASS is a stylesheet but not CSS dialect (but SCSS is)\n */\nexport function isCSS(syntax?: string): boolean {\n    return syntax ? cssSyntaxes.includes(syntax) : false;\n}\n\n/**\n * Check if given syntax is JSX dialect\n */\nexport function isJSX(syntax?: string): boolean {\n    return syntax ? jsxSyntaxes.includes(syntax) : false;\n}\n\n/**\n * Check if given option if enabled for specified syntax\n */\nexport function enabledForSyntax(opt: EnableForSyntax, info: SyntaxInfo) {\n    if (opt === true) {\n        return true;\n    }\n\n    if (Array.isArray(opt)) {\n        const candidates: string[] = [info.type, info.syntax!];\n        if (info.inline) {\n            candidates.push(`${info.type}-inline`, `${info.syntax!}-inline`);\n        }\n\n        return candidates.some(c => opt.includes(c));\n    }\n\n    return false;\n}\n\n/**\n * Returns embedded stylesheet syntax from given HTML context\n */\nexport function getEmbeddedStyleSyntax(code: string, ctx: HTMLContext): string | undefined {\n    const parent = last(ctx.ancestors);\n    if (parent && parent.name === 'style') {\n        for (const attr of attributes(code.slice(parent.range[0], parent.range[1]), parent.name)) {\n            if (attr.name === 'type') {\n                return attributeValue(attr);\n            }\n        }\n    }\n}\n\n/**\n * Returns context for Emmet abbreviation from given HTML context\n */\nexport function getMarkupAbbreviationContext(code: string, ctx: HTMLContext): AbbreviationContext | undefined {\n    const parent = last(ctx.ancestors);\n    if (parent) {\n        const attrs: { [name: string]: string } = {};\n        for (const attr of attributes(code.slice(parent.range[0], parent.range[1]), parent.name)) {\n            attrs[attr.name] = attributeValue(attr) || '';\n        }\n\n        return {\n            name: parent.name,\n            attributes: attrs\n        };\n    }\n}\n\n/**\n * Returns context for Emmet abbreviation from given CSS context\n */\nexport function getStylesheetAbbreviationContext(ctx: CSSContext): AbbreviationContext {\n    if (ctx.inline) {\n        return { name: CSSAbbreviationScope.Property }\n    }\n\n    const parent = last(ctx.ancestors);\n    let scope: string = CSSAbbreviationScope.Global;\n    if (ctx.current) {\n        if (ctx.current.type === TokenType.PropertyValue && parent) {\n            scope = parent.name;\n        } else if ((ctx.current.type === TokenType.Selector || ctx.current.type === TokenType.PropertyName) && !parent) {\n            scope = CSSAbbreviationScope.Section;\n        }\n    }\n\n    return {\n        name: scope\n    };\n}\n","import parse$2 from '@emmetio/abbreviation';\nexport { default as markupAbbreviation } from '@emmetio/abbreviation';\nimport parse$3 from '@emmetio/css-abbreviation';\nexport { default as stylesheetAbbreviation } from '@emmetio/css-abbreviation';\n\n/**\n * Merges attributes in current node: de-duplicates attributes with the same name\n * and merges class names\n */\nfunction mergeAttributes(node, config) {\n    if (!node.attributes) {\n        return;\n    }\n    const attributes = [];\n    const lookup = {};\n    for (const attr of node.attributes) {\n        if (attr.name) {\n            const attrName = attr.name;\n            if (attrName in lookup) {\n                const prev = lookup[attrName];\n                if (attrName === 'class') {\n                    prev.value = mergeValue(prev.value, attr.value, ' ');\n                }\n                else {\n                    mergeDeclarations(prev, attr, config);\n                }\n            }\n            else {\n                // Create new attribute instance so we can safely modify it later\n                attributes.push(lookup[attrName] = Object.assign({}, attr));\n            }\n        }\n        else {\n            attributes.push(attr);\n        }\n    }\n    node.attributes = attributes;\n}\n/**\n * Merges two token lists into single list. Adjacent strings are merged together\n */\nfunction mergeValue(prev, next, glue) {\n    if (prev && next) {\n        if (prev.length && glue) {\n            append(prev, glue);\n        }\n        for (const t of next) {\n            append(prev, t);\n        }\n        return prev;\n    }\n    const result = prev || next;\n    return result && result.slice();\n}\n/**\n * Merges data from `src` attribute into `dest` and returns it\n */\nfunction mergeDeclarations(dest, src, config) {\n    dest.name = src.name;\n    if (!config.options['output.reverseAttributes']) {\n        dest.value = src.value;\n    }\n    // Keep high-priority properties\n    if (!dest.implied) {\n        dest.implied = src.implied;\n    }\n    if (!dest.boolean) {\n        dest.boolean = src.boolean;\n    }\n    if (dest.valueType !== 'expression') {\n        dest.valueType = src.valueType;\n    }\n    return dest;\n}\nfunction append(tokens, value) {\n    const lastIx = tokens.length - 1;\n    if (typeof tokens[lastIx] === 'string' && typeof value === 'string') {\n        tokens[lastIx] += value;\n    }\n    else {\n        tokens.push(value);\n    }\n}\n\n/**\n * Walks over each child node of given markup abbreviation AST node (not including\n * given one) and invokes `fn` on each node.\n * The `fn` callback accepts context node, list of ancestor nodes and optional\n * state object\n */\nfunction walk(node, fn, state) {\n    const ancestors = [node];\n    const callback = (ctx) => {\n        fn(ctx, ancestors, state);\n        ancestors.push(ctx);\n        ctx.children.forEach(callback);\n        ancestors.pop();\n    };\n    node.children.forEach(callback);\n}\n/**\n * Finds node which is the deepest for in current node or node itself.\n */\nfunction findDeepest(node) {\n    let parent;\n    while (node.children.length) {\n        parent = node;\n        node = node.children[node.children.length - 1];\n    }\n    return { parent, node };\n}\nfunction isNode(node) {\n    return node.type === 'AbbreviationNode';\n}\n\n/**\n * Finds matching snippet from `registry` and resolves it into a parsed abbreviation.\n * Resolved node is then updated or replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attributes and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n */\nfunction resolveSnippets(abbr, config) {\n    const stack = [];\n    const reversed = config.options['output.reverseAttributes'];\n    const resolve = (child) => {\n        const snippet = child.name && config.snippets[child.name];\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.includes(snippet)) {\n            return null;\n        }\n        const snippetAbbr = parse$2(snippet, config);\n        stack.push(snippet);\n        walkResolve(snippetAbbr, resolve);\n        stack.pop();\n        // Add attributes from current node into every top-level node of parsed abbreviation\n        for (const topNode of snippetAbbr.children) {\n            if (child.attributes) {\n                const from = topNode.attributes || [];\n                const to = child.attributes || [];\n                topNode.attributes = reversed ? to.concat(from) : from.concat(to);\n            }\n            mergeNodes(child, topNode);\n        }\n        return snippetAbbr;\n    };\n    walkResolve(abbr, resolve);\n    return abbr;\n}\nfunction walkResolve(node, resolve, config) {\n    let children = [];\n    for (const child of node.children) {\n        const resolved = resolve(child);\n        if (resolved) {\n            children = children.concat(resolved.children);\n            const deepest = findDeepest(resolved);\n            if (isNode(deepest.node)) {\n                deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));\n            }\n        }\n        else {\n            children.push(child);\n            child.children = walkResolve(child, resolve);\n        }\n    }\n    return node.children = children;\n}\n/**\n * Adds data from first node into second node\n */\nfunction mergeNodes(from, to) {\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n    if (from.value != null) {\n        to.value = from.value;\n    }\n    if (from.repeat) {\n        to.repeat = from.repeat;\n    }\n}\n\nfunction createOutputStream(options, level = 0) {\n    return {\n        options,\n        value: '',\n        level,\n        offset: 0,\n        line: 0,\n        column: 0\n    };\n}\n/**\n * Pushes plain string into output stream without newline processing\n */\nfunction push(stream, text) {\n    const processText = stream.options['output.text'];\n    _push(stream, processText(text, stream.offset, stream.line, stream.column));\n}\n/**\n * Pushes given string with possible newline formatting into output\n */\nfunction pushString(stream, value) {\n    // If given value contains newlines, we should push content line-by-line and\n    // use `pushNewline()` to maintain proper line/column state\n    const lines = splitByLines(value);\n    for (let i = 0, il = lines.length - 1; i <= il; i++) {\n        push(stream, lines[i]);\n        if (i !== il) {\n            pushNewline(stream, true);\n        }\n    }\n}\n/**\n * Pushes new line into given output stream\n */\nfunction pushNewline(stream, indent) {\n    const baseIndent = stream.options['output.baseIndent'];\n    const newline = stream.options['output.newline'];\n    push(stream, newline + baseIndent);\n    stream.line++;\n    stream.column = baseIndent.length;\n    if (indent) {\n        pushIndent(stream, indent === true ? stream.level : indent);\n    }\n}\n/**\n * Adds indentation of `size` to current output stream\n */\nfunction pushIndent(stream, size = stream.level) {\n    const indent = stream.options['output.indent'];\n    push(stream, indent.repeat(Math.max(size, 0)));\n}\n/**\n * Pushes field/tabstop into output stream\n */\nfunction pushField(stream, index, placeholder) {\n    const field = stream.options['output.field'];\n    // NB: use `_push` instead of `push` to skip text processing\n    _push(stream, field(index, placeholder, stream.offset, stream.line, stream.column));\n}\n/**\n * Returns given tag name formatted according to given config\n */\nfunction tagName(name, config) {\n    return strCase(name, config.options['output.tagCase']);\n}\n/**\n * Returns given attribute name formatted according to given config\n */\nfunction attrName(name, config) {\n    return strCase(name, config.options['output.attributeCase']);\n}\n/**\n * Returns character for quoting value of given attribute\n */\nfunction attrQuote(attr, config, isOpen) {\n    if (attr.valueType === 'expression') {\n        return isOpen ? '{' : '}';\n    }\n    return config.options['output.attributeQuotes'] === 'single' ? '\\'' : '\"';\n}\n/**\n * Check if given attribute is boolean\n */\nfunction isBooleanAttribute(attr, config) {\n    return attr.boolean\n        || config.options['output.booleanAttributes'].includes((attr.name || '').toLowerCase());\n}\n/**\n * Returns a token for self-closing tag, depending on current options\n */\nfunction selfClose(config) {\n    switch (config.options['output.selfClosingStyle']) {\n        case 'xhtml': return ' /';\n        case 'xml': return '/';\n        default: return '';\n    }\n}\n/**\n * Check if given tag name belongs to inline-level element\n * @param node Parsed node or tag name\n */\nfunction isInline(node, config) {\n    if (typeof node === 'string') {\n        return config.options.inlineElements.includes(node.toLowerCase());\n    }\n    // inline node is a node either with inline-level name or text-only node\n    return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);\n}\n/**\n * Splits given text by lines\n */\nfunction splitByLines(text) {\n    return text.split(/\\r\\n|\\r|\\n/g);\n}\n/**\n * Pushes raw string into output stream without any processing\n */\nfunction _push(stream, text) {\n    stream.value += text;\n    stream.offset += text.length;\n    stream.column += text.length;\n}\nfunction strCase(str, type) {\n    if (type) {\n        return type === 'upper' ? str.toUpperCase() : str.toLowerCase();\n    }\n    return str;\n}\n\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\nfunction implicitTag(node, ancestors, config) {\n    if (!node.name && node.attributes) {\n        resolveImplicitTag(node, ancestors, config);\n    }\n}\nfunction resolveImplicitTag(node, ancestors, config) {\n    const parent = getParentElement(ancestors);\n    const contextName = config.context ? config.context.name : '';\n    const parentName = lowercase(parent ? parent.name : contextName);\n    node.name = elementMap[parentName]\n        || (isInline(parentName, config) ? 'span' : 'div');\n}\nfunction lowercase(str) {\n    return (str || '').toLowerCase();\n}\n/**\n * Returns closest element node from given ancestors list\n */\nfunction getParentElement(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const elem = ancestors[i];\n        if (isNode(elem)) {\n            return elem;\n        }\n    }\n}\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst vocabularies = { ru, sp, latin };\nconst reLorem = /^lorem([a-z]*)(\\d*)(-\\d*)?$/i;\nfunction lorem(node, ancestors, config) {\n    let m;\n    if (node.name && (m = node.name.match(reLorem))) {\n        const db = vocabularies[m[1]] || vocabularies.latin;\n        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;\n        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;\n        const wordCount = rand(minWordCount, maxWordCount);\n        const repeat = node.repeat || findRepeater(ancestors);\n        node.name = node.attributes = void 0;\n        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];\n        if (node.repeat && ancestors.length > 1) {\n            resolveImplicitTag(node, ancestors, config);\n        }\n    }\n}\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n */\nfunction rand(from, to) {\n    return Math.floor(Math.random() * (to - from) + from);\n}\nfunction sample(arr, count) {\n    const len = arr.length;\n    const iterations = Math.min(len, count);\n    const result = [];\n    while (result.length < iterations) {\n        const str = arr[rand(0, len)];\n        if (!result.includes(str)) {\n            result.push(str);\n        }\n    }\n    return result;\n}\nfunction choice(val) {\n    return val[rand(0, val.length - 1)];\n}\nfunction sentence(words, end) {\n    if (words.length) {\n        words = [capitalize(words[0])].concat(words.slice(1));\n    }\n    return words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\nfunction capitalize(word) {\n    return word[0].toUpperCase() + word.slice(1);\n}\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside `words` array\n */\nfunction insertCommas(words) {\n    if (words.length < 2) {\n        return words;\n    }\n    words = words.slice();\n    const len = words.length;\n    const hasComma = /,$/;\n    let totalCommas = 0;\n    if (len > 3 && len <= 6) {\n        totalCommas = rand(0, 1);\n    }\n    else if (len > 6 && len <= 12) {\n        totalCommas = rand(0, 2);\n    }\n    else {\n        totalCommas = rand(1, 4);\n    }\n    for (let i = 0, pos; i < totalCommas; i++) {\n        pos = rand(0, len - 2);\n        if (!hasComma.test(words[pos])) {\n            words[pos] += ',';\n        }\n    }\n    return words;\n}\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param dict Words dictionary\n * @param wordCount Words count in paragraph\n * @param startWithCommon Should paragraph start with common \"lorem ipsum\" sentence.\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n    const result = [];\n    let totalWords = 0;\n    let words;\n    if (startWithCommon && dict.common) {\n        words = dict.common.slice(0, wordCount);\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words), '.'));\n    }\n    while (totalWords < wordCount) {\n        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words)));\n    }\n    return result.join(' ');\n}\nfunction findRepeater(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const element = ancestors[i];\n        if (element.type === 'AbbreviationNode' && element.repeat) {\n            return element.repeat;\n        }\n    }\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nfunction jsx(node) {\n    if (node.attributes) {\n        node.attributes.forEach(rename);\n    }\n}\nfunction rename(attr) {\n    if (attr.name === 'class') {\n        attr.name = 'className';\n    }\n    else if (attr.name === 'for') {\n        attr.name = 'htmlFor';\n    }\n}\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nfunction xsl(node) {\n    if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {\n        node.attributes = node.attributes.filter(isAllowed);\n    }\n}\nfunction isAllowed(attr) {\n    return attr.name !== 'select';\n}\nfunction matchesName(name) {\n    return name === 'xsl:variable' || name === 'xsl:with-param';\n}\n\nconst reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = (className) => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = (className) => /^[a-z]/i.test(className);\nfunction bem(node, ancestors, config) {\n    expandClassNames(node);\n    expandShortNotation(node, ancestors, config);\n}\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n */\nfunction expandClassNames(node) {\n    const data = getBEMData(node);\n    const classNames = [];\n    for (const cl of data.classNames) {\n        // remove all modifiers and element prefixes from class name to get a base element name\n        const ix = cl.indexOf('_');\n        if (ix > 0 && !cl.startsWith('-')) {\n            classNames.push(cl.slice(0, ix));\n            classNames.push(cl.slice(ix));\n        }\n        else {\n            classNames.push(cl);\n        }\n    }\n    if (classNames.length) {\n        data.classNames = classNames.filter(uniqueClass);\n        data.block = findBlockName(data.classNames);\n        updateClass(node, data.classNames.join(' '));\n    }\n}\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n */\nfunction expandShortNotation(node, ancestors, config) {\n    const data = getBEMData(node);\n    const classNames = [];\n    const { options } = config;\n    const path = ancestors.slice(1).concat(node);\n    for (let cl of data.classNames) {\n        let prefix = '';\n        let m;\n        const originalClass = cl;\n        // parse element definition (could be only one)\n        if (m = cl.match(reElement)) {\n            prefix = getBlockName(path, m[1].length, config.context) + options['bem.element'] + m[2];\n            classNames.push(prefix);\n            cl = cl.slice(m[0].length);\n        }\n        // parse modifiers definitions\n        if (m = cl.match(reModifier)) {\n            if (!prefix) {\n                prefix = getBlockName(path, m[1].length);\n                classNames.push(prefix);\n            }\n            classNames.push(`${prefix}${options['bem.modifier']}${m[2]}`);\n            cl = cl.slice(m[0].length);\n        }\n        if (cl === originalClass) {\n            // class name wasn’t modified: it’s not a BEM-specific class,\n            // add it as-is into output\n            classNames.push(originalClass);\n        }\n    }\n    const arrClassNames = classNames.filter(uniqueClass);\n    if (arrClassNames.length) {\n        updateClass(node, arrClassNames.join(' '));\n    }\n}\n/**\n * Returns BEM data from given abbreviation node\n */\nfunction getBEMData(node) {\n    if (!node._bem) {\n        let classValue = '';\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (attr.name === 'class' && attr.value) {\n                    classValue = stringifyValue(attr.value);\n                    break;\n                }\n            }\n        }\n        node._bem = parseBEM(classValue);\n    }\n    return node._bem;\n}\nfunction getBEMDataFromContext(context) {\n    if (!context._bem) {\n        context._bem = parseBEM(context.attributes && context.attributes.class || '');\n    }\n    return context._bem;\n}\n/**\n * Parses BEM data from given class name\n */\nfunction parseBEM(classValue) {\n    const classNames = classValue ? classValue.split(/\\s+/) : [];\n    return {\n        classNames,\n        block: findBlockName(classNames)\n    };\n}\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n */\nfunction getBlockName(ancestors, depth = 0, context) {\n    const maxParentIx = 0;\n    let parentIx = Math.max(ancestors.length - depth, maxParentIx);\n    do {\n        const parent = ancestors[parentIx];\n        if (parent) {\n            const data = getBEMData(parent);\n            if (data.block) {\n                return data.block;\n            }\n        }\n    } while (maxParentIx < parentIx--);\n    if (context) {\n        const data = getBEMDataFromContext(context);\n        if (data.block) {\n            return data.block;\n        }\n    }\n    return '';\n}\nfunction findBlockName(classNames) {\n    return find(classNames, blockCandidates1)\n        || find(classNames, blockCandidates2)\n        || void 0;\n}\n/**\n * Finds class name from given list which may be used as block name\n */\nfunction find(classNames, filter) {\n    for (const cl of classNames) {\n        if (reElement.test(cl) || reModifier.test(cl)) {\n            break;\n        }\n        if (filter(cl)) {\n            return cl;\n        }\n    }\n}\nfunction updateClass(node, value) {\n    for (const attr of node.attributes) {\n        if (attr.name === 'class') {\n            attr.value = [value];\n            break;\n        }\n    }\n}\nfunction stringifyValue(value) {\n    let result = '';\n    for (const t of value) {\n        result += typeof t === 'string' ? t : t.name;\n    }\n    return result;\n}\nfunction uniqueClass(item, ix, arr) {\n    return !!item && arr.indexOf(item) === ix;\n}\n\nfunction walk$1(abbr, visitor, state) {\n    const callback = (ctx, index, items) => {\n        const { parent, current } = state;\n        state.parent = current;\n        state.current = ctx;\n        visitor(ctx, index, items, state, next);\n        state.current = current;\n        state.parent = parent;\n    };\n    const next = (node, index, items) => {\n        state.ancestors.push(state.current);\n        callback(node, index, items);\n        state.ancestors.pop();\n    };\n    abbr.children.forEach(callback);\n}\nfunction createWalkState(config) {\n    return {\n        // @ts-ignore: Will set value in iterator\n        current: null,\n        parent: void 0,\n        ancestors: [],\n        config,\n        field: 1,\n        out: createOutputStream(config.options)\n    };\n}\n\nconst caret = [{ type: 'Field', index: 0, name: '' }];\n/**\n * Check if given node is a snippet: a node without name and attributes\n */\nfunction isSnippet(node) {\n    return node ? !node.name && !node.attributes : false;\n}\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n */\nfunction isInlineElement(node, config) {\n    return node ? isInline(node, config) : false;\n}\n/**\n * Check if given value token is a field\n */\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field';\n}\nfunction pushTokens(tokens, state) {\n    const { out } = state;\n    let largestIndex = -1;\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            pushString(out, t);\n        }\n        else {\n            pushField(out, state.field + t.index, t.name);\n            if (t.index > largestIndex) {\n                largestIndex = t.index;\n            }\n        }\n    }\n    if (largestIndex !== -1) {\n        state.field += largestIndex + 1;\n    }\n}\n/**\n * Splits given value token by lines: returns array where each entry is a token list\n * for a single line\n */\nfunction splitByLines$1(tokens) {\n    const result = [];\n    let line = [];\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            const lines = t.split(/\\r\\n?|\\n/g);\n            line.push(lines.shift() || '');\n            while (lines.length) {\n                result.push(line);\n                line = [lines.shift() || ''];\n            }\n        }\n        else {\n            line.push(t);\n        }\n    }\n    line.length && result.push(line);\n    return result;\n}\n/**\n * Check if given attribute should be outputted\n */\nfunction shouldOutputAttribute(attr) {\n    // In case if attribute is implied, check if it has a defined value:\n    // either non-empty value or quoted empty value\n    return !attr.implied || attr.valueType !== 'raw' || (!!attr.value && attr.value.length > 0);\n}\n\n/**\n * Splits given string into template tokens.\n * Template is a string which contains placeholders which are uppercase names\n * between `[` and `]`, for example: `[PLACEHOLDER]`.\n * Unlike other templates, a placeholder may contain extra characters before and\n * after name: `[%PLACEHOLDER.]`. If data for `PLACEHOLDER` is defined, it will\n * be outputted with with these extra character, otherwise will be completely omitted.\n */\nfunction template(text) {\n    const tokens = [];\n    const scanner = { pos: 0, text };\n    let placeholder;\n    let offset = scanner.pos;\n    let pos = scanner.pos;\n    while (scanner.pos < scanner.text.length) {\n        pos = scanner.pos;\n        if (placeholder = consumePlaceholder(scanner)) {\n            if (offset !== scanner.pos) {\n                tokens.push(text.slice(offset, pos));\n            }\n            tokens.push(placeholder);\n            offset = scanner.pos;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n    if (offset !== scanner.pos) {\n        tokens.push(text.slice(offset));\n    }\n    return tokens;\n}\n/**\n * Consumes placeholder like `[#ID]` from given scanner\n */\nfunction consumePlaceholder(scanner) {\n    if (peek(scanner) === 91 /* Start */) {\n        const start = ++scanner.pos;\n        let namePos = start;\n        let afterPos = start;\n        let stack = 1;\n        while (scanner.pos < scanner.text.length) {\n            const code = peek(scanner);\n            if (isTokenStart(code)) {\n                namePos = scanner.pos;\n                while (isToken(peek(scanner))) {\n                    scanner.pos++;\n                }\n                afterPos = scanner.pos;\n            }\n            else {\n                if (code === 91 /* Start */) {\n                    stack++;\n                }\n                else if (code === 93 /* End */) {\n                    if (--stack === 0) {\n                        return {\n                            before: scanner.text.slice(start, namePos),\n                            after: scanner.text.slice(afterPos, scanner.pos++),\n                            name: scanner.text.slice(namePos, afterPos)\n                        };\n                    }\n                }\n                scanner.pos++;\n            }\n        }\n    }\n}\nfunction peek(scanner, pos = scanner.pos) {\n    return scanner.text.charCodeAt(pos);\n}\nfunction isTokenStart(code) {\n    return code >= 65 && code <= 90; // A-Z\n}\nfunction isToken(code) {\n    return isTokenStart(code)\n        || (code > 47 && code < 58) /* 0-9 */\n        || code === 95 /* Underscore */\n        || code === 45 /* Dash */;\n}\n\nfunction createCommentState(config) {\n    const { options } = config;\n    return {\n        enabled: options['comment.enabled'],\n        trigger: options['comment.trigger'],\n        before: options['comment.before'] ? template(options['comment.before']) : void 0,\n        after: options['comment.after'] ? template(options['comment.after']) : void 0\n    };\n}\n/**\n * Adds comment prefix for given node, if required\n */\nfunction commentNodeBefore(node, state) {\n    if (shouldComment(node, state) && state.comment.before) {\n        output(node, state.comment.before, state);\n    }\n}\n/**\n * Adds comment suffix for given node, if required\n */\nfunction commentNodeAfter(node, state) {\n    if (shouldComment(node, state) && state.comment.after) {\n        output(node, state.comment.after, state);\n    }\n}\n/**\n * Check if given node should be commented\n */\nfunction shouldComment(node, state) {\n    const { comment } = state;\n    if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {\n        return false;\n    }\n    for (const attr of node.attributes) {\n        if (attr.name && comment.trigger.includes(attr.name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Pushes given template tokens into output stream\n */\nfunction output(node, tokens, state) {\n    const attrs = {};\n    const { out } = state;\n    // Collect attributes payload\n    for (const attr of node.attributes) {\n        if (attr.name && attr.value) {\n            attrs[attr.name.toUpperCase()] = attr.value;\n        }\n    }\n    // Output parsed tokens\n    for (const token of tokens) {\n        if (typeof token === 'string') {\n            pushString(out, token);\n        }\n        else if (attrs[token.name]) {\n            pushString(out, token.before);\n            pushTokens(attrs[token.name], state);\n            pushString(out, token.after);\n        }\n    }\n}\n\nconst htmlTagRegex = /^<([\\w\\-:]+)[\\s>]/;\nfunction html(abbr, config) {\n    const state = createWalkState(config);\n    state.comment = createCommentState(config);\n    walk$1(abbr, element, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element(node, index, items, state, next) {\n    const { out, config } = state;\n    const format = shouldFormat(node, index, items, state);\n    // Pick offset level for current node\n    const level = getIndent(state);\n    out.level += level;\n    format && pushNewline(out, true);\n    if (node.name) {\n        const name = tagName(node.name, config);\n        commentNodeBefore(node, state);\n        pushString(out, `<${name}`);\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (shouldOutputAttribute(attr)) {\n                    pushAttribute(attr, state);\n                }\n            }\n        }\n        if (node.selfClosing && !node.children.length && !node.value) {\n            pushString(out, `${selfClose(config)}>`);\n        }\n        else {\n            pushString(out, '>');\n            if (!pushSnippet(node, state, next)) {\n                if (node.value) {\n                    const innerFormat = node.value.some(hasNewline) || startsWithBlockTag(node.value, config);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(node.value, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n                node.children.forEach(next);\n                if (!node.value && !node.children.length) {\n                    const innerFormat = config.options['output.formatLeafNode']\n                        || config.options['output.formatForce'].includes(node.name);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(caret, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n            }\n            pushString(out, `</${name}>`);\n            commentNodeAfter(node, state);\n        }\n    }\n    else if (!pushSnippet(node, state, next) && node.value) {\n        // A text-only node (snippet)\n        pushTokens(node.value, state);\n        node.children.forEach(next);\n    }\n    if (format && index === items.length - 1 && state.parent) {\n        const offset = isSnippet(state.parent) ? 0 : 1;\n        pushNewline(out, out.level - offset);\n    }\n    out.level -= level;\n}\n/**\n * Outputs given attribute’s content into output stream\n */\nfunction pushAttribute(attr, state) {\n    const { out, config } = state;\n    if (attr.name) {\n        const name = attrName(attr.name, config);\n        const lQuote = attrQuote(attr, config, true);\n        const rQuote = attrQuote(attr, config);\n        let value = attr.value;\n        if (isBooleanAttribute(attr, config) && !value) {\n            // If attribute value is omitted and it’s a boolean value, check for\n            // `compactBoolean` option: if it’s disabled, set value to attribute name\n            // (XML style)\n            if (!config.options['output.compactBoolean']) {\n                value = [name];\n            }\n        }\n        else if (!value) {\n            value = caret;\n        }\n        pushString(out, ' ' + name);\n        if (value) {\n            pushString(out, '=' + lQuote);\n            pushTokens(value, state);\n            pushString(out, rQuote);\n        }\n        else if (config.options['output.selfClosingStyle'] !== 'html') {\n            pushString(out, '=' + lQuote + rQuote);\n        }\n    }\n}\nfunction pushSnippet(node, state, next) {\n    if (node.value && node.children.length) {\n        // We have a value and child nodes. In case if value contains fields,\n        // we should output children as a content of first field\n        const fieldIx = node.value.findIndex(isField);\n        if (fieldIx !== -1) {\n            pushTokens(node.value.slice(0, fieldIx), state);\n            const line = state.out.line;\n            let pos = fieldIx + 1;\n            node.children.forEach(next);\n            // If there was a line change, trim leading whitespace for better result\n            if (state.out.line !== line && typeof node.value[pos] === 'string') {\n                pushString(state.out, node.value[pos++].trimLeft());\n            }\n            pushTokens(node.value.slice(pos), state);\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Check if given node should be formatted in its parent context\n */\nfunction shouldFormat(node, index, items, state) {\n    const { config, parent } = state;\n    if (!config.options['output.format']) {\n        return false;\n    }\n    if (index === 0 && !parent) {\n        // Do not format very first node\n        return false;\n    }\n    // Do not format single child of snippet\n    if (parent && isSnippet(parent) && items.length === 1) {\n        return false;\n    }\n    /**\n     * Adjacent text-only/snippet nodes\n     */\n    if (isSnippet(node)) {\n        // Adjacent text-only/snippet nodes\n        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1])\n            // Has newlines: looks like wrapping code fragment\n            || node.value.some(hasNewline)\n            // Format as wrapper: contains children which will be outputted as field content\n            || (node.value.some(isField) && node.children.length);\n        if (format) {\n            return true;\n        }\n    }\n    if (isInline(node, config)) {\n        // Check if inline node is the next sibling of block-level node\n        if (index === 0) {\n            // First node in parent: format if it’s followed by a block-level element\n            for (let i = 0; i < items.length; i++) {\n                if (!isInline(items[i], config)) {\n                    return true;\n                }\n            }\n        }\n        else if (!isInline(items[index - 1], config)) {\n            // Node is right after block-level element\n            return true;\n        }\n        if (config.options['output.inlineBreak']) {\n            // check for adjacent inline elements before and after current element\n            let adjacentInline = 1;\n            let before = index;\n            let after = index;\n            while (isInlineElement(items[--before], config)) {\n                adjacentInline++;\n            }\n            while (isInlineElement(items[++after], config)) {\n                adjacentInline++;\n            }\n            if (adjacentInline >= config.options['output.inlineBreak']) {\n                return true;\n            }\n        }\n        // Edge case: inline node contains node that should receive formatting\n        for (let i = 0, il = node.children.length; i < il; i++) {\n            if (shouldFormat(node.children[i], i, node.children, state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Returns indentation offset for given node\n */\nfunction getIndent(state) {\n    const { config, parent } = state;\n    if (!parent || isSnippet(parent) || (parent.name && config.options['output.formatSkip'].includes(parent.name))) {\n        return 0;\n    }\n    return 1;\n}\n/**\n * Check if given node value contains newlines\n */\nfunction hasNewline(value) {\n    return typeof value === 'string' && /\\r|\\n/.test(value);\n}\n/**\n * Check if given node value starts with block-level tag\n */\nfunction startsWithBlockTag(value, config) {\n    if (value.length && typeof value[0] === 'string') {\n        const matches = htmlTagRegex.exec(value[0]);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) && !config.options['inlineElements'].includes(matches[1].toLowerCase())) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction indentFormat(abbr, config, options) {\n    const state = createWalkState(config);\n    state.options = options || {};\n    walk$1(abbr, element$1, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element$1(node, index, items, state, next) {\n    const { out, options } = state;\n    const { primary, secondary } = collectAttributes(node);\n    // Pick offset level for current node\n    const level = state.parent ? 1 : 0;\n    out.level += level;\n    // Do not indent top-level elements\n    if (shouldFormat$1(node, index, items, state)) {\n        pushNewline(out, true);\n    }\n    if (node.name && (node.name !== 'div' || !primary.length)) {\n        pushString(out, (options.beforeName || '') + node.name + (options.afterName || ''));\n    }\n    pushPrimaryAttributes(primary, state);\n    pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);\n    if (node.selfClosing && !node.value && !node.children.length) {\n        if (state.options.selfClose) {\n            pushString(out, state.options.selfClose);\n        }\n    }\n    else {\n        pushValue(node, state);\n        node.children.forEach(next);\n    }\n    out.level -= level;\n}\n/**\n * From given node, collects all attributes as `primary` (id, class) and\n * `secondary` (all the rest) lists. In most indent-based syntaxes, primary attribute\n * has special syntax\n */\nfunction collectAttributes(node) {\n    const primary = [];\n    const secondary = [];\n    if (node.attributes) {\n        for (const attr of node.attributes) {\n            if (isPrimaryAttribute(attr)) {\n                primary.push(attr);\n            }\n            else {\n                secondary.push(attr);\n            }\n        }\n    }\n    return { primary, secondary };\n}\n/**\n * Outputs given attributes as primary into output stream\n */\nfunction pushPrimaryAttributes(attrs, state) {\n    for (const attr of attrs) {\n        if (attr.value) {\n            if (attr.name === 'class') {\n                pushString(state.out, '.');\n                // All whitespace characters must be replaced with dots in class names\n                const tokens = attr.value.map(t => typeof t === 'string' ? t.replace(/\\s+/g, '.') : t);\n                pushTokens(tokens, state);\n            }\n            else {\n                // ID attribute\n                pushString(state.out, '#');\n                pushTokens(attr.value, state);\n            }\n        }\n    }\n}\n/**\n * Outputs given attributes as secondary into output stream\n */\nfunction pushSecondaryAttributes(attrs, state) {\n    if (attrs.length) {\n        const { out, config, options } = state;\n        options.beforeAttribute && pushString(out, options.beforeAttribute);\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            pushString(out, attrName(attr.name || '', config));\n            if (isBooleanAttribute(attr, config) && !attr.value) {\n                if (!config.options['output.compactBoolean'] && options.booleanValue) {\n                    pushString(out, '=' + options.booleanValue);\n                }\n            }\n            else {\n                pushString(out, '=' + attrQuote(attr, config, true));\n                pushTokens(attr.value || caret, state);\n                pushString(out, attrQuote(attr, config));\n            }\n            if (i !== attrs.length - 1 && options.glueAttribute) {\n                pushString(out, options.glueAttribute);\n            }\n        }\n        options.afterAttribute && pushString(out, options.afterAttribute);\n    }\n}\n/**\n * Outputs given node value into state output stream\n */\nfunction pushValue(node, state) {\n    // We should either output value or add caret but for leaf nodes only (no children)\n    if (!node.value && node.children.length) {\n        return;\n    }\n    const value = node.value || caret;\n    const lines = splitByLines$1(value);\n    const { out, options } = state;\n    if (lines.length === 1) {\n        if (node.name || node.attributes) {\n            push(out, ' ');\n        }\n        pushTokens(value, state);\n    }\n    else {\n        // We should format multi-line value with terminating `|` character\n        // and same line length\n        const lineLengths = [];\n        let maxLength = 0;\n        // Calculate lengths of all lines and max line length\n        for (const line of lines) {\n            const len = valueLength(line);\n            lineLengths.push(len);\n            if (len > maxLength) {\n                maxLength = len;\n            }\n        }\n        // Output each line, padded to max length\n        out.level++;\n        for (let i = 0; i < lines.length; i++) {\n            pushNewline(out, true);\n            options.beforeTextLine && push(out, options.beforeTextLine);\n            pushTokens(lines[i], state);\n            if (options.afterTextLine) {\n                push(out, ' '.repeat(maxLength - lineLengths[i]));\n                push(out, options.afterTextLine);\n            }\n        }\n        out.level--;\n    }\n}\nfunction isPrimaryAttribute(attr) {\n    return attr.name === 'class' || attr.name === 'id';\n}\n/**\n * Calculates string length from given tokens\n */\nfunction valueLength(tokens) {\n    let len = 0;\n    for (const token of tokens) {\n        len += typeof token === 'string' ? token.length : token.name.length;\n    }\n    return len;\n}\nfunction shouldFormat$1(node, index, items, state) {\n    // Do not format first top-level element or snippets\n    if (!state.parent && index === 0) {\n        return false;\n    }\n    return !isSnippet(node);\n}\n\nfunction haml(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeName: '%',\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ' ',\n        afterTextLine: ' |',\n        booleanValue: 'true',\n        selfClose: '/'\n    });\n}\n\nfunction slim(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: ' ',\n        glueAttribute: ' ',\n        beforeTextLine: '| ',\n        selfClose: '/'\n    });\n}\n\nfunction pug(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ', ',\n        beforeTextLine: '| ',\n        selfClose: config.options['output.selfClosingStyle'] === 'xml' ? '/' : ''\n    });\n}\n\nconst formatters = { html, haml, slim, pug };\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse(abbr, config) {\n    let oldTextValue;\n    if (typeof abbr === 'string') {\n        let parseOpt = config;\n        if (config.options['jsx.enabled']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { jsx: true });\n        }\n        if (config.options['markup.href']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { href: true });\n        }\n        abbr = parse$2(abbr, parseOpt);\n        // remove text field before snippets(abbr, config) call\n        // as abbreviation(abbr, parseOpt) already handled it\n        oldTextValue = config.text;\n        config.text = undefined;\n    }\n    // Run abbreviation resolve in two passes:\n    // 1. Map each node to snippets, which are abbreviations as well. A single snippet\n    // may produce multiple nodes\n    // 2. Transform every resolved node\n    abbr = resolveSnippets(abbr, config);\n    walk(abbr, transform, config);\n    config.text = oldTextValue !== null && oldTextValue !== void 0 ? oldTextValue : config.text;\n    return abbr;\n}\n/**\n * Converts given abbreviation to string according to provided `config`\n */\nfunction stringify(abbr, config) {\n    const formatter = formatters[config.syntax] || html;\n    return formatter(abbr, config);\n}\n/**\n * Modifies given node and prepares it for output\n */\nfunction transform(node, ancestors, config) {\n    implicitTag(node, ancestors, config);\n    mergeAttributes(node, config);\n    lorem(node, ancestors, config);\n    if (config.syntax === 'xsl') {\n        xsl(node);\n    }\n    if (config.options['jsx.enabled']) {\n        jsx(node);\n    }\n    if (config.options['bem.enabled']) {\n        bem(node, ancestors, config);\n    }\n}\n\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r;]+?);*)?$/;\nconst opt = { value: true };\n/**\n * Creates structure for holding resolved CSS snippet\n */\nfunction createSnippet(key, value) {\n    // A snippet could be a raw text snippet (e.g. arbitrary text string) or a\n    // CSS property with possible values separated by `|`.\n    // In latter case, we have to parse snippet as CSS abbreviation\n    const m = value.match(reProperty);\n    if (m) {\n        const keywords = {};\n        const parsed = m[2] ? m[2].split('|').map(parseValue) : [];\n        for (const item of parsed) {\n            for (const cssVal of item) {\n                collectKeywords(cssVal, keywords);\n            }\n        }\n        return {\n            type: \"Property\" /* Property */,\n            key,\n            property: m[1],\n            value: parsed,\n            keywords,\n            dependencies: []\n        };\n    }\n    return { type: \"Raw\" /* Raw */, key, value };\n}\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * `background-position-x` -> `background-position` -> `background`\n */\nfunction nest(snippets) {\n    snippets = snippets.slice().sort(snippetsSort);\n    const stack = [];\n    let prev;\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // background -> background-position -> background-position-x\n    for (const cur of snippets.filter(isProperty)) {\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n            if (cur.property.startsWith(prev.property)\n                && cur.property.charCodeAt(prev.property.length) === 45 /* - */) {\n                prev.dependencies.push(cur);\n                stack.push(cur);\n                break;\n            }\n            stack.pop();\n        }\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n    return snippets;\n}\n/**\n * A sorting function for array of snippets\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n    return a.key < b.key ? -1 : 1;\n}\nfunction parseValue(value) {\n    return parse$3(value.trim(), opt)[0].value;\n}\nfunction isProperty(snippet) {\n    return snippet.type === \"Property\" /* Property */;\n}\nfunction collectKeywords(cssVal, dest) {\n    for (const v of cssVal.value) {\n        if (v.type === 'Literal') {\n            dest[v.value] = v;\n        }\n        else if (v.type === 'FunctionCall') {\n            dest[v.name] = v;\n        }\n        else if (v.type === 'Field') {\n            // Create literal from field, if available\n            const value = v.name.trim();\n            if (value) {\n                dest[value] = { type: 'Literal', value };\n            }\n        }\n    }\n}\n\n/**\n * Calculates how close `str1` matches `str2` using fuzzy match.\n * How matching works:\n * – first characters of both `str1` and `str2` *must* match\n * – `str1` length larger than `str2` length is allowed only when `unmatched` is true\n * – ideal match is when `str1` equals to `str2` (score: 1)\n * – next best match is `str2` starts with `str1` (score: 1 × percent of matched characters)\n * – other scores depend on how close characters of `str1` to the beginning of `str2`\n * @param partialMatch Allow length `str1` to be greater than `str2` length\n */\nfunction scoreMatch(str1, str2, partialMatch = false) {\n    str1 = str1.toLowerCase();\n    str2 = str2.toLowerCase();\n    if (str1 === str2) {\n        return 1;\n    }\n    // Both strings MUST start with the same character\n    if (!str1 || !str2 || str1.charCodeAt(0) !== str2.charCodeAt(0)) {\n        return 0;\n    }\n    const str1Len = str1.length;\n    const str2Len = str2.length;\n    if (!partialMatch && str1Len > str2Len) {\n        return 0;\n    }\n    // Characters from `str1` which are closer to the beginning of a `str2` should\n    // have higher score.\n    // For example, if `str2` is `abcde`, it’s max score is:\n    // 5 + 4 + 3 + 2 + 1 = 15 (sum of character positions in reverse order)\n    // Matching `abd` against `abcde` should produce:\n    // 5 + 4 + 2 = 11\n    // Acronym bonus for match right after `-`. Matching `abd` against `abc-de`\n    // should produce:\n    // 6 + 5 + 4 (use `d` position in `abd`, not in abc-de`)\n    const minLength = Math.min(str1Len, str2Len);\n    const maxLength = Math.max(str1Len, str2Len);\n    let i = 1;\n    let j = 1;\n    let score = maxLength;\n    let ch1 = 0;\n    let ch2 = 0;\n    let found = false;\n    let acronym = false;\n    while (i < str1Len) {\n        ch1 = str1.charCodeAt(i);\n        found = false;\n        acronym = false;\n        while (j < str2Len) {\n            ch2 = str2.charCodeAt(j);\n            if (ch1 === ch2) {\n                found = true;\n                score += maxLength - (acronym ? i : j);\n                break;\n            }\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === 45 /* - */;\n            j++;\n        }\n        if (!found) {\n            if (!partialMatch) {\n                return 0;\n            }\n            break;\n        }\n        i++;\n    }\n    const matchRatio = i / maxLength;\n    const delta = maxLength - minLength;\n    const maxScore = sum(maxLength) - sum(delta);\n    return (score * matchRatio) / maxScore;\n}\n/**\n * Calculates sum of first `n` numbers, e.g. 1+2+3+...n\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nfunction color(token, shortHex) {\n    if (!token.r && !token.g && !token.b && !token.a) {\n        return 'transparent';\n    }\n    else if (token.a === 1) {\n        return asHex(token, shortHex);\n    }\n    return asRGB(token);\n}\n/**\n * Output given color as hex value\n * @param short Produce short value (e.g. #fff instead of #ffffff), if possible\n */\nfunction asHex(token, short) {\n    const fn = (short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b))\n        ? toShortHex : toHex;\n    return '#' + fn(token.r) + fn(token.g) + fn(token.b);\n}\n/**\n * Output current color as `rgba?(...)` CSS color\n */\nfunction asRGB(token) {\n    const values = [token.r, token.g, token.b];\n    if (token.a !== 1) {\n        values.push(frac(token.a, 8));\n    }\n    return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n}\nfunction frac(num, digits = 4) {\n    return num.toFixed(digits).replace(/\\.?0+$/, '');\n}\nfunction isShortHex(hex) {\n    return !(hex % 17);\n}\nfunction toShortHex(num) {\n    return (num >> 4).toString(16);\n}\nfunction toHex(num) {\n    return pad(num.toString(16), 2);\n}\nfunction pad(value, len) {\n    while (value.length < len) {\n        value = '0' + value;\n    }\n    return value;\n}\n\nfunction css(abbr, config) {\n    var _a;\n    const out = createOutputStream(config.options);\n    const format = config.options['output.format'];\n    if (((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === \"@@section\" /* Section */) {\n        // For section context, filter out unmatched snippets\n        abbr = abbr.filter(node => node.snippet);\n    }\n    for (let i = 0; i < abbr.length; i++) {\n        if (format && i !== 0) {\n            pushNewline(out, true);\n        }\n        property(abbr[i], out, config);\n    }\n    return out.value;\n}\n/**\n * Outputs given abbreviation node into output stream\n */\nfunction property(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    if (node.name) {\n        // It’s a CSS property\n        const name = isJSON ? toCamelCase(node.name) : node.name;\n        pushString(out, name + config.options['stylesheet.between']);\n        if (node.value.length) {\n            propertyValue(node, out, config);\n        }\n        else {\n            pushField(out, 0, '');\n        }\n        if (isJSON) {\n            // For CSS-in-JS, always finalize property with comma\n            // NB: seems like `important` is not available in CSS-in-JS syntaxes\n            push(out, ',');\n        }\n        else {\n            outputImportant(node, out, true);\n            push(out, config.options['stylesheet.after']);\n        }\n    }\n    else {\n        // It’s a regular snippet, output plain tokens without any additional formatting\n        for (const cssVal of node.value) {\n            for (const v of cssVal.value) {\n                outputToken(v, out, config);\n            }\n        }\n        outputImportant(node, out, node.value.length > 0);\n    }\n}\nfunction propertyValue(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    const num = isJSON ? getSingleNumeric(node) : null;\n    if (num && (!num.unit || num.unit === 'px')) {\n        // For CSS-in-JS, if property contains single numeric value, output it\n        // as JS number\n        push(out, String(num.value));\n    }\n    else {\n        const quote = getQuote(config);\n        isJSON && push(out, quote);\n        for (let i = 0; i < node.value.length; i++) {\n            if (i !== 0) {\n                push(out, ', ');\n            }\n            outputValue(node.value[i], out, config);\n        }\n        isJSON && push(out, quote);\n    }\n}\nfunction outputImportant(node, out, separator) {\n    if (node.important) {\n        if (separator) {\n            push(out, ' ');\n        }\n        push(out, '!important');\n    }\n}\nfunction outputValue(value, out, config) {\n    for (let i = 0, prevEnd = -1; i < value.value.length; i++) {\n        const token = value.value[i];\n        // Handle edge case: a field is written close to previous token like this: `foo${bar}`.\n        // We should not add delimiter here\n        if (i !== 0 && (token.type !== 'Field' || token.start !== prevEnd)) {\n            push(out, ' ');\n        }\n        outputToken(token, out, config);\n        prevEnd = token['end'];\n    }\n}\nfunction outputToken(token, out, config) {\n    if (token.type === 'ColorValue') {\n        push(out, color(token, config.options['stylesheet.shortHex']));\n    }\n    else if (token.type === 'Literal') {\n        pushString(out, token.value);\n    }\n    else if (token.type === 'NumberValue') {\n        pushString(out, frac(token.value, 4) + token.unit);\n    }\n    else if (token.type === 'StringValue') {\n        const quote = token.quote === 'double' ? '\"' : '\\'';\n        pushString(out, quote + token.value + quote);\n    }\n    else if (token.type === 'Field') {\n        pushField(out, token.index, token.name);\n    }\n    else if (token.type === 'FunctionCall') {\n        push(out, token.name + '(');\n        for (let i = 0; i < token.arguments.length; i++) {\n            if (i) {\n                push(out, ', ');\n            }\n            outputValue(token.arguments[i], out, config);\n        }\n        push(out, ')');\n    }\n}\n/**\n * If value of given property is a single numeric value, returns this token\n */\nfunction getSingleNumeric(node) {\n    if (node.value.length === 1) {\n        const cssVal = node.value[0];\n        if (cssVal.value.length === 1 && cssVal.value[0].type === 'NumberValue') {\n            return cssVal.value[0];\n        }\n    }\n}\n/**\n * Converts kebab-case string to camelCase\n */\nfunction toCamelCase(str) {\n    return str.replace(/\\-(\\w)/g, (_, letter) => letter.toUpperCase());\n}\nfunction getQuote(config) {\n    return config.options['stylesheet.jsonDoubleQuotes'] ? '\"' : '\\'';\n}\n\nconst gradientName = 'lg';\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse$1(abbr, config) {\n    var _a;\n    const snippets = ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.stylesheetSnippets) || convertSnippets(config.snippets);\n    if (config.cache) {\n        config.cache.stylesheetSnippets = snippets;\n    }\n    if (typeof abbr === 'string') {\n        abbr = parse$3(abbr, { value: isValueScope(config) });\n    }\n    const filteredSnippets = getSnippetsForScope(snippets, config);\n    for (const node of abbr) {\n        resolveNode(node, filteredSnippets, config);\n    }\n    return abbr;\n}\n/**\n * Converts given raw snippets into internal snippets representation\n */\nfunction convertSnippets(snippets) {\n    const result = [];\n    for (const key of Object.keys(snippets)) {\n        result.push(createSnippet(key, snippets[key]));\n    }\n    return nest(result);\n}\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n */\nfunction resolveNode(node, snippets, config) {\n    if (!resolveGradient(node, config)) {\n        const score = config.options['stylesheet.fuzzySearchMinScore'];\n        if (isValueScope(config)) {\n            // Resolve as value of given CSS property\n            const propName = config.context.name;\n            const snippet = snippets.find(s => s.type === \"Property\" /* Property */ && s.property === propName);\n            resolveValueKeywords(node, config, snippet, score);\n            node.snippet = snippet;\n        }\n        else if (node.name) {\n            const snippet = findBestMatch(node.name, snippets, score, true);\n            node.snippet = snippet;\n            if (snippet) {\n                if (snippet.type === \"Property\" /* Property */) {\n                    resolveAsProperty(node, snippet, config);\n                }\n                else {\n                    resolveAsSnippet(node, snippet);\n                }\n            }\n        }\n    }\n    if (node.name || config.context) {\n        // Resolve numeric values for CSS properties only\n        resolveNumericValue(node, config);\n    }\n    return node;\n}\n/**\n * Resolves CSS gradient shortcut from given property, if possible\n */\nfunction resolveGradient(node, config) {\n    let gradientFn = null;\n    const cssVal = node.value.length === 1 ? node.value[0] : null;\n    if (cssVal && cssVal.value.length === 1) {\n        const v = cssVal.value[0];\n        if (v.type === 'FunctionCall' && v.name === gradientName) {\n            gradientFn = v;\n        }\n    }\n    if (gradientFn || node.name === gradientName) {\n        if (!gradientFn) {\n            gradientFn = {\n                type: 'FunctionCall',\n                name: 'linear-gradient',\n                arguments: [cssValue(field(0, ''))]\n            };\n        }\n        else {\n            gradientFn = Object.assign(Object.assign({}, gradientFn), { name: 'linear-gradient' });\n        }\n        if (!config.context) {\n            node.name = 'background-image';\n        }\n        node.value = [cssValue(gradientFn)];\n        return true;\n    }\n    return false;\n}\n/**\n * Resolves given parsed abbreviation node as CSS property\n */\nfunction resolveAsProperty(node, snippet, config) {\n    const abbr = node.name;\n    // Check for unmatched part of abbreviation\n    // For example, in `dib` abbreviation the matched part is `d` and `ib` should\n    // be considered as inline value. If unmatched fragment exists, we should check\n    // if it matches actual value of snippet. If either explicit value is specified\n    // or unmatched fragment did not resolve to to a keyword, we should consider\n    // matched snippet as invalid\n    const inlineValue = getUnmatchedPart(abbr, snippet.key);\n    if (inlineValue) {\n        if (node.value.length) {\n            // Already have value: unmatched part indicates matched snippet is invalid\n            return node;\n        }\n        const kw = resolveKeyword(inlineValue, config, snippet);\n        if (!kw) {\n            return node;\n        }\n        node.value.push(cssValue(kw));\n    }\n    node.name = snippet.property;\n    if (node.value.length) {\n        // Replace keyword alias from current abbreviation node with matched keyword\n        resolveValueKeywords(node, config, snippet);\n    }\n    else if (snippet.value.length) {\n        const defaultValue = snippet.value[0];\n        // https://github.com/emmetio/emmet/issues/558\n        // We should auto-select inserted value only if there’s multiple value\n        // choice\n        node.value = snippet.value.length === 1 || defaultValue.some(hasField)\n            ? defaultValue\n            : defaultValue.map(n => wrapWithField(n, config));\n    }\n    return node;\n}\nfunction resolveValueKeywords(node, config, snippet, minScore) {\n    for (const cssVal of node.value) {\n        const value = [];\n        for (const token of cssVal.value) {\n            if (token.type === 'Literal') {\n                value.push(resolveKeyword(token.value, config, snippet, minScore) || token);\n            }\n            else if (token.type === 'FunctionCall') {\n                // For function calls, we should find matching function call\n                // and merge arguments\n                const match = resolveKeyword(token.name, config, snippet, minScore);\n                if (match && match.type === 'FunctionCall') {\n                    value.push(Object.assign(Object.assign({}, match), { arguments: token.arguments.concat(match.arguments.slice(token.arguments.length)) }));\n                }\n                else {\n                    value.push(token);\n                }\n            }\n            else {\n                value.push(token);\n            }\n        }\n        cssVal.value = value;\n    }\n}\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n */\nfunction resolveAsSnippet(node, snippet) {\n    // When resolving snippets, we have to do the following:\n    // 1. Replace field placeholders with actual field tokens.\n    // 2. If input values given, put them instead of fields\n    let offset = 0;\n    let m;\n    const reField = /\\$\\{(\\d+)(:[^}]+)?\\}/g;\n    const inputValue = node.value[0];\n    const outputValue = [];\n    while (m = reField.exec(snippet.value)) {\n        if (offset !== m.index) {\n            outputValue.push(literal(snippet.value.slice(offset, m.index)));\n        }\n        offset = m.index + m[0].length;\n        if (inputValue && inputValue.value.length) {\n            outputValue.push(inputValue.value.shift());\n        }\n        else {\n            outputValue.push(field(Number(m[1]), m[2] ? m[2].slice(1) : ''));\n        }\n    }\n    const tail = snippet.value.slice(offset);\n    if (tail) {\n        outputValue.push(literal(tail));\n    }\n    node.name = void 0;\n    node.value = [cssValue(...outputValue)];\n    return node;\n}\n/**\n * Finds best matching item from `items` array\n * @param abbr  Abbreviation to match\n * @param items List of items for match\n * @param minScore The minimum score the best matched item should have to be a valid match.\n */\nfunction findBestMatch(abbr, items, minScore = 0, partialMatch = false) {\n    let matchedItem = null;\n    let maxScore = 0;\n    for (const item of items) {\n        const score = scoreMatch(abbr, getScoringPart(item), partialMatch);\n        if (score === 1) {\n            // direct hit, no need to look further\n            return item;\n        }\n        if (score && score >= maxScore) {\n            maxScore = score;\n            matchedItem = item;\n        }\n    }\n    return maxScore >= minScore ? matchedItem : null;\n}\nfunction getScoringPart(item) {\n    return typeof item === 'string' ? item : item.key;\n}\n/**\n * Returns a part of `abbr` that wasn’t directly matched against `str`.\n * For example, if abbreviation `poas` is matched against `position`,\n * the unmatched part will be `as` since `a` wasn’t found in string stream\n */\nfunction getUnmatchedPart(abbr, str) {\n    for (let i = 0, lastPos = 0; i < abbr.length; i++) {\n        lastPos = str.indexOf(abbr[i], lastPos);\n        if (lastPos === -1) {\n            return abbr.slice(i);\n        }\n        lastPos++;\n    }\n    return '';\n}\n/**\n * Resolves given keyword shorthand into matched snippet keyword or global keyword,\n * if possible\n */\nfunction resolveKeyword(kw, config, snippet, minScore) {\n    let ref;\n    if (snippet) {\n        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {\n            return snippet.keywords[ref];\n        }\n        for (const dep of snippet.dependencies) {\n            if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {\n                return dep.keywords[ref];\n            }\n        }\n    }\n    if (ref = findBestMatch(kw, config.options['stylesheet.keywords'], minScore)) {\n        return literal(ref);\n    }\n    return null;\n}\n/**\n * Resolves numeric values in given abbreviation node\n */\nfunction resolveNumericValue(node, config) {\n    const aliases = config.options['stylesheet.unitAliases'];\n    const unitless = config.options['stylesheet.unitless'];\n    for (const v of node.value) {\n        for (const t of v.value) {\n            if (t.type === 'NumberValue') {\n                if (t.unit) {\n                    t.unit = aliases[t.unit] || t.unit;\n                }\n                else if (t.value !== 0 && !unitless.includes(node.name)) {\n                    t.unit = t.rawValue.includes('.')\n                        ? config.options['stylesheet.floatUnit']\n                        : config.options['stylesheet.intUnit'];\n                }\n            }\n        }\n    }\n}\n/**\n * Constructs CSS value token\n */\nfunction cssValue(...args) {\n    return {\n        type: 'CSSValue',\n        value: args\n    };\n}\n/**\n * Constructs literal token\n */\nfunction literal(value) {\n    return { type: 'Literal', value };\n}\n/**\n * Constructs field token\n */\nfunction field(index, name) {\n    return { type: 'Field', index, name };\n}\n/**\n * Check if given value contains fields\n */\nfunction hasField(value) {\n    for (const v of value.value) {\n        if (v.type === 'Field' || (v.type === 'FunctionCall' && v.arguments.some(hasField))) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Wraps tokens of given abbreviation with fields\n */\nfunction wrapWithField(node, config, state = { index: 1 }) {\n    let value = [];\n    for (const v of node.value) {\n        switch (v.type) {\n            case 'ColorValue':\n                value.push(field(state.index++, color(v, config.options['stylesheet.shortHex'])));\n                break;\n            case 'Literal':\n                value.push(field(state.index++, v.value));\n                break;\n            case 'NumberValue':\n                value.push(field(state.index++, `${v.value}${v.unit}`));\n                break;\n            case 'StringValue':\n                const q = v.quote === 'single' ? '\\'' : '\"';\n                value.push(field(state.index++, q + v.value + q));\n                break;\n            case 'FunctionCall':\n                value.push(field(state.index++, v.name), literal('('));\n                for (let i = 0, il = v.arguments.length; i < il; i++) {\n                    value = value.concat(wrapWithField(v.arguments[i], config, state).value);\n                    if (i !== il - 1) {\n                        value.push(literal(', '));\n                    }\n                }\n                value.push(literal(')'));\n                break;\n            default:\n                value.push(v);\n        }\n    }\n    return Object.assign(Object.assign({}, node), { value });\n}\n/**\n * Check if abbreviation should be expanded in CSS value context\n */\nfunction isValueScope(config) {\n    if (config.context) {\n        return config.context.name === \"@@value\" /* Value */ || !config.context.name.startsWith('@@');\n    }\n    return false;\n}\n/**\n * Returns snippets for given scope\n */\nfunction getSnippetsForScope(snippets, config) {\n    if (config.context) {\n        if (config.context.name === \"@@section\" /* Section */) {\n            return snippets.filter(s => s.type === \"Raw\" /* Raw */);\n        }\n        if (config.context.name === \"@@property\" /* Property */) {\n            return snippets.filter(s => s.type === \"Property\" /* Property */);\n        }\n    }\n    return snippets;\n}\n\nvar markupSnippets = {\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:btn|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"sum\": \"summary\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta[http-equiv='X-UA-Compatible'][content='IE=edge']+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar stylesheetSnippets = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${2});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n\t\"cr\": \"color:rgb(${1:0}, ${2:0}, ${3:0})\",\n\t\"cra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, ${4:.5})\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|grid|inline-grid|subgrid|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"gtc\": \"grid-template-columns:repeat()|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat()|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op|opa\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xslSnippets = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar pugSnippets = {\n\t\"!!!\": \"{doctype html}\"\n};\n\nvar variables = {\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n};\n\n/**\n * Default syntaxes for abbreviation types\n */\nconst defaultSyntaxes = {\n    markup: 'html',\n    stylesheet: 'css'\n};\nconst defaultOptions = {\n    'inlineElements': [\n        'a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n        'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n        'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n        's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n        'textarea', 'tt', 'u', 'var'\n    ],\n    'output.indent': '\\t',\n    'output.baseIndent': '',\n    'output.newline': '\\n',\n    'output.tagCase': '',\n    'output.attributeCase': '',\n    'output.attributeQuotes': 'double',\n    'output.format': true,\n    'output.formatLeafNode': false,\n    'output.formatSkip': ['html'],\n    'output.formatForce': ['body'],\n    'output.inlineBreak': 3,\n    'output.compactBoolean': false,\n    'output.booleanAttributes': [\n        'contenteditable', 'seamless', 'async', 'autofocus',\n        'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n        'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n        'required', 'reversed', 'selected', 'typemustmatch'\n    ],\n    'output.reverseAttributes': false,\n    'output.selfClosingStyle': 'html',\n    'output.field': (index, placeholder) => placeholder,\n    'output.text': text => text,\n    'markup.href': true,\n    'comment.enabled': false,\n    'comment.trigger': ['id', 'class'],\n    'comment.before': '',\n    'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n    'bem.enabled': false,\n    'bem.element': '__',\n    'bem.modifier': '_',\n    'jsx.enabled': false,\n    'stylesheet.keywords': ['auto', 'inherit', 'unset', 'none'],\n    'stylesheet.unitless': ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'],\n    'stylesheet.shortHex': true,\n    'stylesheet.between': ': ',\n    'stylesheet.after': ';',\n    'stylesheet.intUnit': 'px',\n    'stylesheet.floatUnit': 'em',\n    'stylesheet.unitAliases': { e: 'em', p: '%', x: 'ex', r: 'rem' },\n    'stylesheet.json': false,\n    'stylesheet.jsonDoubleQuotes': false,\n    'stylesheet.fuzzySearchMinScore': 0\n};\nconst defaultConfig = {\n    type: 'markup',\n    syntax: 'html',\n    variables,\n    snippets: {},\n    options: defaultOptions\n};\n/**\n * Default per-syntax config\n */\nconst syntaxConfig = {\n    markup: {\n        snippets: parseSnippets(markupSnippets),\n    },\n    xhtml: {\n        options: {\n            'output.selfClosingStyle': 'xhtml'\n        }\n    },\n    xml: {\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    xsl: {\n        snippets: parseSnippets(xslSnippets),\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    jsx: {\n        options: {\n            'jsx.enabled': true\n        }\n    },\n    pug: {\n        snippets: parseSnippets(pugSnippets)\n    },\n    stylesheet: {\n        snippets: parseSnippets(stylesheetSnippets)\n    },\n    sass: {\n        options: {\n            'stylesheet.after': ''\n        }\n    },\n    stylus: {\n        options: {\n            'stylesheet.between': ' ',\n            'stylesheet.after': '',\n        }\n    }\n};\n/**\n * Parses raw snippets definitions with possibly multiple keys into a plan\n * snippet map\n */\nfunction parseSnippets(snippets) {\n    const result = {};\n    Object.keys(snippets).forEach(k => {\n        for (const name of k.split('|')) {\n            result[name] = snippets[k];\n        }\n    });\n    return result;\n}\nfunction resolveConfig(config = {}, globals = {}) {\n    const type = config.type || 'markup';\n    const syntax = config.syntax || defaultSyntaxes[type];\n    return Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { type,\n        syntax, variables: mergedData(type, syntax, 'variables', config, globals), snippets: mergedData(type, syntax, 'snippets', config, globals), options: mergedData(type, syntax, 'options', config, globals) });\n}\nfunction mergedData(type, syntax, key, config, globals = {}) {\n    const typeDefaults = syntaxConfig[type];\n    const typeOverride = globals[type];\n    const syntaxDefaults = syntaxConfig[syntax];\n    const syntaxOverride = globals[syntax];\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfig[key]), (typeDefaults && typeDefaults[key])), (syntaxDefaults && syntaxDefaults[key])), (typeOverride && typeOverride[key])), (syntaxOverride && syntaxOverride[key])), config[key]);\n}\n\n/**\n * Creates structure for scanning given string in backward direction\n */\nfunction backwardScanner(text, start = 0) {\n    return { text, start, pos: text.length };\n}\n/**\n * Check if given scanner position is at start of scanned text\n */\nfunction sol(scanner) {\n    return scanner.pos === scanner.start;\n}\n/**\n * “Peeks” character code an current scanner location without advancing it\n */\nfunction peek$1(scanner, offset = 0) {\n    return scanner.text.charCodeAt(scanner.pos - 1 + offset);\n}\n/**\n * Returns current character code and moves character location one symbol back\n */\nfunction previous(scanner) {\n    if (!sol(scanner)) {\n        return scanner.text.charCodeAt(--scanner.pos);\n    }\n}\n/**\n * Consumes current character code if it matches given `match` code or function\n */\nfunction consume(scanner, match) {\n    if (sol(scanner)) {\n        return false;\n    }\n    const ok = typeof match === 'function'\n        ? match(peek$1(scanner))\n        : match === peek$1(scanner);\n    if (ok) {\n        scanner.pos--;\n    }\n    return !!ok;\n}\nfunction consumeWhile(scanner, match) {\n    const start = scanner.pos;\n    while (consume(scanner, match)) {\n        // empty\n    }\n    return scanner.pos < start;\n}\n\n/**\n * Check if given character code is a quote\n */\nfunction isQuote(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\n/**\n * Consumes quoted value, if possible\n * @return Returns `true` is value was consumed\n */\nfunction consumeQuoted(scanner) {\n    const start = scanner.pos;\n    const quote = previous(scanner);\n    if (isQuote(quote)) {\n        while (!sol(scanner)) {\n            if (previous(scanner) === quote && peek$1(scanner) !== 92 /* Escape */) {\n                return true;\n            }\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n\nconst bracePairs = {\n    [91 /* SquareL */]: 93 /* SquareR */,\n    [40 /* RoundL */]: 41 /* RoundR */,\n    [123 /* CurlyL */]: 125 /* CurlyR */,\n};\n\n/**\n * Check if given reader’s current position points at the end of HTML tag\n */\nfunction isHtml(scanner) {\n    const start = scanner.pos;\n    if (!consume(scanner, 62 /* AngleRight */)) {\n        return false;\n    }\n    let ok = false;\n    consume(scanner, 47 /* Slash */); // possibly self-closed element\n    while (!sol(scanner)) {\n        consumeWhile(scanner, isWhiteSpace);\n        if (consumeIdent(scanner)) {\n            // ate identifier: could be a tag name, boolean attribute or unquoted\n            // attribute value\n            if (consume(scanner, 47 /* Slash */)) {\n                // either closing tag or invalid tag\n                ok = consume(scanner, 60 /* AngleLeft */);\n                break;\n            }\n            else if (consume(scanner, 60 /* AngleLeft */)) {\n                // opening tag\n                ok = true;\n                break;\n            }\n            else if (consume(scanner, isWhiteSpace)) {\n                // boolean attribute\n                continue;\n            }\n            else if (consume(scanner, 61 /* Equals */)) {\n                // simple unquoted value or invalid attribute\n                if (consumeIdent(scanner)) {\n                    continue;\n                }\n                break;\n            }\n            else if (consumeAttributeWithUnquotedValue(scanner)) {\n                // identifier was a part of unquoted value\n                ok = true;\n                break;\n            }\n            // invalid tag\n            break;\n        }\n        if (consumeAttribute(scanner)) {\n            continue;\n        }\n        break;\n    }\n    scanner.pos = start;\n    return ok;\n}\n/**\n * Consumes HTML attribute from given string.\n * @return `true` if attribute was consumed.\n */\nfunction consumeAttribute(scanner) {\n    return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);\n}\nfunction consumeAttributeWithQuotedValue(scanner) {\n    const start = scanner.pos;\n    if (consumeQuoted(scanner) && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\nfunction consumeAttributeWithUnquotedValue(scanner) {\n    const start = scanner.pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        const ch = peek$1(scanner);\n        if (isCloseBracket(ch)) {\n            stack.push(ch);\n        }\n        else if (isOpenBracket(ch)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // Unexpected open bracket\n                break;\n            }\n        }\n        else if (!isUnquotedValue(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (start !== scanner.pos && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes HTML identifier from stream\n */\nfunction consumeIdent(scanner) {\n    return consumeWhile(scanner, isIdent);\n}\n/**\n * Check if given character code belongs to HTML identifier\n */\nfunction isIdent(ch) {\n    return ch === 58 /* Colon */ || ch === 45 /* Dash */ || isAlpha(ch) || isNumber(ch);\n}\n/**\n * Check if given character code is alpha code (letter though A to Z)\n */\nfunction isAlpha(ch) {\n    ch &= ~32; // quick hack to convert any char code to uppercase char code\n    return ch >= 65 && ch <= 90; // A-Z\n}\n/**\n * Check if given code is a number\n */\nfunction isNumber(ch) {\n    return ch > 47 && ch < 58;\n}\n/**\n * Check if given code is a whitespace\n */\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* Space */ || ch === 9 /* Tab */;\n}\n/**\n * Check if given code may belong to unquoted attribute value\n */\nfunction isUnquotedValue(ch) {\n    return !isNaN(ch) && ch !== 61 /* Equals */ && !isWhiteSpace(ch) && !isQuote(ch);\n}\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyL */ || ch === 40 /* RoundL */ || ch === 91 /* SquareL */;\n}\nfunction isCloseBracket(ch) {\n    return ch === 125 /* CurlyR */ || ch === 41 /* RoundR */ || ch === 93 /* SquareR */;\n}\n\nconst code = (ch) => ch.charCodeAt(0);\nconst specialChars = '#.*:$-_!@%^+>/'.split('').map(code);\nconst defaultOptions$1 = {\n    type: 'markup',\n    lookAhead: true,\n    prefix: ''\n};\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editor’s line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param line A text line where abbreviation should be expanded\n * @param pos Caret position in line. If not given, uses end of line\n * @param options Extracting options\n */\nfunction extractAbbreviation(line, pos = line.length, options = {}) {\n    // make sure `pos` is within line range\n    const opt = Object.assign(Object.assign({}, defaultOptions$1), options);\n    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n    if (opt.lookAhead) {\n        pos = offsetPastAutoClosed(line, pos, opt);\n    }\n    let ch;\n    const start = getStartOffset(line, pos, opt.prefix || '');\n    if (start === -1) {\n        return void 0;\n    }\n    const scanner = backwardScanner(line, start);\n    scanner.pos = pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        ch = peek$1(scanner);\n        if (stack.includes(125 /* CurlyR */)) {\n            if (ch === 125 /* CurlyR */) {\n                stack.push(ch);\n                scanner.pos--;\n                continue;\n            }\n            if (ch !== 123 /* CurlyL */) {\n                scanner.pos--;\n                continue;\n            }\n        }\n        if (isCloseBrace(ch, opt.type)) {\n            stack.push(ch);\n        }\n        else if (isOpenBrace(ch, opt.type)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // unexpected brace\n                break;\n            }\n        }\n        else if (stack.includes(93 /* SquareR */) || stack.includes(125 /* CurlyR */)) {\n            // respect all characters inside attribute sets or text nodes\n            scanner.pos--;\n            continue;\n        }\n        else if (isHtml(scanner) || !isAbbreviation(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (!stack.length && scanner.pos !== pos) {\n        // Found something, remove some invalid symbols from the\n        // beginning and return abbreviation\n        const abbreviation = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, '');\n        return {\n            abbreviation,\n            location: pos - abbreviation.length,\n            start: options.prefix\n                ? start - options.prefix.length\n                : pos - abbreviation.length,\n            end: pos\n        };\n    }\n}\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n */\nfunction offsetPastAutoClosed(line, pos, options) {\n    // closing quote is allowed only as a next character\n    if (isQuote(line.charCodeAt(pos))) {\n        pos++;\n    }\n    // offset pointer until non-autoclosed character is found\n    while (isCloseBrace(line.charCodeAt(pos), options.type)) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: it’s nearest to `pos` location of `prefix` token\n */\nfunction getStartOffset(line, pos, prefix) {\n    if (!prefix) {\n        return 0;\n    }\n    const scanner = backwardScanner(line);\n    const compiledPrefix = prefix.split('').map(code);\n    scanner.pos = pos;\n    let result;\n    while (!sol(scanner)) {\n        if (consumePair(scanner, 93 /* SquareR */, 91 /* SquareL */) || consumePair(scanner, 125 /* CurlyR */, 123 /* CurlyL */)) {\n            continue;\n        }\n        result = scanner.pos;\n        if (consumeArray(scanner, compiledPrefix)) {\n            return result;\n        }\n        scanner.pos--;\n    }\n    return -1;\n}\n/**\n * Consumes full character pair, if possible\n */\nfunction consumePair(scanner, close, open) {\n    const start = scanner.pos;\n    if (consume(scanner, close)) {\n        while (!sol(scanner)) {\n            if (consume(scanner, open)) {\n                return true;\n            }\n            scanner.pos--;\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n */\nfunction consumeArray(scanner, arr) {\n    const start = scanner.pos;\n    let consumed = false;\n    for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {\n        if (!consume(scanner, arr[i])) {\n            break;\n        }\n        consumed = i === 0;\n    }\n    if (!consumed) {\n        scanner.pos = start;\n    }\n    return consumed;\n}\nfunction isAbbreviation(ch) {\n    return (ch > 64 && ch < 91) // uppercase letter\n        || (ch > 96 && ch < 123) // lowercase letter\n        || (ch > 47 && ch < 58) // number\n        || specialChars.includes(ch); // special character\n}\nfunction isOpenBrace(ch, syntax) {\n    return ch === 40 /* RoundL */ || (syntax === 'markup' && (ch === 91 /* SquareL */ || ch === 123 /* CurlyL */));\n}\nfunction isCloseBrace(ch, syntax) {\n    return ch === 41 /* RoundR */ || (syntax === 'markup' && (ch === 93 /* SquareR */ || ch === 125 /* CurlyR */));\n}\n\nfunction expandAbbreviation(abbr, config) {\n    const resolvedConfig = resolveConfig(config);\n    return resolvedConfig.type === 'stylesheet'\n        ? stylesheet(abbr, resolvedConfig)\n        : markup(abbr, resolvedConfig);\n}\n/**\n * Expands given *markup* abbreviation (e.g. regular Emmet abbreviation that\n * produces structured output like HTML) and outputs it according to options\n * provided in config\n */\nfunction markup(abbr, config) {\n    return stringify(parse(abbr, config), config);\n}\n/**\n * Expands given *stylesheet* abbreviation (a special Emmet abbreviation designed for\n * stylesheet languages like CSS, SASS etc.) and outputs it according to options\n * provided in config\n */\nfunction stylesheet(abbr, config) {\n    return css(parse$1(abbr, config), config);\n}\n\nexport default expandAbbreviation;\nexport { extractAbbreviation as extract, markup, parse as parseMarkup, parse$1 as parseStylesheet, convertSnippets as parseStylesheetSnippets, resolveConfig, stringify as stringifyMarkup, css as stringifyStylesheet, stylesheet };\n//# sourceMappingURL=emmet.es.js.map\n","import Scanner, { isSpace, isQuote } from '@emmetio/scanner';\n\n/**\n * Performs fast scan of given stylesheet (CSS, LESS, SCSS) source code and runs\n * callback for each token and its range found. The goal of this parser is to quickly\n * determine document structure: selector, property, value and block end.\n * It doesn’t provide detailed info about CSS atoms like compound selectors,\n * operators, quoted string etc. to reduce memory allocations: this data can be\n * parsed later on demand.\n */\nfunction scan(source, callback) {\n    const scanner = new Scanner(source);\n    const state = {\n        start: -1,\n        end: -1,\n        propertyStart: -1,\n        propertyEnd: -1,\n        propertyDelimiter: -1,\n        expression: 0,\n    };\n    let blockEnd;\n    const notify = (type, delimiter = scanner.start, start = state.start, end = state.end) => {\n        return callback(type, start, end, delimiter) === false;\n    };\n    while (!scanner.eof()) {\n        if (comment(scanner) || whitespace(scanner)) {\n            continue;\n        }\n        scanner.start = scanner.pos;\n        if ((blockEnd = scanner.eat(125 /* RightCurly */)) || scanner.eat(59 /* Semicolon */)) {\n            // Block or property end\n            if (state.propertyStart !== -1) {\n                // We have pending property\n                if (notify(\"propertyName\" /* PropertyName */, state.propertyDelimiter, state.propertyStart, state.propertyEnd)) {\n                    return;\n                }\n                if (state.start === -1) {\n                    // Explicit property value state: emit empty value\n                    state.start = state.end = scanner.start;\n                }\n                if (notify(\"propertyValue\" /* PropertyValue */)) {\n                    return;\n                }\n            }\n            else if (state.start !== -1 && notify(\"propertyName\" /* PropertyName */)) {\n                // Flush consumed token\n                return;\n            }\n            if (blockEnd) {\n                state.start = scanner.start;\n                state.end = scanner.pos;\n                if (notify(\"blockEnd\" /* BlockEnd */)) {\n                    return;\n                }\n            }\n            reset(state);\n        }\n        else if (scanner.eat(123 /* LeftCurly */)) {\n            // Block start\n            if (state.start === -1 && state.propertyStart === -1) {\n                // No consumed selector, emit empty value as selector start\n                state.start = state.end = scanner.pos;\n            }\n            if (state.propertyStart !== -1) {\n                // Now we know that value that looks like property name-value pair\n                // was actually a selector\n                state.start = state.propertyStart;\n            }\n            if (notify(\"selector\" /* Selector */)) {\n                return;\n            }\n            reset(state);\n        }\n        else if (scanner.eat(58 /* Colon */) && !isKnownSelectorColon(scanner, state)) {\n            // Colon could be one of the following:\n            // — property delimiter: `foo: bar`, must be in block context\n            // — variable delimiter: `$foo: bar`, could be anywhere\n            // — pseudo-selector: `a:hover`, could be anywhere (for LESS and SCSS)\n            // — media query expression: `min-width: 100px`, must be inside expression context\n            // Since I can’t easily detect `:` meaning for sure, we’ll update state\n            // to accumulate possible property name-value pair or selector\n            if (state.propertyStart === -1) {\n                state.propertyStart = state.start;\n            }\n            state.propertyEnd = state.end;\n            state.propertyDelimiter = scanner.pos - 1;\n            state.start = state.end = -1;\n        }\n        else {\n            if (state.start === -1) {\n                state.start = scanner.pos;\n            }\n            if (scanner.eat(40 /* LeftRound */)) {\n                state.expression++;\n            }\n            else if (scanner.eat(41 /* RightRound */)) {\n                state.expression--;\n            }\n            else if (!literal(scanner)) {\n                scanner.pos++;\n            }\n            state.end = scanner.pos;\n        }\n    }\n    if (state.propertyStart !== -1) {\n        // Pending property name\n        if (notify(\"propertyName\" /* PropertyName */, state.propertyDelimiter, state.propertyStart, state.propertyEnd)) {\n            return;\n        }\n    }\n    if (state.start !== -1) {\n        // There’s pending token in state\n        notify(state.propertyStart !== -1 ? \"propertyValue\" /* PropertyValue */ : \"propertyName\" /* PropertyName */, -1);\n    }\n}\nfunction whitespace(scanner) {\n    return scanner.eatWhile(isSpace);\n}\n/**\n * Consumes CSS comments from scanner: `/*  * /`\n * It’s possible that comment may not have closing part\n */\nfunction comment(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(47 /* Slash */) && scanner.eat(42 /* Asterisk */)) {\n        scanner.start = start;\n        while (!scanner.eof()) {\n            if (scanner.eat(42 /* Asterisk */)) {\n                if (scanner.eat(47 /* Slash */)) {\n                    return true;\n                }\n                continue;\n            }\n            scanner.pos++;\n        }\n        return true;\n    }\n    else {\n        scanner.pos = start;\n    }\n    return false;\n}\n/**\n * Consumes single- or double-quoted string literal\n */\nfunction literal(scanner) {\n    const ch = scanner.peek();\n    if (isQuote(ch)) {\n        scanner.start = scanner.pos++;\n        while (!scanner.eof()) {\n            if (scanner.eat(ch) || scanner.eat(10 /* LF */) || scanner.eat(13 /* CR */)) {\n                break;\n            }\n            // Skip escape character, if any\n            scanner.eat(92 /* Backslash */);\n            scanner.pos++;\n        }\n        // Do not throw if string is incomplete\n        return true;\n    }\n}\nfunction reset(state) {\n    state.start = state.end = state.propertyStart = state.propertyEnd = state.propertyDelimiter = -1;\n}\n/**\n * Check if current state is a known selector context for `:` delimiter\n */\nfunction isKnownSelectorColon(scanner, state) {\n    // Either inside expression like `(min-width: 10px)` or pseudo-element `::before`\n    return state.expression || scanner.eatWhile(58 /* Colon */);\n}\n\n// NB: no `Minus` operator, it must be handled differently\nconst operators = [\n    43 /* Plus */, 47 /* Division */, 42 /* Multiplication */,\n    44 /* Comma */\n];\n/**\n * Splits given CSS value into token list\n */\nfunction splitValue(value, offset = 0) {\n    let start = -1;\n    let expression = 0;\n    let pos = 0;\n    const result = [];\n    const scanner = new Scanner(value);\n    while (!scanner.eof()) {\n        pos = scanner.pos;\n        if (scanner.eat(isSpace) || scanner.eat(isOperator) || isMinusOperator(scanner)) {\n            // Use space as value delimiter but only if not in expression context,\n            // e.g. `1 2` are distinct values but `(1 2)` not\n            if (!expression && start !== -1) {\n                result.push([offset + start, offset + pos]);\n                start = -1;\n            }\n            scanner.eatWhile(isSpace);\n        }\n        else {\n            if (start === -1) {\n                start = scanner.pos;\n            }\n            if (scanner.eat(40 /* LeftRound */)) {\n                expression++;\n            }\n            else if (scanner.eat(41 /* RightRound */)) {\n                expression--;\n            }\n            else if (!literal(scanner)) {\n                scanner.pos++;\n            }\n        }\n    }\n    if (start !== -1 && start !== scanner.pos) {\n        result.push([offset + start, offset + scanner.pos]);\n    }\n    return result;\n}\nfunction isOperator(ch) {\n    return operators.includes(ch);\n}\n/**\n * Check if current scanner state is at minus operator\n */\nfunction isMinusOperator(scanner) {\n    // Minus operator is tricky since CSS supports dashes in keyword names like\n    // `no-repeat`\n    const start = scanner.pos;\n    if (scanner.eat(45 /* Minus */) && scanner.eat(isSpace)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n\nfunction match(source, pos) {\n    const pool = [];\n    const stack = [];\n    let result = null;\n    let pendingProperty = null;\n    const releasePending = () => {\n        if (pendingProperty) {\n            releaseRange(pool, pendingProperty);\n            pendingProperty = null;\n        }\n    };\n    scan(source, (type, start, end, delimiter) => {\n        if (type === \"selector\" /* Selector */) {\n            releasePending();\n            stack.push(allocRange(pool, start, end, delimiter));\n        }\n        else if (type === \"blockEnd\" /* BlockEnd */) {\n            releasePending();\n            const parent = stack.pop();\n            if (parent && parent[0] < pos && pos < end) {\n                result = {\n                    type: 'selector',\n                    start: parent[0],\n                    end,\n                    bodyStart: parent[2] + 1,\n                    bodyEnd: start\n                };\n                return false;\n            }\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            releasePending();\n            pendingProperty = allocRange(pool, start, end, delimiter);\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            if (pendingProperty && pendingProperty[0] < pos && pos < end) {\n                result = {\n                    type: 'property',\n                    start: pendingProperty[0],\n                    end: delimiter + 1,\n                    bodyStart: start,\n                    bodyEnd: end\n                };\n                return false;\n            }\n            releasePending();\n        }\n    });\n    return result;\n}\n/**\n * Returns balanced CSS model: a list of all ranges that could possibly match\n * given location when moving in outward direction\n */\nfunction balancedOutward(source, pos) {\n    const pool = [];\n    const stack = [];\n    const result = [];\n    let property = null;\n    scan(source, (type, start, end, delimiter) => {\n        if (type === \"selector\" /* Selector */) {\n            stack.push(allocRange(pool, start, end, delimiter));\n        }\n        else if (type === \"blockEnd\" /* BlockEnd */) {\n            const left = stack.pop();\n            if (left && left[0] < pos && end > pos) {\n                // Matching section found\n                const inner = innerRange(source, left[2] + 1, start);\n                inner && push(result, inner);\n                push(result, [left[0], end]);\n            }\n            left && releaseRange(pool, left);\n            if (!stack.length) {\n                return false;\n            }\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            property && releaseRange(pool, property);\n            property = allocRange(pool, start, end, delimiter);\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            if (property && property[0] < pos && Math.max(delimiter, end) > pos) {\n                // Push full token and value range\n                push(result, [start, end]);\n                push(result, [property[0], delimiter !== -1 ? delimiter + 1 : end]);\n            }\n        }\n        if (type !== \"propertyName\" /* PropertyName */ && property) {\n            releaseRange(pool, property);\n            property = null;\n        }\n    });\n    return result;\n}\n/**\n * Returns balanced CSS selectors: a list of all ranges that could possibly match\n * given location when moving in inward direction\n */\nfunction balancedInward(source, pos) {\n    // Collecting ranges for inward balancing is a bit trickier: we have to store\n    // first child of every matched selector until we find the one that matches given\n    // location\n    const pool = [];\n    const stack = [];\n    const result = [];\n    let pendingProperty = null;\n    const alloc = (start, end, delimiter) => {\n        if (pool.length) {\n            const range = pool.pop();\n            range.start = start;\n            range.end = end;\n            range.delimiter = delimiter;\n            return range;\n        }\n        return { start, end, delimiter, firstChild: null };\n    };\n    const release = (range) => {\n        range.firstChild = null;\n        pool.push(range);\n    };\n    const releasePending = () => {\n        if (pendingProperty) {\n            release(pendingProperty);\n            pendingProperty = null;\n        }\n    };\n    /**\n     * Pushes given inward range as a first child of current selector only if it’s\n     * not set yet\n     */\n    const pushChild = (start, end, delimiter) => {\n        const parent = last(stack);\n        if (parent && !parent.firstChild) {\n            parent.firstChild = alloc(start, end, delimiter);\n        }\n    };\n    scan(source, (type, start, end, delimiter) => {\n        if (type === \"blockEnd\" /* BlockEnd */) {\n            releasePending();\n            let range = stack.pop();\n            if (!range) {\n                // Some sort of lone closing brace, ignore it\n                return;\n            }\n            if (range.start <= pos && pos <= end) {\n                // Matching selector found: add it and its inner range into result\n                let inner = innerRange(source, range.delimiter + 1, start);\n                push(result, [range.start, end]);\n                inner && push(result, inner);\n                while (range.firstChild) {\n                    const child = range.firstChild;\n                    inner = innerRange(source, child.delimiter + 1, child.end - 1);\n                    push(result, [child.start, child.end]);\n                    inner && push(result, inner);\n                    range = child;\n                }\n                return false;\n            }\n            else {\n                const parent = last(stack);\n                if (parent && !parent.firstChild) {\n                    // No first child in parent node: store current selector\n                    range.end = end;\n                    parent.firstChild = range;\n                }\n                else {\n                    release(range);\n                }\n            }\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            releasePending();\n            pendingProperty = alloc(start, end, delimiter);\n            pushChild(start, end, delimiter);\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            if (pendingProperty) {\n                if (pendingProperty.start <= pos && end >= pos) {\n                    // Direct hit into property, no need to look further\n                    push(result, [pendingProperty.start, delimiter + 1]);\n                    push(result, [start, end]);\n                    releasePending();\n                    return false;\n                }\n                const parent = last(stack);\n                if (parent && parent.firstChild && parent.firstChild.start === pendingProperty.start) {\n                    // First child is an expected property name, update its range\n                    // to include property value\n                    parent.firstChild.end = delimiter !== -1 ? delimiter + 1 : end;\n                }\n                releasePending();\n            }\n        }\n        else {\n            // Selector start\n            stack.push(alloc(start, end, delimiter));\n            releasePending();\n        }\n    });\n    stack.length = pool.length = 0;\n    return result;\n}\n/**\n * Returns inner range for given selector bounds: narrows it to first non-empty\n * region. If resulting region is empty, returns `null`\n */\nfunction innerRange(source, start, end) {\n    while (start < end && isSpace(source.charCodeAt(start))) {\n        start++;\n    }\n    while (end > start && isSpace(source.charCodeAt(end - 1))) {\n        end--;\n    }\n    return start !== end ? [start, end] : null;\n}\nfunction allocRange(pool, start, end, delimiter) {\n    if (pool.length) {\n        const range = pool.pop();\n        range[0] = start;\n        range[1] = end;\n        range[2] = delimiter;\n        return range;\n    }\n    return [start, end, delimiter];\n}\nfunction releaseRange(pool, range) {\n    range && pool.push(range);\n    return null;\n}\nfunction push(ranges, range) {\n    const prev = ranges.length ? ranges[ranges.length - 1] : null;\n    if ((!prev || prev[0] !== range[0] || prev[1] !== range[1]) && range[0] !== range[1]) {\n        ranges.push(range);\n    }\n}\nfunction last(arr) {\n    return arr.length ? arr[arr.length - 1] : null;\n}\n\nexport default match;\nexport { balancedInward, balancedOutward, scan, splitValue };\n//# sourceMappingURL=css-matcher.es.js.map\n","import Scanner, { isWhiteSpace, isNumber, isSpace } from '@emmetio/scanner';\n\nconst nullary = token(\"null\" /* Null */, 0);\n/**\n * Parses given expression in forward direction\n */\nfunction parse(expr) {\n    const scanner = typeof expr === 'string' ? new Scanner(expr) : expr;\n    let ch;\n    let priority = 0;\n    let expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n    const tokens = [];\n    while (!scanner.eof()) {\n        scanner.eatWhile(isWhiteSpace);\n        scanner.start = scanner.pos;\n        if (consumeNumber(scanner)) {\n            if ((expected & 1 /* Primary */) === 0) {\n                error('Unexpected number', scanner);\n            }\n            tokens.push(number(scanner.current()));\n            expected = (2 /* Operator */ | 8 /* RParen */);\n        }\n        else if (isOperator(scanner.peek())) {\n            ch = scanner.next();\n            if (isSign(ch) && (expected & 16 /* Sign */)) {\n                if (isNegativeSign(ch)) {\n                    tokens.push(op1(ch, priority));\n                }\n                expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n            }\n            else {\n                if ((expected & 2 /* Operator */) === 0) {\n                    error('Unexpected operator', scanner);\n                }\n                tokens.push(op2(ch, priority));\n                expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n            }\n        }\n        else if (scanner.eat(40 /* LeftParenthesis */)) {\n            if ((expected & 4 /* LParen */) === 0) {\n                error('Unexpected \"(\"', scanner);\n            }\n            priority += 10;\n            expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */ | 32 /* NullaryCall */);\n        }\n        else if (scanner.eat(41 /* RightParenthesis */)) {\n            priority -= 10;\n            if (expected & 32 /* NullaryCall */) {\n                tokens.push(nullary);\n            }\n            else if ((expected & 8 /* RParen */) === 0) {\n                error('Unexpected \")\"', scanner);\n            }\n            expected = (2 /* Operator */ | 8 /* RParen */ | 4 /* LParen */);\n        }\n        else {\n            error('Unknown character', scanner);\n        }\n    }\n    if (priority < 0 || priority >= 10) {\n        error('Unmatched \"()\"', scanner);\n    }\n    const result = orderTokens(tokens);\n    if (result === null) {\n        error('Parity', scanner);\n    }\n    return result;\n}\n/**\n * Consumes number from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */) && scanner.eatWhile(isNumber)) {\n        // short decimal notation: .025\n        return true;\n    }\n    if (scanner.eatWhile(isNumber) && (!scanner.eat(46 /* Dot */) || scanner.eatWhile(isNumber))) {\n        // either integer or decimal: 10, 10.25\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Orders parsed tokens (operands and operators) in given array so that they are\n * laid off in order of execution\n */\nfunction orderTokens(tokens) {\n    const operators = [];\n    const operands = [];\n    let nOperators = 0;\n    for (let i = 0; i < tokens.length; i++) {\n        const t = tokens[i];\n        if (t.type === \"num\" /* Number */) {\n            operands.push(t);\n        }\n        else {\n            nOperators += t.type === \"op1\" /* Op1 */ ? 1 : 2;\n            while (operators.length) {\n                if (t.priority <= operators[operators.length - 1].priority) {\n                    operands.push(operators.pop());\n                }\n                else {\n                    break;\n                }\n            }\n            operators.push(t);\n        }\n    }\n    return nOperators + 1 === operands.length + operators.length\n        ? operands.concat(operators.reverse())\n        : null /* parity */;\n}\n/**\n * Number token factory\n */\nfunction number(value, priority) {\n    return token(\"num\" /* Number */, parseFloat(value), priority);\n}\n/**\n * Unary operator factory\n * @param value    Operator  character code\n * @param priority Operator execution priority\n */\nfunction op1(value, priority = 0) {\n    if (value === 45 /* Minus */) {\n        priority += 2;\n    }\n    return token(\"op1\" /* Op1 */, value, priority);\n}\n/**\n * Binary operator factory\n * @param value Operator  character code\n * @param priority Operator execution priority\n */\nfunction op2(value, priority = 0) {\n    if (value === 42 /* Multiply */) {\n        priority += 1;\n    }\n    else if (value === 47 /* Divide */ || value === 92 /* IntDivide */) {\n        priority += 2;\n    }\n    return token(\"op2\" /* Op2 */, value, priority);\n}\nfunction error(name, scanner) {\n    if (scanner) {\n        name += ` at column ${scanner.pos} of expression`;\n    }\n    throw new Error(name);\n}\nfunction isSign(ch) {\n    return isPositiveSign(ch) || isNegativeSign(ch);\n}\nfunction isPositiveSign(ch) {\n    return ch === 43 /* Plus */;\n}\nfunction isNegativeSign(ch) {\n    return ch === 45 /* Minus */;\n}\nfunction isOperator(ch) {\n    return ch === 43 /* Plus */ || ch === 45 /* Minus */ || ch === 42 /* Multiply */\n        || ch === 47 /* Divide */ || ch === 92 /* IntDivide */;\n}\nfunction token(type, value, priority = 0) {\n    return { type, value, priority };\n}\n\nconst defaultOptions = {\n    lookAhead: true,\n    whitespace: true\n};\nfunction extract(text, pos = text.length, options) {\n    const opt = Object.assign(Object.assign({}, defaultOptions), options);\n    const scanner = { text, pos };\n    let ch;\n    if (opt.lookAhead && cur(scanner) === 41 /* RightParenthesis */) {\n        // Basically, we should consume right parenthesis only with optional whitespace\n        scanner.pos++;\n        const len = text.length;\n        while (scanner.pos < len) {\n            ch = cur(scanner);\n            if (ch !== 41 /* RightParenthesis */ && !(opt.whitespace && isSpace(ch))) {\n                break;\n            }\n            scanner.pos++;\n        }\n    }\n    const end = scanner.pos;\n    let braces = 0;\n    while (scanner.pos >= 0) {\n        if (number$1(scanner)) {\n            continue;\n        }\n        ch = prev(scanner);\n        if (ch === 41 /* RightParenthesis */) {\n            braces++;\n        }\n        else if (ch === 40 /* LeftParenthesis */) {\n            if (!braces) {\n                break;\n            }\n            braces--;\n        }\n        else if (!((opt.whitespace && isSpace(ch)) || isSign(ch) || isOperator(ch))) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (scanner.pos !== end && !braces) {\n        // Trim whitespace\n        while (isSpace(cur(scanner))) {\n            scanner.pos++;\n        }\n        return [scanner.pos, end];\n    }\n    return null;\n}\n/**\n * Backward-consumes number from given scanner, if possible\n */\nfunction number$1(scanner) {\n    if (isNumber(prev(scanner))) {\n        scanner.pos--;\n        let dot = false;\n        let ch;\n        while (scanner.pos >= 0) {\n            ch = prev(scanner);\n            if (ch === 46 /* . */) {\n                if (dot) {\n                    // Decimal delimiter already consumed, abort\n                    break;\n                }\n                dot = true;\n            }\n            else if (!isNumber(ch)) {\n                break;\n            }\n            scanner.pos--;\n        }\n        return true;\n    }\n    return false;\n}\nfunction prev(scanner) {\n    return scanner.text.charCodeAt(scanner.pos - 1);\n}\nfunction cur(scanner) {\n    return scanner.text.charCodeAt(scanner.pos);\n}\n\nconst ops1 = {\n    [45 /* Minus */]: num => -num\n};\nconst ops2 = {\n    [43 /* Plus */]: (a, b) => a + b,\n    [45 /* Minus */]: (a, b) => a - b,\n    [42 /* Multiply */]: (a, b) => a * b,\n    [47 /* Divide */]: (a, b) => a / b,\n    [92 /* IntDivide */]: (a, b) => Math.floor(a / b)\n};\n/**\n * Evaluates given math expression\n * @param expr Expression to evaluate\n */\nfunction evaluate(expr) {\n    if (!Array.isArray(expr)) {\n        expr = parse(expr);\n    }\n    if (!expr || !expr.length) {\n        return null;\n    }\n    const nStack = [];\n    let n1;\n    let n2;\n    let f;\n    for (let i = 0, il = expr.length; i < il; i++) {\n        const token = expr[i];\n        if (token.type === \"num\" /* Number */) {\n            nStack.push(token.value);\n        }\n        else if (token.type === \"op2\" /* Op2 */) {\n            n2 = nStack.pop();\n            n1 = nStack.pop();\n            f = ops2[token.value];\n            nStack.push(f(n1, n2));\n        }\n        else if (token.type === \"op1\" /* Op1 */) {\n            n1 = nStack.pop();\n            f = ops1[token.value];\n            nStack.push(f(n1));\n        }\n        else {\n            throw new Error('Invalid expression');\n        }\n    }\n    if (nStack.length > 1) {\n        throw new Error('Invalid Expression (parity)');\n    }\n    return nStack[0];\n}\n\nexport default evaluate;\nexport { extract, parse };\n//# sourceMappingURL=math.es.js.map\n","import { Options } from 'emmet';\nimport getEmmetConfig from './config';\nimport { tabStopStart, tabStopEnd } from './utils';\nimport { isHTML, docSyntax } from './syntax';\n\nexport default function getOutputOptions(editor: CodeMirror.Editor, pos?: number, inline?: boolean): Partial<Options> {\n    const posObj: CodeMirror.Position = pos != null ? editor.posFromIndex(pos) : editor.getCursor();\n    const syntax = docSyntax(editor) || 'html';\n    const config = getEmmetConfig(editor);\n\n    const opt: Partial<Options> = {\n        'output.baseIndent': lineIndent(editor, posObj.line),\n        'output.indent': getIndentation(editor),\n        'output.field': field(),\n        'output.format': !inline,\n        'output.attributeQuotes': config.attributeQuotes\n    };\n\n    if (syntax === 'html') {\n        opt['output.selfClosingStyle'] = config.markupStyle;\n        opt['output.compactBoolean'] = config.markupStyle === 'html';\n    }\n\n    if (isHTML(syntax)) {\n        if (config.comments) {\n            opt['comment.enabled'] = true;\n            if (config.commentsTemplate) {\n                opt['comment.after'] = config.commentsTemplate;\n            }\n        }\n\n        opt['bem.enabled'] = config.bem;\n        opt['stylesheet.shortHex'] = config.shortHex;\n    }\n\n    return opt;\n}\n\n/**\n * Produces tabstop for CodeMirror editor\n */\nexport function field() {\n    let handled = -1;\n    return (index: number, placeholder: string) => {\n        if (handled === -1 || handled === index) {\n            handled = index;\n            return placeholder\n                ? tabStopStart + placeholder + tabStopEnd\n                : tabStopStart;\n        }\n\n        return placeholder || '';\n    }\n}\n\n/**\n * Returns indentation of given line\n */\nexport function lineIndent(editor: CodeMirror.Editor, line: number): string {\n    const lineStr = editor.getLine(line);\n    const indent = lineStr.match(/^\\s+/);\n    return indent ? indent[0] : '';\n}\n\n/**\n * Returns token used for single indentation in given editor\n */\nexport function getIndentation(editor: CodeMirror.Editor): string {\n    if (!editor.getOption('indentWithTabs')) {\n        return ' '.repeat(editor.getOption('indentUnit') || 0);\n    }\n\n    return '\\t';\n}\n","import expandAbbreviation, { extract as extractAbbreviation, UserConfig, AbbreviationContext, ExtractedAbbreviation, Options, ExtractOptions, resolveConfig, MarkupAbbreviation, StylesheetAbbreviation, SyntaxType } from 'emmet';\nimport match, { balancedInward, balancedOutward } from '@emmetio/html-matcher';\nimport { balancedInward as cssBalancedInward, balancedOutward as cssBalancedOutward } from '@emmetio/css-matcher';\nimport { selectItemCSS, selectItemHTML, TextRange } from '@emmetio/action-utils';\nimport evaluate, { extract as extractMath, ExtractOptions as MathExtractOptions } from '@emmetio/math-expression';\nimport { isXML, syntaxInfo, getMarkupAbbreviationContext, getStylesheetAbbreviationContext } from './syntax';\nimport { getContent, isQuotedString } from './utils';\nimport getEmmetConfig from './config';\nimport getOutputOptions, { field } from './output';\n\ninterface EvaluatedMath {\n    start: number;\n    end: number;\n    result: number;\n    snippet: string;\n}\n\nexport interface ContextTag extends AbbreviationContext {\n    open: TextRange;\n    close?: TextRange;\n}\n\nexport interface ExtractedAbbreviationWithContext extends ExtractedAbbreviation {\n    context?: AbbreviationContext;\n    inline?: boolean;\n}\n\n/**\n * Cache for storing internal Emmet data.\n * TODO reset whenever user settings are changed\n */\nlet cache = {};\n\nexport const JSX_PREFIX = '<';\n\n/**\n * Expands given abbreviation into code snippet\n */\nexport function expand(editor: CodeMirror.Editor, abbr: string | MarkupAbbreviation | StylesheetAbbreviation, config?: UserConfig) {\n    let opt: UserConfig = { cache };\n    const outputOpt: Partial<Options> = {\n        'output.field': field(),\n        'output.format': !config || !config['inline'],\n    };\n\n    if (config) {\n        Object.assign(opt, config);\n        if (config.options) {\n            Object.assign(outputOpt, config.options);\n        }\n    }\n\n    opt.options = outputOpt;\n\n    const pluginConfig = getEmmetConfig(editor);\n    if (pluginConfig.config) {\n        opt = resolveConfig(opt, pluginConfig.config);\n    }\n\n    return expandAbbreviation(abbr as string, opt);\n}\n\n/**\n * Extracts abbreviation from given source code by detecting actual syntax context.\n * For example, if host syntax is HTML, it tries to detect if location is inside\n * embedded CSS.\n *\n * It also detects if abbreviation is allowed at given location: HTML tags,\n * CSS selectors may not contain abbreviations.\n * @param code Code from which abbreviation should be extracted\n * @param pos Location at which abbreviation should be expanded\n * @param syntax Syntax of abbreviation to expand\n */\nexport function extract(code: string, pos: number, type: SyntaxType = 'markup', options?: Partial<ExtractOptions>): ExtractedAbbreviation | undefined {\n    return extractAbbreviation(code, pos, {\n        lookAhead: type !== 'stylesheet',\n        type,\n        ...options\n    });\n}\n\n/**\n * Returns list of tags for balancing for given code\n */\nexport function balance(code: string, pos: number, inward = false, xml = false) {\n    const options = { xml };\n    return inward\n        ? balancedInward(code, pos, options)\n        : balancedOutward(code, pos, options);\n}\n\n/**\n * Returns list of selector/property ranges for balancing for given code\n */\nexport function balanceCSS(code: string, pos: number, inward?: boolean) {\n    return inward\n        ? cssBalancedInward(code, pos)\n        : cssBalancedOutward(code, pos);\n}\n\n/**\n * Returns model for selecting next/previous item\n */\nexport function selectItem(code: string, pos: number, isCSS?: boolean, isPrevious?: boolean) {\n    return isCSS\n        ? selectItemCSS(code, pos, isPrevious)\n        : selectItemHTML(code, pos, isPrevious);\n}\n\n/**\n * Finds and evaluates math expression at given position in line\n */\nexport function evaluateMath(code: string, pos: number, options?: Partial<MathExtractOptions>): EvaluatedMath | undefined {\n    const expr = extractMath(code, pos, options);\n    if (expr) {\n        try {\n            const [start, end] = expr;\n            const result = evaluate(code.slice(start, end));\n            if (result !== null) {\n                return {\n                    start, end, result,\n                    snippet: result.toFixed(4).replace(/\\.?0+$/, '')\n                };\n            }\n        } catch (err) {\n            console.error(err);\n        }\n    }\n}\n\n/**\n * Returns matched HTML/XML tag for given point in view\n */\nexport function getTagContext(editor: CodeMirror.Editor, pos: number, xml?: boolean): ContextTag | undefined {\n    const content = getContent(editor);\n    let ctx: ContextTag | undefined;\n\n    if (xml == null) {\n        // Autodetect XML dialect\n        const mode = editor.getMode();\n        xml = mode ? isXML(mode.name) : false;\n    }\n\n    const matchedTag = match(content, pos, { xml });\n    if (matchedTag) {\n        const { open, close } = matchedTag;\n        ctx = {\n            name: matchedTag.name,\n            open,\n            close\n        };\n\n        if (matchedTag.attributes) {\n            ctx.attributes = {};\n            matchedTag.attributes.forEach(attr => {\n                let value = attr.value;\n                if (value && isQuotedString(value)) {\n                    value = value.slice(1, -1);\n                }\n\n                ctx!.attributes![attr.name] = value == null ? null : value;\n            });\n        }\n    }\n\n    return ctx;\n}\n\n/**\n * Returns Emmet options for given character location in editor\n */\nexport function getOptions(editor: CodeMirror.Editor, pos: number): UserConfig {\n    const info = syntaxInfo(editor, pos);\n    const { context } = info;\n\n    const config: UserConfig = {\n        type: info.type,\n        syntax: info.syntax || 'html',\n        options: getOutputOptions(editor, pos, info.inline)\n    };\n\n    if (context) {\n        const content = getContent(editor);\n        // Set context from syntax info\n        if (context.type === 'html' && context.ancestors.length) {\n            config.context = getMarkupAbbreviationContext(content, context);\n        } else if (context.type === 'css') {\n            config.context = getStylesheetAbbreviationContext(context);\n        }\n    }\n\n    return config;\n}\n","import { UserConfig } from 'emmet';\nimport { AbbreviationTrackingController, EditorProxy, AbbreviationTracker, AbbreviationTrackerType, JSX_PREFIX, StopTrackingParams, StartTrackingParams } from '@emmetio/action-utils';\nimport { getInternalState, getCaret, toRange, errorSnippet, replaceWithSnippet } from './lib/utils';\nimport {\n    isSupported, isJSX, isCSS, isHTML, isXML, syntaxFromPos, docSyntax,\n    syntaxInfo, enabledForSyntax, getSyntaxType\n} from './lib/syntax';\nimport { getOptions, extract, expand } from './lib/emmet';\nimport getOutputOptions from './lib/output';\nimport getEmmetConfig from './lib/config';\n\nexport interface CompletionItem {\n    text: string;\n    displayText: string;\n    hint(): void;\n    from: CodeMirror.Position;\n    to: CodeMirror.Position;\n}\n\n/** Class name for Emmet abbreviation marker in editor */\nconst markClass = 'emmet-abbreviation';\n\n/** Class name for Emmet abbreviation preview in editor */\nconst previewClass = 'emmet-abbreviation-preview';\n\nclass CMEditorProxy implements EditorProxy {\n    public cm: CodeMirror.Editor;\n    public marker: CodeMirror.TextMarker | null = null;\n    public preview: CodeMirror.Editor | null = null;\n    public forcedMarker: HTMLElement | null = null;\n\n    get id() {\n        return getInternalState(this.cm).id;\n    }\n\n    substr(from?: number, to?: number) {\n        const value = this.cm.getValue();\n        if (from === undefined && to === undefined) {\n            return value;\n        }\n\n        return value.slice(from || 0, to);\n    }\n\n    replace(value: string, from: number, to: number) {\n        this.cm.replaceRange(value,\n            this.cm.posFromIndex(from),\n            this.cm.posFromIndex(to));\n    }\n\n    syntax() {\n        return docSyntax(this.cm);\n    }\n\n    size() {\n        return this.cm.getValue().length;\n    }\n\n    config(pos: number): UserConfig {\n        return getOptions(this.cm, pos);\n    }\n\n    outputOptions(pos: number, inline?: boolean) {\n        return getOutputOptions(this.cm, pos, inline);\n    }\n\n    previewConfig(config: UserConfig) {\n        return {\n            ...config,\n            options: {\n                ...config.options,\n                'output.field': previewField,\n                'output.indent': '  ',\n                'output.baseIndent': ''\n            }\n        };\n    }\n\n    allowTracking(pos: number) {\n        return allowTracking(this.cm, pos);\n    }\n\n    mark(tracker: AbbreviationTracker): void {\n        const { cm } = this;\n        this.disposeMarker();\n        const [from, to] = toRange(cm, tracker.range);\n        this.marker = cm.markText(from, to, {\n            inclusiveLeft: true,\n            inclusiveRight: true,\n            clearWhenEmpty: false,\n            className: markClass\n        });\n\n        if (tracker.forced && !this.forcedMarker) {\n            this.forcedMarker = document.createElement('div');\n            this.forcedMarker.className = `${markClass}-marker`;\n            cm.addWidget(from, this.forcedMarker, false);\n        }\n    }\n\n    unmark(): void {\n        this.disposeMarker();\n        this.hidePreview();\n    }\n\n    showPreview(tracker: AbbreviationTracker) {\n        const { cm } = this;\n        const config = getEmmetConfig(cm);\n\n        // Check if we should display preview\n        if (!enabledForSyntax(config.preview, syntaxInfo(cm, tracker.range[0]))) {\n            return;\n        }\n\n        let content: string | undefined;\n        let isError = false;\n\n        if (tracker.type === AbbreviationTrackerType.Error) {\n            content = errorSnippet(tracker.error);\n            isError = true;\n        } else if (tracker.forced || !tracker.simple) {\n            content = tracker.preview;\n        }\n\n        if (content) {\n            if (!this.preview) {\n                const previewElem = document.createElement('div');\n                previewElem.className = previewClass;\n\n                const pos = cm.posFromIndex(tracker.range[0]);\n                if (config.attachPreview) {\n                    config.attachPreview(cm, previewElem, pos);\n                } else {\n                    cm.addWidget(pos, previewElem, false);\n                }\n\n                // @ts-ignore\n                this.preview = new this.cm.constructor(previewElem, {\n                    mode: cm.getOption('mode'),\n                    readOnly: 'nocursor',\n                    lineNumbers: false\n                }) as CodeMirror.Editor;\n\n                const errElement = document.createElement('div');\n                errElement.className = `${previewClass}-error`;\n                previewElem.appendChild(errElement);\n            }\n\n            const wrapper = this.preview.getWrapperElement().parentElement!;\n            wrapper.classList.toggle('has-error', isError);\n            if (isError) {\n                wrapper.querySelector(`.${previewClass}-error`)!.innerHTML = content;\n            } else {\n                this.preview.setValue(content);\n            }\n        } else {\n            this.hidePreview();\n        }\n    }\n\n    hidePreview() {\n        if (this.preview) {\n            this.preview.getWrapperElement().parentElement!.remove();\n            this.preview = null;\n        }\n    }\n\n    /**\n     * Check if given syntax is a CSS dialect (including SCSS, LESS etc)\n     */\n    isCSS(syntax: string): boolean {\n        return isCSS(syntax);\n    }\n\n    syntaxType(syntax: string) {\n        return getSyntaxType(syntax);\n    }\n\n    /**\n     * Check if given syntax is a HTML dialect. HTML dialects also support embedded\n     * stylesheets in `<style>` tga or `style=\"\"` attribute\n     */\n    isHTML(syntax: string): boolean {\n        return isHTML(syntax);\n    }\n\n    /**\n     * Check if given syntax is a XML dialect. Unlike HTML, XML dialects doesn’t\n     * support embedded stylesheets\n     */\n    isXML(syntax: string): boolean {\n        return isXML(syntax);\n    }\n\n    /**\n     * Check if given syntax is a JSX dialect\n     */\n    isJSX(syntax: string) {\n        return isJSX(syntax);\n    }\n\n    /**\n     * Runs given callback in context of given editor\n     */\n    run<R>(editor: CodeMirror.Editor, callback: () => R): R {\n        const { cm } = this;\n        this.cm = editor;\n        const result = callback();\n        this.cm = cm;\n        return result;\n    }\n\n    private disposeMarker() {\n        if (this.marker) {\n            this.marker.clear();\n            this.marker = null;\n        }\n\n        if (this.forcedMarker) {\n            this.forcedMarker.remove();\n            this.forcedMarker = null;\n        }\n    }\n}\n\nfunction previewField(index: number, placeholder: string) {\n    return placeholder;\n}\n\nconst proxy = new CMEditorProxy();\nconst controller = new AbbreviationTrackingController<CMEditorProxy>();\n\nexport default function initAbbreviationTracker(editor: CodeMirror.Editor) {\n    const onChange = (ed: CodeMirror.Editor) => {\n        proxy.run(ed, () => {\n            controller.handleChange(proxy, getCaret(ed));\n        });\n    };\n    const onSelectionChange = (ed: CodeMirror.Editor) => {\n        proxy.run(ed, () => {\n            const caret = getCaret(ed);\n            if (!isEnabled(ed, caret)) {\n                return;\n            }\n\n            const tracker = controller.handleSelectionChange(proxy, caret);\n            if (tracker) {\n                if (contains(tracker, caret)) {\n                    proxy.showPreview(tracker);\n                } else {\n                    proxy.hidePreview();\n                }\n            }\n        });\n    };\n\n    editor.on('change', onChange);\n    editor.on('focus', onSelectionChange);\n    editor.on('cursorActivity', onSelectionChange);\n\n    return () => {\n        proxy.run(editor, () => controller.disposeEditor(proxy));\n        editor.off('change', onChange);\n        editor.off('focus', onSelectionChange);\n        editor.off('cursorActivity', onSelectionChange);\n    };\n}\n\n/**\n * Runs given function in context of abbreviation tracker\n */\nexport function runInTrackerContext<R>(editor: CodeMirror.Editor, callback: (controller: AbbreviationTrackingController<CMEditorProxy>, proxy: CMEditorProxy) => R): R {\n    return proxy.run(editor, () => callback(controller, proxy));\n}\n\n/**\n * Check if abbreviation tracking is allowed in editor at given location\n */\nexport function allowTracking(editor: CodeMirror.Editor, pos: number): boolean {\n    if (isEnabled(editor, pos)) {\n        const syntax = syntaxFromPos(editor, pos);\n        return syntax ? isSupported(syntax) || isJSX(syntax) : false;\n    }\n\n    return false;\n}\n\n/**\n * Check if Emmet auto-complete is enabled\n */\nexport function isEnabled(editor: CodeMirror.Editor, pos: number): boolean {\n    const config = getEmmetConfig(editor);\n    return enabledForSyntax(config.mark, syntaxInfo(editor, pos));\n}\n\n/**\n * If allowed, tries to extract abbreviation from given completion context\n * @param forceValid Enforces tracker to be valid, e.g. do not track abbreviation\n * if it’s not valid\n */\nexport function extractTracker(editor: CodeMirror.Editor, pos: number, forceValid?: boolean): AbbreviationTracker | undefined {\n    return proxy.run(editor, () => {\n        const syntax = proxy.syntax();\n        const prefix = proxy.isJSX(syntax) ? JSX_PREFIX : '';\n        const config = controller.getActivationContext(proxy, pos);\n        const abbr = extract(proxy.substr(), pos, getSyntaxType(config?.syntax), { prefix });\n        if (abbr) {\n            const tracker = controller.startTracking(proxy, abbr.start, abbr.end, {\n                offset: prefix.length,\n                config\n            });\n\n            if (tracker) {\n                if (tracker.type === AbbreviationTrackerType.Error && forceValid) {\n                    controller.stopTracking(proxy, { force: true });\n                    return;\n                }\n                proxy.showPreview(tracker);\n            }\n            return tracker;\n        }\n    });\n}\n\n/**\n * Returns abbreviation tracker for given editor, if any\n */\nexport function getTracker(editor: CodeMirror.Editor): AbbreviationTracker | undefined {\n    return proxy.run(editor, () => controller.getTracker(proxy));\n}\n\n/**\n * Start abbreviation tracking in given editor for given range\n */\nexport function startTracking(editor: CodeMirror.Editor, start: number, pos: number, params?: Partial<StartTrackingParams>) {\n    return proxy.run(editor, () => {\n        const tracker = controller.startTracking(proxy, start, pos, params);\n        if (tracker) {\n            proxy.showPreview(tracker);\n        }\n\n        return tracker;\n    });\n}\n\n/**\n * Stops abbreviation tracking in given editor\n */\nexport function stopTracking(editor: CodeMirror.Editor, params?: Partial<StopTrackingParams>) {\n    return proxy.run(editor, () => controller.stopTracking(proxy, params));\n}\n\n/**\n * Returns completion item, suitable for auto-hint CodeMirror module,\n * with tracked abbreviation for it\n */\nexport function getCompletion(editor: CodeMirror.Editor, pos: number): CompletionItem | undefined {\n    const tracker = getTracker(editor) || extractTracker(editor, pos);\n    if (tracker && contains(tracker, pos) && tracker.type === AbbreviationTrackerType.Abbreviation) {\n        const { abbreviation, preview } = tracker;\n        return {\n            text: abbreviation,\n            displayText: preview,\n            hint: () => {\n                stopTracking(editor);\n                const snippet = expand(editor, abbreviation, tracker.config);\n                replaceWithSnippet(editor, tracker.range, snippet);\n            },\n            from: editor.posFromIndex(tracker.range[0]),\n            to: editor.posFromIndex(tracker.range[1]),\n        } as CompletionItem;\n    }\n}\n\n/**\n * Restore tracker on undo, if possible\n */\nexport function restoreOnUndo(editor: CodeMirror.Editor, pos: number, abbr: string) {\n    proxy.run(editor, () => {\n        const lastTracker = controller.getStoredTracker(proxy);\n\n        if (lastTracker) {\n            const shouldRestore = lastTracker.type === AbbreviationTrackerType.Abbreviation\n                && abbr === lastTracker.abbreviation\n                && lastTracker.range[0] === pos;\n\n            if (shouldRestore) {\n                controller.restoreTracker(proxy, pos);\n            }\n        }\n    })\n}\n\n/**\n * Check if tracker range contains given position\n */\nexport function contains(tracker: AbbreviationTracker, pos: number): boolean {\n    return pos >= tracker.range[0] && pos <= tracker.range[1];\n}\n","import { attributes } from '@emmetio/html-matcher';\nimport { TagMatch, findTagMatch, getTagMatches } from '@emmetio/action-utils';\nimport { getCaret, rangesEqual, substr, isQuotedString } from './utils';\nimport getEmmetConfig from './config';\n\nconst openTagMark = 'emmet-open-tag';\nconst closeTagMark = 'emmet-close-tag';\n\ninterface CMTagMatch extends TagMatch {\n    /** Open tag name preview */\n    preview?: string;\n}\n\ninterface CMMarkRange {\n    from: CodeMirror.Position;\n    to: CodeMirror.Position;\n}\n\n/**\n * Setup editor for tag matching\n */\nexport default function markTagMatches(editor: CodeMirror.Editor) {\n    let tags: TagMatch[] | null = null;\n    let lastMatch: TagMatch | null | undefined;\n    let tagPreview: HTMLElement | null = null;\n\n    /**\n     * Displays tag preview as given location, if possible\n     */\n    function showTagPreview(ed: CodeMirror.Editor, pos: number, preview: string) {\n        // Check if we already have preview at given location\n        if (!tagPreview || tagPreview.dataset.pos !== String(pos)) {\n            hidePreview();\n            tagPreview = createPreviewWidget(ed, pos, preview);\n        }\n    }\n\n    function hidePreview() {\n        if (tagPreview) {\n            tagPreview.remove();\n            tagPreview = null;\n        }\n    }\n\n    const onCursorActivity = (ed: CodeMirror.Editor) => {\n        if (!tags) {\n            tags = getTagMatches(ed.getValue());\n        }\n\n        const caret = getCaret(ed);\n        let match = findTagMatch(tags!, caret) as CMTagMatch | undefined;\n        if (match) {\n            if (!match.preview) {\n                match.preview = generatePreview(ed, match);\n            }\n\n            if (shouldDisplayTagPreview(ed, match, caret)) {\n                showTagPreview(ed, match.close![1], match.preview);\n            } else {\n                hidePreview();\n            }\n\n            // Replace full tag match with name-only match\n            const nLen = match.name.length;\n            match = {\n                ...match,\n                open: [match.open[0] + 1, match.open[0] + 1 + nLen],\n            };\n            if (match.close) {\n                match.close = [match.close[0] + 2, match.close[0] + 2 + nLen]\n            }\n        }\n\n        if (match && (!lastMatch || !rangesEqual(lastMatch.open, match.open))) {\n            clearTagMarks(ed);\n            markTagMatch(ed, match);\n        } else if (!match && lastMatch) {\n            clearTagMarks(ed);\n        }\n        lastMatch = match;\n    };\n\n    const onChange = (editor: CodeMirror.Editor) => {\n        tags = null;\n        if (getEmmetConfig(editor).autoRenameTags) {\n            const { open, close } = getTagMarks(editor);\n            if (open && close) {\n                const cursor = editor.getCursor();\n                const openRange = open.find();\n                const closeRange = close.find();\n\n                let shouldReset = false;\n                // Handle edge case when user deletes text fragment which invalidates\n                // matched tags, e.g. in `<div>1</div>` remove `>1</div`.\n                // In this case, a closing range becomes empty\n                if (isEmptyRange(editor, openRange) || isEmptyRange(editor, closeRange)) {\n                    shouldReset = true;\n                } else if (isValidAutoRenameRanges(editor, openRange, closeRange)) {\n                    if (containsPos(openRange, cursor)) {\n                        // Update happened inside open tag, update close tag as well\n                        shouldReset = updateTag(editor, openRange, closeRange);\n                    } else if (containsPos(closeRange, cursor)) {\n                        // Update happened inside close tag, update open tag as well\n                        shouldReset = updateTag(editor, closeRange, openRange);\n                    }\n                }\n\n                if (shouldReset) {\n                    // Reset last match & marker to find and re-mark new location\n                    clearTagMarks(editor);\n                    lastMatch = null;\n                }\n            }\n        }\n    }\n\n    editor.on('cursorActivity', onCursorActivity);\n    editor.on('change', onChange);\n\n    return () => {\n        clearTagMarks(editor);\n        hidePreview();\n        editor.off('cursorActivity', onCursorActivity);\n        editor.off('cursorActivity', onChange);\n        tags = lastMatch = null;\n    };\n}\n\nfunction shouldDisplayTagPreview(editor: CodeMirror.Editor, match: CMTagMatch, caret: number) {\n    return match.close && match.preview && getEmmetConfig(editor).previewOpenTag\n        && caret > match.close[0] && caret < match.close[1];\n}\n\n/**\n * Marks given tag match in editor\n */\nfunction markTagMatch(editor: CodeMirror.Editor, { open, close, preview }: CMTagMatch) {\n    createTagMark(editor, editor.posFromIndex(open[0]), editor.posFromIndex(open[1]), openTagMark);\n    if (close) {\n        createTagMark(editor, editor.posFromIndex(close[0]), editor.posFromIndex(close[1]), closeTagMark);\n    }\n}\n\n/**\n * Removes any existing tag marks in editor\n */\nfunction clearTagMarks(editor: CodeMirror.Editor) {\n    const { open, close } = getTagMarks(editor);\n    open && open.clear();\n    close && close.clear();\n}\n\n/**\n * Returns open and close tag marks in editor, if available\n */\nfunction getTagMarks(editor: CodeMirror.Editor) {\n    let open: CodeMirror.TextMarker | undefined;\n    let close: CodeMirror.TextMarker | undefined;\n    editor.getAllMarks().forEach(mark => {\n        if (mark['className'] === openTagMark) {\n            open = mark;\n        } else if (mark['className'] === closeTagMark) {\n            close = mark;\n        }\n    });\n\n    return { open, close };\n}\n\nfunction createTagMark(editor: CodeMirror.Editor, from: CodeMirror.Position, to: CodeMirror.Position, className: string, attributes?: {}) {\n    return editor.markText(from, to, {\n        className,\n        inclusiveLeft: true,\n        inclusiveRight: true,\n        clearWhenEmpty: false,\n        // @ts-ignore `attributes` key is supported\n        attributes\n    });\n}\n\n/**\n * Updates content of `dest` range with valid tag name from `source` range.\n * @returns `true` if tag markers must be updated\n */\nfunction updateTag(editor: CodeMirror.Editor, source: CMMarkRange, dest: CMMarkRange): boolean {\n    const name = editor.getRange(source.from, source.to);\n    const m = name.match(/[\\w:.-]+/);\n    const newName = m ? m[0] : '';\n\n    if (editor.getRange(dest.from, dest.to) !== newName) {\n        editor.replaceRange(newName, dest.from, dest.to);\n    }\n\n    return name !== newName;\n}\n\nfunction createPreviewWidget(editor: CodeMirror.Editor, pos: number, preview: string): HTMLElement {\n    const elem = document.createElement('div');\n    elem.className = 'emmet-tag-preview';\n    elem.innerText = preview;\n    elem.dataset.pos = String(pos);\n\n    editor.addWidget(editor.posFromIndex(pos), elem, false);\n    return elem;\n}\n\n/**\n * Generates open tag preview for given tag match\n */\nfunction generatePreview(editor: CodeMirror.Editor, match: TagMatch): string {\n    let className = '';\n    let id = '';\n    const attrs: string[] = [];\n\n    attributes(substr(editor, match.open), match.name).forEach(attr => {\n        if (attr.name === 'class' && attr.value) {\n            className = '.' + unquoted(attr.value).replace(/\\s+/g, '.');\n        } else if (attr.name === 'id' && attr.value) {\n            id = '#' + unquoted(attr.value);\n        } else {\n            attrs.push(attr.value ? `${attr.name}=${attr.value}` : attr.name);\n        }\n    });\n\n    const attrString = attrs.length ? `[${attrs.join(' ')}]` : '';\n    const suffix = id + className + attrString;\n    return suffix ? match.name + suffix : '';\n}\n\nfunction unquoted(str: string) {\n    return isQuotedString(str) ? str.slice(1, -1) : str;\n}\n\n/**\n * Check if given range contains point\n * @param exclude Exclude range end and start\n */\nfunction containsPos(range: CMMarkRange, pos: CodeMirror.Position, exclude?: boolean): boolean {\n    return exclude\n        ? comparePos(pos, range.from) > 0 && comparePos(pos, range.to) < 0\n        : comparePos(pos, range.from) >= 0 && comparePos(pos, range.to) <= 0;\n}\n\nfunction comparePos(a: CodeMirror.Position, b: CodeMirror.Position) {\n    return a.line - b.line || a.ch - b.ch;\n}\n\nfunction isValidAutoRenameRanges(editor: CodeMirror.Editor, open: CMMarkRange, close: CMMarkRange) {\n    const openName = editor.getRange(open.from, open.to);\n    const closeName = editor.getRange(close.from, close.to);\n    return openName !== closeName;\n}\n\nfunction isEmptyRange(editor: CodeMirror.Editor, range: CMMarkRange): boolean {\n    return editor.getRange(range.from, range.to) === '';\n}\n","import Scanner from '@emmetio/scanner';\n\nexport type ParseModeError = Error & { ch?: number };\n\ninterface State {\n    parseError?: ParseModeError;\n}\n\nexport function error(message: string, scanner: Scanner | CodeMirror.StringStream): ParseModeError {\n    const err = new Error(message) as ParseModeError;\n    err.ch = scanner.pos;\n    return err;\n}\n\nexport function unexpectedCharacter(stream: CodeMirror.StringStream, state: State, message = 'Unexpected character'): string {\n    state.parseError = error(message.replace(/\\s+at\\s+\\d+$/, ''), stream);\n    stream.skipToEnd();\n    return 'invalidchar';\n}\n\nexport function last<T>(arr: T[]): T {\n    return arr[arr.length - 1];\n}\n","import Scanner from '@emmetio/scanner';\nimport { getToken, BracketType, Bracket, AllTokens } from '@emmetio/abbreviation';\nimport { last, unexpectedCharacter, error, ParseModeError } from './utils';\n\ntype Context = { [ctx in BracketType]: number } & { quote: number };\n\ninterface EmmetMarkupModeState extends Context {\n    parseError?: ParseModeError;\n    braces: Bracket[];\n    scanner: Scanner;\n    tokens: AllTokens[];\n}\n\nexport default function emmetAbbreviationMode(): CodeMirror.Mode<EmmetMarkupModeState> {\n    return {\n        startState() {\n            return {\n                attribute: 0,\n                expression: 0,\n                group: 0,\n                quote: 0,\n                braces: [],\n                tokens: [],\n                scanner: new Scanner('')\n            };\n        },\n        token(stream, state) {\n            const { scanner } = state;\n            scanner.string = stream.string;\n            scanner.pos = stream.pos;\n            scanner.start = stream.start;\n            scanner.end = stream.string.length;\n\n            const ch = scanner.peek();\n            const token = getToken(scanner, state);\n\n            if (!token) {\n                return unexpectedCharacter(stream, state);\n            }\n\n            stream.pos = scanner.pos;\n\n            if (token.type === 'Quote') {\n                state.quote = ch === state.quote ? 0 : ch;\n            } else if (token.type === 'Bracket') {\n                if (token.open) {\n                    state[token.context]++;\n                    state.braces.push(token);\n                } else {\n                    state[token.context]--;\n                    const lastBrace = last(state.braces);\n                    if (lastBrace && lastBrace.context === token.context) {\n                        state.braces.pop();\n                    }\n                }\n            }\n\n            // Report if closing braces are missing at the end of abbreviation\n            if (stream.eol() && state.braces.length && !state.parseError) {\n                const pos = last(state.braces).start;\n                state.parseError = error(`No closing brace at ${pos}`, stream);\n                return null;\n            }\n\n            const name = getTokenName(token, state);\n            state.tokens.push(token);\n            return name;\n        }\n    }\n}\n\n/**\n * Returns scope name for given token\n */\nfunction getTokenName(token: AllTokens, state: EmmetMarkupModeState): string {\n    const prev = last(state.tokens)\n    switch(token.type) {\n        case 'Bracket':\n            return `bracket`;\n        case 'Field':\n            return 'variable-2';\n        case 'Literal':\n            if (state.attribute) {\n                if (prev && prev.type === 'Operator' && prev.operator === 'equal') {\n                    return 'string-2';\n                }\n                return state.quote ? 'string' : 'attribute';\n            }\n\n            if (state.quote) {\n                return 'string';\n            }\n\n            if (prev && prev.type === 'Operator') {\n                if (prev.operator === 'class') {\n                    return 'variable-2';\n                }\n\n                if (prev.operator === 'id') {\n                    return 'variable-3';\n                }\n            }\n\n            return 'tag';\n        case 'Operator':\n            if (token.operator === 'class') {\n                return 'variable-2';\n            }\n\n            if (token.operator === 'id') {\n                return 'variable-3';\n            }\n\n            return `operator ${token.operator}`;\n        case 'Repeater':\n        case 'RepeaterPlaceholder':\n            return 'meta';\n        case 'Quote':\n            return 'string';\n        case 'RepeaterNumber':\n            return 'number';\n    }\n\n    return '';\n}\n","import Scanner from '@emmetio/scanner';\nimport { getToken, AllTokens } from '@emmetio/css-abbreviation';\nimport { unexpectedCharacter, ParseModeError } from './utils';\n\ninterface EmmetStylesheetModeState {\n    parseError?: ParseModeError;\n    brackets: number;\n    scanner: Scanner;\n    tokens: AllTokens[];\n}\n\nexport default function emmetAbbreviationMode(): CodeMirror.Mode<EmmetStylesheetModeState> {\n    return {\n        startState() {\n            return {\n                brackets: 0,\n                tokens: [],\n                scanner: new Scanner('')\n            };\n        },\n        token(stream, state) {\n            const { scanner } = state;\n            scanner.string = stream.string;\n            scanner.pos = stream.pos;\n            scanner.start = stream.start;\n            scanner.end = stream.string.length;\n\n            const token = getToken(scanner, state.brackets === 0);\n\n            if (!token) {\n                return unexpectedCharacter(stream, state);\n            }\n\n            if (token.type === 'Bracket') {\n                state.brackets += token.open ? 1 : -1;\n                if (state.brackets < 0) {\n                    return unexpectedCharacter(stream, state, 'Unexpected bracket');\n                }\n            }\n\n            stream.pos = scanner.pos;\n\n            const name = getTokenName(token, state);\n            state.tokens.push(token);\n            return name;\n        }\n    }\n}\n\n/**\n * Returns scope name for given token\n */\nfunction getTokenName(token: AllTokens, state: EmmetStylesheetModeState): string | null {\n    switch (token.type) {\n        case 'Bracket':\n            return `bracket`;\n        case 'Field':\n            return 'variable-2';\n        case 'Literal':\n            return 'tag';\n        case 'Operator':\n            return `operator ${token.operator}`;\n        case 'ColorValue':\n            return 'variable-3';\n        case 'NumberValue':\n            return 'number';\n        case 'StringValue':\n            return 'string';\n    }\n\n    return null;\n}\n","/**\n * Emmet snippet name parsing mode\n */\nexport default function snippetNameMode(): CodeMirror.Mode<{}> {\n    return {\n        token(stream) {\n            if (stream.eatWhile(ident)) {\n                return 'tag';\n            }\n\n            if (stream.eat(separator)) {\n                return 'operator';\n            }\n\n            stream.skipToEnd();\n            return 'invalidchar';\n        }\n    };\n}\n\nfunction ident(ch: string): boolean {\n    return /[a-zA-Z0-9-_$@!:]/.test(ch);\n}\n\nfunction separator(ch: string): boolean {\n    return ch === '|';\n}\n","import { UserConfig } from 'emmet';\nimport { TextRange, AbbreviationTrackerType } from '@emmetio/action-utils';\nimport { pass, getCaret, replaceWithSnippet } from '../lib/utils';\nimport getEmmetConfig from '../lib/config';\nimport { getTracker, stopTracking, contains, runInTrackerContext } from '../abbreviation';\nimport { expand, extract, getOptions } from '../lib/emmet';\nimport { getSyntaxType } from '../lib/syntax';\n// import { getActivationContext } from '../abbreviation';\n\nexport default function expandAbbreviation(editor: CodeMirror.Editor, tabKey?: boolean) {\n    if (editor.somethingSelected()) {\n        return pass(editor);\n    }\n\n    if (tabKey) {\n        return expandAbbreviationWithTab(editor);\n    }\n\n    const caret = getCaret(editor);\n    const pos = editor.posFromIndex(caret);\n    const line = editor.getLine(pos.line);\n    const options = getOptions(editor, caret);\n    const abbr = extract(line, pos.ch, getSyntaxType(options.syntax));\n\n    if (abbr) {\n        const offset = caret - pos.ch;\n        runExpand(editor, abbr.abbreviation, [abbr.start + offset, abbr.end + offset], options);\n    }\n}\n\nfunction expandAbbreviationWithTab(editor: CodeMirror.Editor) {\n    // With Tab key, we should either expand tracked abbreviation\n    // or extract abbreviation from current location if abbreviation marking\n    // is not available\n    const caret = getCaret(editor);\n    if (getEmmetConfig(editor).mark) {\n        const tracker = getTracker(editor);\n\n        if (tracker && contains(tracker, caret) && tracker.type === AbbreviationTrackerType.Abbreviation) {\n            runExpand(editor, tracker.abbreviation, tracker.range, tracker.config);\n            stopTracking(editor, { skipRemove: true });\n            return;\n        }\n        return pass(editor);\n    }\n\n    return runInTrackerContext(editor, (controller, proxy) => {\n        const options = controller.getActivationContext(proxy, caret);\n        if (options) {\n            const pos = editor.posFromIndex(caret);\n            const line = editor.getLine(pos.line);\n            const abbr = extract(line, pos.ch, getSyntaxType(options.syntax));\n            if (abbr) {\n                const offset = caret - pos.ch;\n                runExpand(editor, abbr.abbreviation, [abbr.start + offset, abbr.end + offset], options);\n                return;\n            }\n        }\n        return pass(editor);\n    });\n}\n\nfunction runExpand(editor: CodeMirror.Editor, abbr: string, range: TextRange, options?: UserConfig) {\n    const snippet = expand(editor, abbr, options);\n    replaceWithSnippet(editor, range, snippet);\n}\n","import { getTracker, stopTracking } from '../abbreviation';\nimport { pass } from '../lib/utils';\n\nexport default function resetAbbreviation(editor: CodeMirror.Editor) {\n    const tracker = getTracker(editor);\n    if (tracker) {\n        stopTracking(editor, { force: true });\n    } else {\n        return pass(editor);\n    }\n}\n","import { getCaret } from '../lib/utils';\nimport { extractTracker, stopTracking } from '../abbreviation';\n\nexport default function captureAbbreviation(editor: CodeMirror.Editor) {\n    stopTracking(editor);\n    extractTracker(editor, getCaret(editor));\n}\n","import { getTracker, stopTracking, startTracking } from '../abbreviation';\nimport { textRange } from '../lib/utils';\n\nexport default function enterAbbreviationMode(editor: CodeMirror.Editor) {\n    let tracker = getTracker(editor);\n    stopTracking(editor);\n    if (tracker && tracker.forced) {\n        // Already have forced abbreviation: act as toggler\n        return;\n    }\n\n    const [from, to] = textRange(editor, editor.listSelections()[0]);\n\n    tracker = startTracking(editor, from, to, { forced: true });\n    if (from !== to) {\n        editor.setSelection(editor.posFromIndex(to));\n    }\n}\n","import { pass } from '../lib/utils';\nimport { getIndentation, lineIndent } from '../lib/output';\n\ninterface Sel {\n    anchor: CodeMirror.Position;\n    head: CodeMirror.Position;\n}\n\nexport default function insertLineBreak(editor: CodeMirror.Editor) {\n    const between = editor.listSelections().map(sel => betweenTags(editor, sel.anchor, sel.head));\n\n    if (!between.some(Boolean)) {\n        return pass(editor);\n    }\n\n    editor.operation(() => {\n        const sels = editor.listSelections();\n        // @ts-ignore Invalid docs for Document\n        const nl = editor.getDoc().lineSeparator();\n        const indent = getIndentation(editor);\n\n        // Step 1: insert newlines either single or double depending on selection\n        const nextSels: Sel[] = [];\n        for (let i = sels.length - 1; i >= 0; i--) {\n            const sel = sels[i];\n            const base = lineIndent(editor, sel.anchor.line);\n            let nextIndent = base;\n            if (between[i]) {\n                nextIndent += indent;\n                editor.replaceRange( nl + nextIndent + nl + base, sel.anchor, sel.head);\n            } else {\n                editor.replaceRange(nl + base, sel.anchor, sel.head);\n            }\n\n            const nextPos: CodeMirror.Position = {\n                line: sel.anchor.line + 1,\n                ch: nextIndent.length\n            };\n            nextSels.unshift({ anchor: nextPos, head: nextPos });\n        }\n\n        editor.setSelections(nextSels);\n    });\n}\n\n/**\n * Check if given range is a single caret between tags\n */\nfunction betweenTags(editor: CodeMirror.Editor, anchor: CodeMirror.Position, head: CodeMirror.Position) {\n    if (equalCursorPos(anchor, head)) {\n        const mode = editor.getModeAt(anchor);\n\n        if (mode.name === 'xml') {\n            const left = editor.getTokenAt(anchor);\n            const right = editor.getTokenAt(Object.assign({}, anchor, { ch: anchor.ch + 1 }));\n\n            return left.type === 'tag bracket' && left.string === '>'\n                && right.type === 'tag bracket' && right.string === '</';\n        }\n    }\n}\n\n// Compare two positions, return 0 if they are the same, a negative\n// number when a is less, and a positive number otherwise.\nfunction cmp(a: CodeMirror.Position, b: CodeMirror.Position) {\n    return a.line - b.line || a.ch - b.ch;\n}\n\nfunction equalCursorPos(a: CodeMirror.Position, b: CodeMirror.Position) {\n    return a.sticky === b.sticky && cmp(a, b) === 0;\n}\n","import { TextRange } from '@emmetio/action-utils';\nimport { getOptions, getTagContext, ContextTag, expand } from '../lib/emmet';\nimport { getCaret, narrowToNonSpace, replaceWithSnippet, substr, errorSnippet, textRange } from '../lib/utils';\nimport { docSyntax, isXML } from '../lib/syntax';\nimport { lineIndent } from '../lib/output';\n\nconst baseClass = 'emmet-panel';\nconst errClass = 'emmet-error';\n\nexport default function wrapWithAbbreviation(editor: CodeMirror.Editor) {\n    const syntax = docSyntax(editor);\n    const caret = getCaret(editor);\n    const context = getTagContext(editor, caret, isXML(syntax));\n    const wrapRange = getWrapRange(editor, getSelection(editor), context);\n    const options = getOptions(editor, wrapRange[0]);\n    options.text = getContent(editor, wrapRange, true);\n\n    let panel = createInputPanel();\n    let input = panel.querySelector('input')!;\n    let errContainer = panel.querySelector(`.${baseClass}-error`)!;\n    let updated = false;\n\n    function onInput(evt: InputEvent) {\n        evt && evt.stopPropagation();\n        undo();\n        const abbr = input.value.trim();\n        if (!abbr) {\n            return;\n        }\n\n        try {\n            const snippet = expand(editor, abbr, options);\n            replaceWithSnippet(editor, wrapRange, snippet);\n            updated = true;\n            if (panel.classList.contains(errClass)) {\n                errContainer.innerHTML = '';\n                panel.classList.remove(errClass);\n            }\n        } catch (err) {\n            updated = false;\n            panel.classList.add(errClass);\n            errContainer.innerHTML = errorSnippet(err);\n            console.error(err);\n        }\n    };\n\n    function onKeyDown(evt: KeyboardEvent) {\n        if (evt.keyCode === 27 /* ESC */) {\n            evt.stopPropagation();\n            evt.preventDefault();\n            cancel();\n        } else if (evt.keyCode === 13 /* Enter */) {\n            evt.stopPropagation();\n            evt.preventDefault();\n            submit();\n        }\n    };\n\n    function undo() {\n        if (updated) {\n            editor.undo();\n        }\n    }\n\n    function cancel() {\n        undo();\n        dispose();\n        editor.focus();\n    }\n\n    function submit() {\n        // Changes should already be applied to editor\n        dispose();\n        editor.focus();\n    }\n\n    function dispose() {\n        input.removeEventListener('input', onInput);\n        input.removeEventListener('change', onInput);\n        input.removeEventListener('paste', onInput);\n        input.removeEventListener('keydown', onKeyDown);\n        input.removeEventListener('blur', cancel);\n        panel.remove();\n        // @ts-ignore Dispose element references\n        panel = input = errContainer = null;\n    }\n\n    // Expose internals to programmatically submit or cancel command\n    panel['emmet'] = { submit, cancel, update: onInput };\n\n    input.addEventListener('input', onInput);\n    input.addEventListener('change', onInput);\n    input.addEventListener('paste', onInput);\n    input.addEventListener('keydown', onKeyDown);\n    editor.getWrapperElement().appendChild(panel);\n    input.focus();\n}\n\nfunction createInputPanel(): HTMLElement {\n    const elem = document.createElement('div');\n    elem.className = baseClass;\n    elem.innerHTML = `<div class=\"${baseClass}-wrapper\">\n        <input type=\"text\" placeholder=\"Enter abbreviation\" autofocus />\n        <div class=\"${baseClass}-error\"></div>\n    </div>`;\n    return elem;\n}\n\nfunction getWrapRange(editor: CodeMirror.Editor, range: TextRange, context?: ContextTag): TextRange {\n    if (range[0] === range[1] && context) {\n        // No selection means user wants to wrap current tag container\n        const { open, close } = context;\n        const pos = range[0];\n\n        // Check how given point relates to matched tag:\n        // if it's in either open or close tag, we should wrap tag itself,\n        // otherwise we should wrap its contents\n\n        if (inRange(open, pos) || (close && inRange(close, pos))) {\n            return [open[0], close ? close[1] : open[1]];\n        }\n\n        if (close) {\n            return narrowToNonSpace(editor, [open[1], close[0]]);\n        }\n    }\n\n    return range;\n}\n\n/**\n * Returns contents of given region, properly de-indented\n */\nfunction getContent(editor: CodeMirror.Editor, range: TextRange, lines = false): string | string[] {\n    const pos = editor.posFromIndex(range[0]);\n    const baseIndent = lineIndent(editor, pos.line);\n    const srcLines = substr(editor, range).split('\\n');\n    const destLines = srcLines.map(line => {\n        return line.startsWith(baseIndent)\n            ? line.slice(baseIndent.length)\n            : line;\n    });\n\n    return lines ? destLines : destLines.join('\\n');\n}\n\nfunction inRange(range: TextRange, pt: number): boolean {\n    return range[0] < pt && pt < range[1];\n}\n\nfunction getSelection(editor: CodeMirror.Editor): TextRange {\n    return textRange(editor, editor.listSelections()[0]);\n}\n","import { TextRange } from '@emmetio/action-utils';\nimport { isCSS, isXML, docSyntax, isHTML } from '../lib/syntax';\nimport { balanceCSS, balance } from '../lib/emmet';\nimport { getContent, textRange, rangeContains, rangesEqual, pass } from '../lib/utils';\n\nexport default function balanceAction(editor: CodeMirror.Editor, inward?: boolean) {\n    const syntax = docSyntax(editor);\n\n    if (isHTML(syntax) || isCSS(syntax)) {\n        const ranges = inward\n            ? balanceActionInward(editor, syntax)\n            : balanceActionOutward(editor, syntax);\n\n        editor.setSelections(ranges.map(r => ({\n            anchor: editor.posFromIndex(r[0]),\n            head: editor.posFromIndex(r[1]),\n        })));\n    } else {\n        return pass(editor);\n    }\n}\n\n/**\n * Pushes given `range` into `ranges` list on if it’s not the same as last one\n */\nfunction pushRange(ranges: TextRange[], range: TextRange) {\n    const last = ranges[ranges.length - 1];\n    if (!last || !rangesEqual(last, range)) {\n        ranges.push(range);\n    }\n}\n\n/**\n * Returns regions for balancing\n */\nfunction getRanges(editor: CodeMirror.Editor, pos: number, syntax: string, inward?: boolean): TextRange[] {\n    const content = getContent(editor);\n    if (isCSS(syntax)) {\n        return balanceCSS(content, pos, inward);\n    }\n\n    const result: TextRange[] = [];\n    const tags = balance(content, pos, inward, isXML(syntax));\n\n    for (const tag of tags) {\n        if (tag.close) {\n            // Inner range\n            pushRange(result, [tag.open[1], tag.close[0]]);\n            // Outer range\n            pushRange(result, [tag.open[0], tag.close[1]]);\n        } else {\n            pushRange(result, [tag.open[0], tag.open[1]]);\n        }\n    }\n\n    return result.sort((a, b) => {\n        return inward ? a[0] - b[0] : b[0] - a[0];\n    });\n}\n\n/**\n * Returns inward balanced ranges from current view's selection\n */\nfunction balanceActionInward(editor: CodeMirror.Editor, syntax: string): TextRange[] {\n    const result: TextRange[] = [];\n\n    for (const sel of editor.listSelections()) {\n        const selRange = textRange(editor, sel);\n        const ranges = getRanges(editor, selRange[0], syntax, true);\n\n        // Try to find range which equals to selection: we should pick leftmost\n        let ix = ranges.findIndex(r => rangesEqual(selRange, r));\n        let targetRange: TextRange | undefined;\n\n        if (ix < ranges.length - 1) {\n            targetRange = ranges[ix + 1];\n        } else if (ix !== -1) {\n            // No match found, pick closest region\n            targetRange = ranges.find(r => rangeContains(r, selRange));\n        }\n\n        result.push(targetRange || selRange);\n    }\n\n    return result;\n}\n\n/**\n * Returns outward balanced ranges from current view's selection\n */\nfunction balanceActionOutward(editor: CodeMirror.Editor, syntax: string): TextRange[] {\n    const result: TextRange[] = [];\n    for (const sel of editor.listSelections()) {\n        const selRange = textRange(editor, sel);\n        const ranges = getRanges(editor, selRange[0], syntax);\n        const targetRange = ranges.find(r => rangeContains(r, selRange) && r[1] > selRange[1]);\n        result.push(targetRange || selRange);\n    }\n\n    return result;\n}\n\n","import Scanner from '@emmetio/scanner';\nimport { scan, createOptions, ElementType, ScannerOptions } from '@emmetio/html-matcher';\nimport matchCSS from '@emmetio/css-matcher';\nimport { TextRange } from '@emmetio/action-utils';\nimport { isSpace, getContent, narrowToNonSpace, textRange, rangeEmpty, substr, toRange } from '../lib/utils';\nimport { isHTML, isXML, isCSS, syntaxInfo } from '../lib/syntax';\n\ninterface Block {\n    range: TextRange;\n    commentStart?: string;\n    commentEnd?: string;\n}\n\ninterface Tag {\n    name: string;\n    start: number;\n    end: number;\n}\n\ntype CommentTokens = [string, string];\n\nconst htmlComment: CommentTokens = ['<!--', '-->'];\nconst cssComment: CommentTokens = ['/*', '*/'];\n\nexport default function comment(editor: CodeMirror.Editor) {\n    const selection = editor.listSelections().slice().reverse();\n    editor.operation(() => {\n        for (const sel of selection) {\n            const selRange = textRange(editor, sel);\n            const { syntax } = syntaxInfo(editor, selRange[0]);\n            const tokens = syntax && isCSS(syntax) ? cssComment : htmlComment;\n            const block = getRangeForComment(editor, selRange[0]);\n\n            if (block && block.commentStart) {\n                // Caret inside comment, strip it\n                removeComment(editor, block);\n            } else if (block && rangeEmpty(selRange)) {\n                // Wrap block with comments but remove inner comments first\n                let removed = 0;\n                for (const c of getCommentRegions(editor, block.range, tokens).reverse()) {\n                    removed += removeComment(editor, c);\n                }\n\n                addComment(editor, [block.range[0], block.range[1] - removed], tokens);\n            } else if (!rangeEmpty(selRange)) {\n                // No matching block, comment selection\n                addComment(editor, selRange, tokens);\n            } else {\n                // No matching block, comment line\n\n                const line = editor.getLine(sel.anchor.line);\n                const lineRange = textRange(editor, {\n                    anchor: { line: sel.anchor.line, ch: 0 },\n                    head: { line: sel.anchor.line, ch: line.length },\n                })\n                addComment(editor, narrowToNonSpace(editor, lineRange), tokens);\n            }\n        }\n    });\n}\n\n/**\n * Removes comment markers from given region. Returns amount of characters removed\n */\nfunction removeComment(editor: CodeMirror.Editor, { range, commentStart, commentEnd }: Block): number {\n    const text = substr(editor, range);\n\n    if (commentStart && text.startsWith(commentStart)) {\n        let startOffset = commentStart.length;\n        let endOffset = commentEnd && text.endsWith(commentEnd)\n            ? commentEnd.length\n            : 0;\n\n        // Narrow down offsets for whitespace\n        if (isSpace(text[startOffset])) {\n            startOffset += 1;\n        }\n\n        if (endOffset && isSpace(text[text.length - endOffset - 1])) {\n            endOffset += 1;\n        }\n\n        const r1 = toRange(editor, [range[1] - endOffset, range[1]]);\n        const r2 = toRange(editor, [range[0], range[0] + startOffset]);\n        editor.replaceRange('', r1[0], r1[1]);\n        editor.replaceRange('', r2[0], r2[1]);\n\n        return startOffset + endOffset;\n    }\n\n    return 0;\n}\n\n/**\n * Adds comments around given range\n */\nfunction addComment(editor: CodeMirror.Editor, range: TextRange, tokens: CommentTokens) {\n    const [from, to] = toRange(editor, range);\n    editor.replaceRange(' ' + tokens[1], to, to);\n    editor.replaceRange(tokens[0] + ' ', from, from);\n}\n\n/**\n * Finds comments inside given region and returns their regions\n */\nfunction getCommentRegions(editor: CodeMirror.Editor, range: TextRange, tokens: CommentTokens): Block[] {\n    const result: Block[] = [];\n    const text = substr(editor, range);\n    let start = range[0];\n    let offset = 0\n\n    while (true) {\n        const commentStart = text.indexOf(tokens[0], offset);\n        if (commentStart !== -1) {\n            offset = commentStart + tokens[0].length;\n\n            // Find comment end\n            const commentEnd = text.indexOf(tokens[1], offset);\n            if (commentEnd !== -1) {\n                offset = commentEnd + tokens[1].length;\n                result.push({\n                    range: [start + commentStart, start + offset],\n                    commentStart: tokens[0],\n                    commentEnd: tokens[1],\n                });\n            }\n        } else {\n            break;\n        }\n    }\n\n    return result;\n}\n\nfunction getRangeForComment(editor: CodeMirror.Editor, pos: number): Block | undefined {\n    const { syntax } = syntaxInfo(editor, pos);\n    if (!syntax) {\n        return;\n    }\n\n    if (isHTML(syntax)) {\n        return getHTMLBlockRange(getContent(editor), pos, isXML(syntax));\n    }\n\n    if (isCSS(syntax)) {\n        const content = getContent(editor);\n        const comment = findCSSComment(content, pos);\n        if (comment) {\n            return comment;\n        }\n\n        const css = matchCSS(content, pos);\n        if (css) {\n            return {\n                range: [css.start, css.end]\n            };\n        }\n    }\n}\n\n/**\n * Returns range for comment toggling\n */\nfunction getHTMLBlockRange(source: string, pos: number, xml = false): Block | undefined {\n    // Since we expect large input document, we’ll use pooling technique\n    // for storing tag data to reduce memory pressure and improve performance\n    const pool: Tag[] = [];\n    const stack: Tag[] = [];\n    const options = createOptions({ xml, allTokens: true });\n    let result: Block | undefined;\n\n    scan(source, (name, type, start, end) => {\n        if (type === ElementType.Open && isSelfClose(name, options)) {\n            // Found empty element in HTML mode, mark is as self-closing\n            type = ElementType.SelfClose;\n        }\n\n        if (type === ElementType.Open) {\n            // Allocate tag object from pool\n            stack.push(allocTag(pool, name, start, end));\n        } else if (type === ElementType.SelfClose) {\n            if (start < pos && pos < end) {\n                // Matched given self-closing tag\n                result = { range: [start, end] };\n                return false;\n            }\n        } else if (type === ElementType.Close) {\n            const tag = last(stack);\n            if (tag && tag.name === name) {\n                // Matching closing tag found\n                if (tag.start < pos && pos < end) {\n                    result = {\n                        range: [tag.start, end],\n                    };\n                    return false;\n                } else if (stack.length) {\n                    // Release tag object for further re-use\n                    releaseTag(pool, stack.pop()!);\n                }\n            }\n        } else if (start < pos && pos < end) {\n            // Found other token that matches given location\n            result = { range: [start, end] };\n            if (type === ElementType.Comment) {\n                result.commentStart = htmlComment[0];\n                result.commentEnd = htmlComment[1];\n            }\n            return false;\n        }\n    }, options);\n\n    stack.length = pool.length = 0;\n    return result;\n}\n\n/**\n * If given `pos` location is inside CSS comment in given `code`, returns its\n * range\n */\nfunction findCSSComment(code: string, pos: number): Block | undefined {\n    const enum Chars {\n        Asterisk = 42,\n        Slash = 47,\n        Backslash = 92,\n        LF = 10,\n        CR = 13,\n    };\n    const scanner = new Scanner(code);\n\n    while (!scanner.eof() && pos > scanner.pos) {\n        const start = scanner.pos;\n\n        if (consumeSeq2(scanner, Chars.Slash, Chars.Asterisk)) {\n            // Consumed multiline comment start\n            while (!scanner.eof() && !consumeSeq2(scanner, Chars.Asterisk, Chars.Slash)) {\n                scanner.pos++;\n            }\n\n            if (start < pos && pos < scanner.pos) {\n                return {\n                    range: [start, scanner.pos],\n                    commentStart: cssComment[0],\n                    commentEnd: cssComment[1],\n                };\n            }\n        } else if (consumeSeq2(scanner, Chars.Slash, Chars.Slash)) {\n            // Consumed single-line comment\n            while (!scanner.eof() && !scanner.eat(Chars.CR) && !scanner.eat(Chars.LF)) {\n                scanner.pos++;\n            }\n            if (start < pos && pos < scanner.pos) {\n                return {\n                    range: [start, scanner.pos],\n                    commentStart: '//',\n                };\n            }\n        } else {\n            scanner.pos++;\n        }\n    }\n}\n\n/**\n * Returns `true` if both `ch1` and `ch2` where consumed\n */\nfunction consumeSeq2(scanner: Scanner, ch1: number, ch2: number): boolean {\n    const { pos } = scanner;\n    if (scanner.eat(ch1) && scanner.eat(ch2)) {\n        return true;\n    }\n\n    scanner.pos = pos;\n    return false;\n}\n\n/**\n * Check if given tag is self-close for current parsing context\n */\nfunction isSelfClose(name: string, options: ScannerOptions) {\n    return !options.xml && options.empty.includes(name);\n}\n\nfunction allocTag(pool: Tag[], name: string, start: number, end: number): Tag {\n    if (pool.length) {\n        const tag = pool.pop()!;\n        tag.name = name;\n        tag.start = start;\n        tag.end = end;\n        return tag;\n    }\n    return { name, start, end };\n}\n\nfunction releaseTag(pool: Tag[], tag: Tag) {\n    pool.push(tag);\n}\n\nfunction last<T>(arr: T[]): T | null {\n    return arr.length ? arr[arr.length - 1] : null;\n}\n","import { evaluateMath } from '../lib/emmet';\n\nexport default function evaluateMathCommand(editor: CodeMirror.Editor) {\n    const cursor = editor.getCursor();\n    const line = editor.getLine(cursor.line);\n    const expr = evaluateMath(line, cursor.ch);\n\n    if (expr) {\n        const from = { line: cursor.line, ch: expr.start };\n        const to = { line: cursor.line, ch: expr.end };\n        editor.replaceRange(expr.snippet, from, to);\n    }\n}\n","import { getContent, isQuote, isSpace, getCaret } from '../lib/utils';\n\nexport default function goToEditPoint(editor: CodeMirror.Editor, inc: number) {\n    const caret = getCaret(editor);\n    const pos = findNewEditPoint(editor, caret + inc, inc);\n    if (pos != null) {\n        editor.setCursor(editor.posFromIndex(pos));\n    }\n}\n\nfunction findNewEditPoint(editor: CodeMirror.Editor, pos: number, inc: number): number | undefined {\n    const doc = getContent(editor);\n    const docSize = doc.length;\n    let curPos = pos;\n\n    while (curPos < docSize && curPos >= 0) {\n        curPos += inc;\n        const cur = doc[curPos];\n        const next = doc[curPos + 1];\n        const prev = doc[curPos - 1];\n\n        if (isQuote(cur) && next === cur && prev === '=') {\n            // Empty attribute value\n            return curPos + 1;\n        }\n\n        if (cur === '<' && prev === '>') {\n            // Between tags\n            return curPos;\n        }\n\n        if (isNewLine(cur)) {\n            const pt = editor.posFromIndex(curPos);\n            const line = editor.getLine(pt.line);\n            if (!line || isSpace(line)) {\n                // Empty line\n                return editor.indexFromPos({\n                    line: pt.line,\n                    ch: line.length\n                });\n            }\n        }\n    }\n}\n\nfunction isNewLine(ch: string) {\n    return ch === '\\r' || ch === '\\n';\n}\n","import { TextRange } from '@emmetio/action-utils';\nimport { getCaret, substr } from '../lib/utils';\nimport { isHTML, isXML, syntaxInfo } from '../lib/syntax';\nimport { getTagContext } from '../lib/emmet';\n\nexport default function goToTagPair(editor: CodeMirror.Editor) {\n    let caret = getCaret(editor);\n    const nextRange: TextRange = [caret, Math.min(caret + 1, editor.getValue().length)];\n    if (substr(editor, nextRange) === '<') {\n        caret++;\n    }\n\n    const { syntax } = syntaxInfo(editor, caret);\n    if (isHTML(syntax)) {\n        const ctx = getTagContext(editor, caret, isXML(syntax));\n        if (ctx && ctx.open && ctx.close) {\n            const { open, close } = ctx;\n            const nextPos = open[0] <= caret && caret < open[1]\n                ? close[0]\n                : open[0];\n\n            editor.setCursor(editor.posFromIndex(nextPos));\n        }\n    }\n}\n","import { isNumber } from '@emmetio/scanner';\nimport { textRange, rangeEmpty, substr, replaceWithSnippet } from '../lib/utils';\n\nexport default function incrementNumber(editor: CodeMirror.Editor, delta = 1) {\n    editor.operation(() => {\n        const nextRanges = editor.listSelections().slice().reverse().map(sel => {\n            let selRange = textRange(editor, sel);\n            if (rangeEmpty(selRange)) {\n                // No selection, extract number\n                const line = editor.getLine(sel.anchor.line);\n                const offset = sel.anchor.ch;\n                const numRange = extractNumber(line, offset);\n                if (numRange) {\n                    selRange = [\n                        selRange[0] - offset + numRange[0],\n                        selRange[0] - offset + numRange[1],\n                    ]\n                }\n            }\n\n            if (!rangeEmpty(selRange)) {\n                // Try to update value in given region\n                let value = updateNumber(substr(editor, selRange), delta);\n                replaceWithSnippet(editor, selRange, value);\n                sel = {\n                    anchor: editor.posFromIndex(selRange[0]),\n                    head: editor.posFromIndex(selRange[0] + value.length)\n                };\n            }\n\n            return sel;\n        });\n\n        editor.setSelections(nextRanges);\n    });\n}\n\n/**\n * Extracts number from text at given location\n */\nfunction extractNumber(text: string, pos: number): [number, number] | undefined {\n    let hasDot = false;\n    let end = pos;\n    let start = pos;\n    let ch: number;\n    const len = text.length;\n\n    // Read ahead for possible numbers\n    while (end < len) {\n        ch = text.charCodeAt(end);\n        if (isDot(ch)) {\n            if (hasDot) {\n                break;\n            }\n            hasDot = true;\n        } else if (!isNumber(ch)) {\n            break;\n        }\n        end++;\n    }\n\n    // Read backward for possible numerics\n    while (start >= 0) {\n        ch = text.charCodeAt(start - 1);\n        if (isDot(ch)) {\n            if (hasDot) {\n                break;\n            }\n            hasDot = true;\n        } else if (!isNumber(ch)) {\n            break;\n        }\n        start--;\n    }\n\n    // Negative number?\n    if (start > 0 && text[start - 1] === '-') {\n        start--;\n    }\n\n    if (start !== end) {\n        return [start, end];\n    }\n}\n\nfunction updateNumber(num: string, delta: number, precision = 3): string {\n    const value = parseFloat(num) + delta;\n\n    if (isNaN(value)) {\n        return num;\n    }\n\n    const neg = value < 0;\n    let result = Math.abs(value).toFixed(precision);\n\n    // Trim trailing zeroes and optionally decimal number\n    result = result.replace(/\\.?0+$/, '');\n\n    // Trim leading zero if input value doesn't have it\n    if ((num[0] === '.' || num.startsWith('-.')) && result[0] === '0') {\n        result = result.slice(1);\n    }\n\n    return (neg ? '-' : '') + result;\n}\n\nfunction isDot(ch: number) {\n    return ch === 46;\n}\n","import { TextRange } from '@emmetio/action-utils';\nimport { getTagContext, ContextTag } from '../lib/emmet';\nimport { narrowToNonSpace, isSpace as isSpaceText, replaceWithSnippet, substr, rangeEmpty } from '../lib/utils';\nimport { lineIndent } from '../lib/output';\n\nexport default function removeTagCommand(editor: CodeMirror.Editor) {\n    editor.operation(() => {\n        const nextRanges = editor.listSelections().slice().reverse().map(sel => {\n            const tag = getTagContext(editor, editor.indexFromPos(sel.anchor));\n            if (tag) {\n                removeTag(editor, tag);\n                const pos = editor.posFromIndex(tag.open[0]);\n                return {\n                    anchor: pos,\n                    head: pos\n                };\n            }\n\n            return sel;\n        });\n\n        editor.setSelections(nextRanges);\n    });\n}\n\nfunction removeTag(editor: CodeMirror.Editor, { open, close }: ContextTag) {\n    if (close) {\n        // Remove open and close tag and dedent inner content\n        const innerRange = narrowToNonSpace(editor, [open[1], close[0]]);\n        if (!rangeEmpty(innerRange)) {\n            // Gracefully remove open and close tags and tweak indentation on tag contents\n            replaceWithSnippet(editor, [innerRange[1], close[1]], '');\n\n            const start = editor.posFromIndex(open[0]);\n            const end = editor.posFromIndex(close[1]);\n            if (start.line !== end.line) {\n                // Skip two lines: first one for open tag, on second one\n                // indentation will be removed with open tag\n                let line = start.line + 2;\n                const baseIndent = getLineIndent(editor, open[0]);\n                const innerIndent = getLineIndent(editor, innerRange[0]);\n\n                while (line <= end.line) {\n                    const lineStart = editor.indexFromPos({ line, ch: 0 });\n                    const indentRange: TextRange = [lineStart, lineStart + innerIndent.length];\n                    if (isSpaceText(substr(editor, indentRange))) {\n                        console.log('replace \"%s\" with \"%s\"', substr(editor, indentRange), baseIndent);\n                        replaceWithSnippet(editor, indentRange, baseIndent);\n                    }\n                    line++;\n                }\n            }\n\n            replaceWithSnippet(editor, [open[0], innerRange[0]], '');\n        } else {\n            replaceWithSnippet(editor, [open[0], close[1]], '');\n        }\n    } else {\n        replaceWithSnippet(editor, open, '');\n    }\n}\n\n/**\n * Returns indentation for line found from given character location\n */\nfunction getLineIndent(editor: CodeMirror.Editor, ix: number): string {\n    return lineIndent(editor, editor.posFromIndex(ix).line);\n}\n\n","import { TextRange } from '@emmetio/action-utils';\nimport { isCSS, isHTML, docSyntax } from '../lib/syntax';\nimport { getContent, toRange, textRange, rangesEqual, rangeContains } from '../lib/utils';\nimport { selectItem } from '../lib/emmet';\n\nexport default function selectItemCommand(editor: CodeMirror.Editor, isPrev = false) {\n    const syntax = docSyntax(editor);\n\n    if (!isCSS(syntax) && !isHTML(syntax)) {\n        return;\n    }\n\n    const sel = editor.listSelections()[0];\n    const selRange = textRange(editor, sel);\n    const code = getContent(editor);\n    let model = selectItem(code, selRange[0], isCSS(syntax), isPrev);\n\n    if (model) {\n        let range = findRange(selRange, model.ranges, isPrev);\n        if (!range) {\n            // Out of available selection range, move to next item\n            const nextPos = isPrev ? model.start : model.end;\n            model = selectItem(code, nextPos, isCSS(syntax), isPrev);\n            if (model) {\n                range = findRange(selRange, model.ranges, isPrev)\n            }\n        }\n\n        if (range) {\n            const [from, to] = toRange(editor, range);\n            editor.setSelection(from, to);\n        }\n    }\n}\n\nfunction findRange(sel: TextRange, ranges: TextRange[], reverse = false) {\n    if (reverse) {\n        ranges = ranges.slice().reverse();\n    }\n\n    let getNext = false;\n    let candidate: TextRange | undefined;\n\n    for (const r of ranges) {\n        if (getNext) {\n            return r;\n        }\n        if (  rangesEqual(r, sel)) {\n            // This range is currently selected, request next\n            getNext = true;\n        } else if (!candidate && (rangeContains(r, sel) || (reverse && r[0] <= sel[0]) || (!reverse && r[0] >= sel[0]))) {\n            candidate = r;\n        }\n    }\n\n    if (!getNext) {\n        return candidate;\n    }\n}\n","import { isXML, syntaxInfo } from '../lib/syntax';\nimport { getTagContext } from '../lib/emmet';\nimport { isSpace, substr, replaceWithSnippet, CMRange } from '../lib/utils';\n\nexport default function splitJoinTag(editor: CodeMirror.Editor) {\n    const selections = editor.listSelections().slice().reverse();\n    const nextRanges: CMRange[] = [];\n\n    editor.operation(() => {\n        for (const sel of selections) {\n            const pos = editor.indexFromPos(sel.anchor);\n            const { syntax } = syntaxInfo(editor, pos);\n            const tag = getTagContext(editor, pos, isXML(syntax));\n\n            if (tag) {\n                const { open, close } = tag;\n                if (close) {\n                    // Join tag: remove tag contents, if any, and add closing slash\n                    replaceWithSnippet(editor, [open[1], close[1]], '');\n                    let closing = isSpace(getChar(editor, open[1] - 2)) ? '/' : ' /';\n                    replaceWithSnippet(editor, [open[1] - 1, open[1] - 1], closing);\n                    nextRanges.push(createRange(editor, open[1] + closing.length));\n                } else {\n                    // Split tag: add closing part and remove closing slash\n                    const endTag = `</${tag.name}>`;\n\n                    replaceWithSnippet(editor, [open[1], open[1]], endTag);\n                    if (getChar(editor, open[1] - 2) === '/') {\n                        let start = open[1] - 2;\n                        let end = open[1] - 1;\n                        if (isSpace(getChar(editor, start - 1))) {\n                            start--;\n                        }\n\n                        replaceWithSnippet(editor, [start, end], '');\n                        nextRanges.push(createRange(editor, open[1] - end + start));\n                    } else {\n                        nextRanges.push(createRange(editor, open[1]));\n                    }\n                }\n            } else {\n                nextRanges.push(sel);\n            }\n        }\n        editor.setSelections(nextRanges);\n    });\n}\n\nfunction getChar(editor: CodeMirror.Editor, pos: number): string {\n    return substr(editor, [pos, pos + 1]);\n}\n\nfunction createRange(editor: CodeMirror.Editor, pos: number): CMRange {\n    const p = editor.posFromIndex(pos);\n    return {\n        anchor: p,\n        head: p\n    };\n}\n","import { UserConfig } from 'emmet';\nimport { parse as parseMarkup, tokenize as tokenizeMarkup, MarkupAbbreviation } from '@emmetio/abbreviation';\nimport { parser as parseStylesheet, tokenize as tokenizeStylesheet, CSSAbbreviation } from '@emmetio/css-abbreviation';\nimport CodeMirror from 'codemirror';\nimport getEmmetConfig, { defaultConfig, EmmetConfig, EmmetEditorOptions } from './lib/config';\n\nimport abbreviationTracker, { extractTracker, allowTracking, getCompletion, restoreOnUndo } from './abbreviation';\n\n// import { extractTracker, allowTracking } from './abbreviation';\n// import { startTracking } from './abbreviation/AbbreviationTracker';\n\nimport matchTags from './lib/match-tags';\nimport markupMode from './mode/markup';\nimport stylesheetMode from './mode/stylesheet';\nimport snippetMode from './mode/snippet';\n\nimport expandAbbreviation from './commands/expand-abbreviation';\nimport emmetResetAbbreviation from './commands/reset-abbreviation'\nimport emmetCaptureAbbreviation from './commands/capture-abbreviation'\nimport emmetEnterAbbreviationMode from './commands/enter-abbreviation';\nimport emmetInsertLineBreak from './commands/insert-line-break';\nimport emmetWrapWithAbbreviation from './commands/wrap-with-abbreviation';\nimport emmetBalance from './commands/balance';\nimport emmetToggleComment from './commands/comment';\nimport emmetEvaluateMath from './commands/evaluate-math';\nimport goToEditPoint from './commands/go-to-edit-point';\nimport emmetGoToTagPair from './commands/go-to-tag-pair';\nimport incrementNumber from './commands/inc-dec-number';\nimport emmetRemoveTag from './commands/remove-tag';\nimport selectItem from './commands/select-item';\nimport emmetSplitJoinTag from './commands/split-join-tag';\nimport { expand, getOptions } from './lib/emmet';\nimport { getInternalState, hasInternalState } from './lib/utils';\n\nexport interface EmmetEditor extends CodeMirror.Editor {\n    /**\n     * Expands given abbreviation with options, defined for current editor\n     */\n    expandAbbreviation(abbr: string, options?: UserConfig): string;\n    /**\n     * Returns Emmet config for given location in editor\n     */\n    emmetOptions(pos?: number, withContext?: boolean): UserConfig;\n\n    /** Parses given abbreviation to AST or throws exception if abbreviation is invalid */\n    parseAbbreviation(abbr: string, type: 'markup' | 'jsx'): MarkupAbbreviation;\n    parseAbbreviation(abbr: string, type: 'stylesheet'): CSSAbbreviation;\n    getEmmetCompletion(pos: number | CodeMirror.Position): CompletionItem;\n}\n\ninterface CompletionItem {\n    text: string;\n    displayText: string;\n    hint(): void;\n    from: CodeMirror.Position;\n    to: CodeMirror.Position;\n}\n\n/**\n * Registers Emmet extension on given CodeMirror constructor.\n * This file is designed to be imported somehow into the app (CommonJS, ES6,\n * Rollup/Webpack/whatever). If you simply want to add a <script> into your page\n * that registers Emmet extension on global CodeMirror constructor, use\n * `browser.js` instead\n */\nexport default function registerEmmetExtension(CM: typeof CodeMirror) {\n    // Register Emmet commands\n    Object.assign(CM.commands, {\n        emmetExpandAbbreviation: (editor: CodeMirror.Editor) => expandAbbreviation(editor, true),\n        emmetExpandAbbreviationAll: (editor: CodeMirror.Editor) => expandAbbreviation(editor, false),\n        emmetCaptureAbbreviation,\n        emmetResetAbbreviation,\n        emmetEnterAbbreviationMode,\n        emmetInsertLineBreak,\n        emmetWrapWithAbbreviation,\n        emmetBalance,\n        emmetBalanceInward: (editor: CodeMirror.Editor) => emmetBalance(editor, true),\n        emmetToggleComment,\n        emmetEvaluateMath,\n        emmetGoToNextEditPoint: (editor: CodeMirror.Editor) => goToEditPoint(editor, 1),\n        emmetGoToPreviousEditPoint: (editor: CodeMirror.Editor) => goToEditPoint(editor, -1),\n        emmetGoToTagPair,\n        emmetIncrementNumber1: (editor: CodeMirror.Editor) => incrementNumber(editor, 1),\n        emmetIncrementNumber01: (editor: CodeMirror.Editor) => incrementNumber(editor, .1),\n        emmetIncrementNumber10: (editor: CodeMirror.Editor) => incrementNumber(editor, 10),\n        emmetDecrementNumber1: (editor: CodeMirror.Editor) => incrementNumber(editor, -1),\n        emmetDecrementNumber01: (editor: CodeMirror.Editor) => incrementNumber(editor, -.1),\n        emmetDecrementNumber10: (editor: CodeMirror.Editor) => incrementNumber(editor, -10),\n        emmetRemoveTag,\n        emmetSelectNextItem: (editor: CodeMirror.Editor) => selectItem(editor),\n        emmetSelectPreviousItem: (editor: CodeMirror.Editor) => selectItem(editor, true),\n        emmetSplitJoinTag,\n    });\n\n    // Track options change\n    CM.defineOption('emmet', defaultConfig, (editor: CodeMirror.Editor, value: EmmetConfig) => {\n        if (!hasInternalState(editor)) {\n            editor.on('change', undoTracker);\n            editor.on('change', pasteTracker);\n        }\n\n        const state = getInternalState(editor);\n        value = getEmmetConfig(editor, value);\n\n        if (value.mark && !state.tracker) {\n            state.tracker = abbreviationTracker(editor);\n        } else if (!value.mark && state.tracker) {\n            state.tracker();\n            state.tracker = null;\n        }\n\n        if (value.markTagPairs && !state.tagMatch) {\n            state.tagMatch = matchTags(editor);\n        } else if (!value.markTagPairs && state.tagMatch) {\n            state.tagMatch();\n            state.tagMatch = null;\n        }\n    });\n\n    CM.defineMode('emmet-abbreviation', markupMode);\n    CM.defineMode('emmet-css-abbreviation', stylesheetMode);\n    CM.defineMode('emmet-snippet', snippetMode);\n\n    // Expose `expandAbbreviation` method to all instances to allow\n    // programmatic usage based on current Emmet options\n    CM.defineExtension('expandAbbreviation', function (this: CodeMirror.Editor, abbr: string, options = getOptions(this, 0)) {\n        return expand(this, abbr, options);\n    });\n\n    CM.defineExtension('emmetOptions', function (this: CodeMirror.Editor, pos = 0) {\n        return getOptions(this, pos);\n    });\n\n    CM.defineExtension('parseAbbreviation', function (this: CodeMirror.Editor, abbr: string, type: 'markup' | 'stylesheet' | 'jsx') {\n        if (type === 'stylesheet') {\n            return parseStylesheet(tokenizeStylesheet(abbr));\n        } else {\n            return parseMarkup(tokenizeMarkup(abbr), { jsx: type === 'jsx' });\n        }\n    });\n\n    CM.defineExtension('getEmmetCompletion', function (this: CodeMirror.Editor, pos: number | CodeMirror.Position) {\n        if (typeof pos !== 'number') {\n            pos = this.indexFromPos(pos);\n        }\n\n        return getCompletion(this, pos);\n    });\n}\n\n/**\n * Undo tracker, if possible\n */\nfunction undoTracker(editor: CodeMirror.Editor, change: CodeMirror.EditorChangeLinkedList) {\n    if (change.origin === 'undo' && change.text.length === 1) {\n        const pos = editor.indexFromPos(change.from);\n        const abbr = change.text[0];\n        restoreOnUndo(editor, pos, abbr);\n    }\n}\n\n/**\n * Capture abbreviation on paste, if possible\n */\nfunction pasteTracker(editor: CodeMirror.Editor, change: CodeMirror.EditorChangeLinkedList) {\n    if (change.origin === 'paste' && change.text.length === 1 && allowTracking(editor, editor.indexFromPos(change.from))) {\n        // Try to capture abbreviation on paste\n        const pos = editor.indexFromPos(change.from) + change.text[0].length;\n        extractTracker(editor, pos, true);\n    }\n}\n\nexport { EmmetConfig, EmmetEditorOptions };\n"],"names":["isWhiteSpace","isQuote","isQuote$1","tokenize","getToken","operator","field","bracket","whiteSpace","literal","consumePlaceholder","isLiteral","createLiteral","isBracket","operatorType","last","tokenScanner","peek","readable","consume","error","isSiblingOperator","isLiteral$1","isOpenBracket","isBracket$1","isOperator","defaultQuotedOptions","isNumber","isAlpha","isAlphaNumericWord","isAlphaWord","isSpace","eatQuoted","eatPair","Scanner","ScannerError","scan","comment","operators","next","slice","abbreviation","statements","element","group","isChildOperator","isClimbOperator","isGroupStart","repeater","elementName","isEmpty","isRepeater","text","getText","shortAttribute","attributeSet","isCloseOperator","isAttributeSetStart","attribute","isAttributeSetEnd","quoted","isEquals","isCapitalizedLiteral","isClassNameOperator","isElementName","isTextStart","escaped","repeaterPlaceholder","repeaterNumber","repeater$1","literal$1","quote","isAllowedOperator","isElementName$1","isAllowedSpace","isAllowedRepeater","bracketType","tokenVisitor","stringify","urlRegex","emailRegex","convert","convertGroup","deepestNode","insertText","insertHref","convertStatement","isGroup","convertElement","stringifyName","stringifyValue","convertAttribute","isField","attachRepeater","parseAbbreviation","mergeTokens","shouldConsumeDashAfter","numberValue","colorValue","stringValue","isIdentPrefix","isKeyword","consumeNumber","isHex","colorAlpha","parseColor","parser","consumeProperty","isFunctionStart","isValueDelimiter","isImportant","consumeValue","isFragmentDelimiter","isValue","consumeArguments","isCloseBracket","isArgumentDelimiter","parse","parse$2","element$1","opt","parse$3","parse$1","defaultOptions","defaultConfig","attributeValue","stylesheetAbbreviation","markupAbbreviation","expand","pairs","isQuoted","isQuotedString","isExprString","createOptions","toCharCodes","consumeArray","consumeSection","nameStartChar","nameChar","ident","isTerminator","isUnquoted","consumePaired","getUnquotedValue","attributes","attributeName","unquoted","getAttributeValue","cdataOpen","cdataClose","commentOpen","commentClose","piStart","piEnd","erbStart","erbEnd","cdata","erb","processingInstruction","skipAttributes","isSpecial","consumeClosing","isSelfClose","getEmbeddedStyleSyntax","getMarkupAbbreviationContext","getStylesheetAbbreviationContext","mergeAttributes","mergeValue","mergeDeclarations","append","walk","findDeepest","isNode","resolveSnippets","walkResolve","mergeNodes","createOutputStream","push","_push","pushString","splitByLines","pushNewline","pushIndent","pushField","tagName","strCase","attrName","attrQuote","isBooleanAttribute","selfClose","isInline","elementMap","implicitTag","resolveImplicitTag","getParentElement","lowercase","latin","ru","sp","vocabularies","reLorem","lorem","rand","findRepeater","paragraph","sample","choice","sentence","capitalize","insertCommas","jsx","rename","xsl","matchesName","isAllowed","reElement","reModifier","blockCandidates1","blockCandidates2","bem","expandClassNames","expandShortNotation","getBEMData","uniqueClass","findBlockName","updateClass","getBlockName","parseBEM","getBEMDataFromContext","find","walk$1","createWalkState","caret","isSnippet","isInlineElement","pushTokens","splitByLines$1","shouldOutputAttribute","template","isTokenStart","isToken","createCommentState","commentNodeBefore","shouldComment","output","commentNodeAfter","htmlTagRegex","html","shouldFormat","getIndent","pushAttribute","pushSnippet","hasNewline","startsWithBlockTag","indentFormat","collectAttributes","shouldFormat$1","pushPrimaryAttributes","pushSecondaryAttributes","pushValue","isPrimaryAttribute","valueLength","haml","slim","pug","formatters","transform","reProperty","createSnippet","parseValue","collectKeywords","nest","snippetsSort","isProperty","scoreMatch","sum","color","asHex","asRGB","isShortHex","toShortHex","toHex","frac","pad","css","property","toCamelCase","propertyValue","outputImportant","outputToken","getSingleNumeric","getQuote","outputValue","gradientName","convertSnippets","isValueScope","getSnippetsForScope","resolveNode","resolveGradient","resolveValueKeywords","findBestMatch","resolveAsProperty","resolveAsSnippet","resolveNumericValue","cssValue","getUnmatchedPart","resolveKeyword","hasField","wrapWithField","getScoringPart","markupSnippets","stylesheetSnippets","xslSnippets","pugSnippets","variables","defaultSyntaxes","syntaxConfig","parseSnippets","resolveConfig","mergedData","peek$1","code","specialChars","defaultOptions$1","expandAbbreviation","stylesheet","markup","whitespace","reset","isKnownSelectorColon","match","balancedOutward","balancedInward","extract","cssBalancedInward","cssBalancedOutward","extractMath","emmetAbbreviationMode","getTokenName","getContent","pushRange","matchCSS","allocTag","releaseTag","isSpaceText","emmetCaptureAbbreviation","emmetResetAbbreviation","emmetEnterAbbreviationMode","emmetInsertLineBreak","emmetWrapWithAbbreviation","emmetBalance","emmetToggleComment","emmetEvaluateMath","emmetGoToTagPair","emmetRemoveTag","selectItem","emmetSplitJoinTag","abbreviationTracker","matchTags","markupMode","stylesheetMode","snippetMode","parseStylesheet","tokenizeStylesheet","parseMarkup","tokenizeMarkup"],"mappings":"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"}